[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "RiboTransVis",
    "section": "",
    "text": "Welcome!\nRibosome profiling (Ribo-seq) has emerged as a powerful technique in life sciences research, providing high-resolution insights into translation dynamics by capturing ribosome-protected fragments (RPFs) across the transcriptome. This approach has led to important discoveries, such as:\n\nIdentification of non-canonical translation events\nQuantitative measurement of translation efficiency\nDetection of novel translated open reading frames (ORFs)\nInsights into translational regulation under various physiological or pathological conditions\n\nHowever, analyzing Ribo-seq data alongside RNA-seq data in a comprehensive and reproducible way remains a challenge, especially when high-quality visualizations are required for publication.\nTo address this need, I developed RiboTransVis — an R package designed to streamline the integrated analysis and publication-ready visualization of Ribo-seq and RNA-seq datasets. The primary goal of this package is to simplify translational research workflows and support researchers in producing figures and insights that meet academic publishing standards.\nCompared to my previous tool, RiboProfiler (https://github.com/junjunlab/RiboProfiler), RiboTransVis does not rely on external programming environments such as Julia or Python. Its functionality is implemented entirely in R, which significantly reduces software dependencies and makes installation and use much more accessible.",
    "crumbs": [
      "Welcome!"
    ]
  },
  {
    "objectID": "Introdocution.html",
    "href": "Introdocution.html",
    "title": "1  Introdocution",
    "section": "",
    "text": "1.1 RiboTransVis\nriboTransVis is an R package specifically developed for analyzing and visualizing Ribo-seq (ribosome profiling) data, offering comprehensive features including quality control metrics, RPF occupancy visualization, and metagene analysis…. The package supports both transcriptome-aligned and genome-aligned BAM files, expanding its utility across different ribosome profiling experimental designs. Its efficient data processing strategy selectively extracts alignment data from specific genomic regions using GTF annotations, rather than loading entire BAM files into memory, significantly improving computational efficiency for single-gene visualizations. The package includes essential functionalities such as read length distribution analysis, frame-specific ribosome density visualization, RPM normalization, and rolling window smoothing, while seamlessly integrating with ggplot2 for publication-quality visualizations. These features, combined with its optimized performance, make riboTransVis an invaluable tool for computational biologists and RNA researchers investigating mRNA translation dynamics.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introdocution</span>"
    ]
  },
  {
    "objectID": "Introdocution.html#workflow",
    "href": "Introdocution.html#workflow",
    "title": "1  Introdocution",
    "section": "1.2 Workflow",
    "text": "1.2 Workflow\nHere is workflow illustration of riboTransVis:",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introdocution</span>"
    ]
  },
  {
    "objectID": "Introdocution.html#installation",
    "href": "Introdocution.html#installation",
    "title": "1  Introdocution",
    "section": "1.3 Installation",
    "text": "1.3 Installation\nriboTransVis is now on github. You can install it like this:\n\n# install.packages(\"devtools\")\ndevtools::install_github(\"junjunlab/riboTransVis\")\n\n# or\nremotes::install_github(\"junjunlab/riboTransVis\")\n\nFeel free to leave any suggestions or questions about riboTransVis at the following address: https://github.com/junjunlab/riboTransVis/issues.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introdocution</span>"
    ]
  },
  {
    "objectID": "Introdocution.html#future-plans",
    "href": "Introdocution.html#future-plans",
    "title": "1  Introdocution",
    "section": "1.4 Future plans",
    "text": "1.4 Future plans\nWe welcome any ideas or suggestions you may have for riboTransVis. Your feedback is invaluable in helping us improve the project. If you are interested in contributing, please feel free to reach out to us directly.\nAdditionally, we invite you to contribute your code on our GitHub repository for ribotransvis. Collaborating with the community is key to enhancing the functionality and usability of our tools, and we would love to see your contributions!",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introdocution</span>"
    ]
  },
  {
    "objectID": "Preprocessing.html",
    "href": "Preprocessing.html",
    "title": "\n1  Preprocessing\n",
    "section": "",
    "text": "1.1 Data download\nIn this tutorial, we use a publicly available yeast Ribo-seq dataset from the publication 《eIF5A Functions Globally in Translation Elongation and Termination》 (published in Molecular Cell) with GEO accession number GSE89704. as a demonstration to illustrate the upstream preprocessing workflow.\nWe retrieve the Aspera download links for each individual sample from SRA Explorer, and then use the Aspera command-line client (ascp) under a Linux environment to quickly and reliably download the corresponding FASTQ files:\n# #!/usr/bin/env bash\nascp -QT -l 300m -P33001 -i $HOME/.aspera/connect/etc/asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:vol1/fastq/SRR500/004/SRR5008134/SRR5008134.fastq.gz . && mv SRR5008134.fastq.gz WT.1.fastq.gz\nascp -QT -l 300m -P33001 -i $HOME/.aspera/connect/etc/asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:vol1/fastq/SRR500/005/SRR5008135/SRR5008135.fastq.gz . && mv SRR5008135.fastq.gz WT.2.fastq.gz\nascp -QT -l 300m -P33001 -i $HOME/.aspera/connect/etc/asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:vol1/fastq/SRR500/006/SRR5008136/SRR5008136.fastq.gz . && mv SRR5008136.fastq.gz eIF5Ad.1.fastq.gz\nascp -QT -l 300m -P33001 -i $HOME/.aspera/connect/etc/asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:vol1/fastq/SRR500/007/SRR5008137/SRR5008137.fastq.gz . && mv SRR5008137.fastq.gz eIF5Ad.2.fastq.gz\nascp -QT -l 300m -P33001 -i $HOME/.aspera/connect/etc/asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:vol1/fastq/SRR500/008/SRR5008138/SRR5008138.fastq.gz . && mv SRR5008138.fastq.gz WT.1HS.fastq.gz\nascp -QT -l 300m -P33001 -i $HOME/.aspera/connect/etc/asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:vol1/fastq/SRR533/004/SRR5335874/SRR5335874.fastq.gz . && mv SRR5335874.fastq.gz WT.2HS.fastq.gz\nascp -QT -l 300m -P33001 -i $HOME/.aspera/connect/etc/asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:vol1/fastq/SRR533/005/SRR5335875/SRR5335875.fastq.gz . && mv SRR5335875.fastq.gz eIF5Ad.2HS.fastq.gz\nascp -QT -l 300m -P33001 -i $HOME/.aspera/connect/etc/asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:vol1/fastq/SRR500/009/SRR5008139/SRR5008139.fastq.gz . && mv SRR5008139.fastq.gz eIF5Ad.1HS.fastq.gz",
    "crumbs": [
      "Preprocessing introduction",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Preprocessing</span>"
    ]
  },
  {
    "objectID": "Preprocessing.html#data-download",
    "href": "Preprocessing.html#data-download",
    "title": "2  Preprocessing",
    "section": "2.2 Data download",
    "text": "2.2 Data download\nWe retrieve the Aspera download links for each individual sample from SRA Explorer, and then use the Aspera command-line client (ascp) under a Linux environment to quickly and reliably download the corresponding FASTQ files:\n\n# #!/usr/bin/env bash\n# ascp -QT -l 300m -P33001 -i $HOME/.aspera/connect/etc/asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:vol1/fastq/SRR500/004/SRR5008134/SRR5008134.fastq.gz . && mv SRR5008134.fastq.gz WT.1.fastq.gz\n# ascp -QT -l 300m -P33001 -i $HOME/.aspera/connect/etc/asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:vol1/fastq/SRR500/005/SRR5008135/SRR5008135.fastq.gz . && mv SRR5008135.fastq.gz WT.2.fastq.gz\n# ascp -QT -l 300m -P33001 -i $HOME/.aspera/connect/etc/asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:vol1/fastq/SRR500/006/SRR5008136/SRR5008136.fastq.gz . && mv SRR5008136.fastq.gz eIF5Ad.1.fastq.gz\n# ascp -QT -l 300m -P33001 -i $HOME/.aspera/connect/etc/asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:vol1/fastq/SRR500/007/SRR5008137/SRR5008137.fastq.gz . && mv SRR5008137.fastq.gz eIF5Ad.2.fastq.gz\n# ascp -QT -l 300m -P33001 -i $HOME/.aspera/connect/etc/asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:vol1/fastq/SRR500/008/SRR5008138/SRR5008138.fastq.gz . && mv SRR5008138.fastq.gz WT.1HS.fastq.gz\n# ascp -QT -l 300m -P33001 -i $HOME/.aspera/connect/etc/asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:vol1/fastq/SRR533/004/SRR5335874/SRR5335874.fastq.gz . && mv SRR5335874.fastq.gz WT.2HS.fastq.gz\n# ascp -QT -l 300m -P33001 -i $HOME/.aspera/connect/etc/asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:vol1/fastq/SRR533/005/SRR5335875/SRR5335875.fastq.gz . && mv SRR5335875.fastq.gz eIF5Ad.2HS.fastq.gz\n# ascp -QT -l 300m -P33001 -i $HOME/.aspera/connect/etc/asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:vol1/fastq/SRR500/009/SRR5008139/SRR5008139.fastq.gz . && mv SRR5008139.fastq.gz eIF5Ad.1HS.fastq.gz",
    "crumbs": [
      "Ribo-seq Upstream",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Preprocessing</span>"
    ]
  },
  {
    "objectID": "Introduction.html",
    "href": "Introduction.html",
    "title": "Introduction",
    "section": "",
    "text": "RiboTransVis\nriboTransVis is an R package specifically developed for analyzing and visualizing Ribo-seq (ribosome profiling) data, offering comprehensive features including quality control metrics, RPF occupancy visualization, and metagene analysis…. The package supports both transcriptome-aligned and genome-aligned BAM files, expanding its utility across different ribosome profiling experimental designs. Its efficient data processing strategy selectively extracts alignment data from specific genomic regions using GTF annotations, rather than loading entire BAM files into memory, significantly improving computational efficiency for single-gene visualizations. The package includes essential functionalities such as read length distribution analysis, frame-specific ribosome density visualization, RPM normalization, and rolling window smoothing, while seamlessly integrating with ggplot2 for publication-quality visualizations. These features, combined with its optimized performance, make riboTransVis an invaluable tool for computational biologists and RNA researchers investigating mRNA translation dynamics.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "Introduction.html#workflow",
    "href": "Introduction.html#workflow",
    "title": "Introduction",
    "section": "Workflow",
    "text": "Workflow\nHere is workflow illustration of riboTransVis:",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "Introduction.html#installation",
    "href": "Introduction.html#installation",
    "title": "Introduction",
    "section": "Installation",
    "text": "Installation\nriboTransVis is now on github. You can install it like this:\n\n# install.packages(\"devtools\")\ndevtools::install_github(\"junjunlab/riboTransVis\")\n\n# or\nremotes::install_github(\"junjunlab/riboTransVis\")\n\nFeel free to leave any suggestions or questions about riboTransVis at the following address: https://github.com/junjunlab/riboTransVis/issues.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "Introduction.html#future-plans",
    "href": "Introduction.html#future-plans",
    "title": "Introduction",
    "section": "Future plans",
    "text": "Future plans\nWe welcome any ideas or suggestions you may have for riboTransVis. Your feedback is invaluable in helping us improve the project. If you are interested in contributing, please feel free to reach out to us directly.\nAdditionally, we invite you to contribute your code on our GitHub repository for ribotransvis. Collaborating with the community is key to enhancing the functionality and usability of our tools, and we would love to see your contributions!",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "Preprocessing-into.html",
    "href": "Preprocessing-into.html",
    "title": "Preprocessing introduction",
    "section": "",
    "text": "Ribosome profiling (Ribo-seq) data are typically generated through a multi-step experimental pipeline, starting from library preparation to sequencing on high-throughput platforms. The raw data output from sequencing is usually in FASTQ format and requires several preprocessing steps before downstream analysis.\nFirst, quality control should be performed on the raw FASTQ files using tools such as FastQC. To remove adapter contamination introduced during library preparation, trimming tools like Cutadapt or Trim Galore are commonly used. During size selection in the library construction process (e.g., gel purification), fragments within a specific length range are enriched. However, these can still include contaminating small RNAs such as rRNAs and tRNAs.\nTo eliminate these unwanted reads, it is essential to align sequences to a custom database of rRNA, tRNA, and other non-coding RNAs (downloadable from resources like NCBI and Ensembl) and remove matching reads. This filtering helps retain only high-confidence ribosome-protected footprints (RPFs), representing genuine translation events.\nThe cleaned reads can then be aligned to the reference genome or transcriptome using alignment tools such as STAR or HISAT2. Quantification of read counts across gene features can be performed using tools like featureCounts or HTSeq. After quantification, differential translation efficiency analysis between experimental conditions, enriched pathway analysis, and other integrative analyses can be carried out to interpret the biological significance of the translation landscape.",
    "crumbs": [
      "Preprocessing introduction"
    ]
  },
  {
    "objectID": "Preprocessing.html#yeast-genome-and-annotation-retrieval",
    "href": "Preprocessing.html#yeast-genome-and-annotation-retrieval",
    "title": "\n1  Preprocessing\n",
    "section": "\n1.2 Yeast Genome and Annotation Retrieval",
    "text": "1.2 Yeast Genome and Annotation Retrieval\nWe obtained the genome sequence (FASTA) and gene annotation (GTF) files for the yeast species from the Ensembl database:\n\nwget https://ftp.ensembl.org/pub/release-112/fasta/saccharomyces_cerevisiae/dna/Saccharomyces_ceree.R64-1-1.dna.toplevel.fa.gz \n\nwget https://ftp.ensembl.org/pub/release-112/gtf/saccharomyces_cerevisiae/Saccharomyces_cerevisiae.R64-1-1.112.gtf.gz\n\ngunzip Saccharomyces_cerevisiae.R64-1-1.dna.toplevel.fa.gz \n\ngunzip Saccharomyces_cerevisiae.R64-1-1.112.gtf.gz",
    "crumbs": [
      "Preprocessing introduction",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Preprocessing</span>"
    ]
  },
  {
    "objectID": "Preprocessing.html#constructing-rrna-and-genome-index",
    "href": "Preprocessing.html#constructing-rrna-and-genome-index",
    "title": "\n1  Preprocessing\n",
    "section": "\n1.3 Constructing rRNA and genome Index",
    "text": "1.3 Constructing rRNA and genome Index\nRibosomal RNA (rRNA) sequences for most species are available from public databases such as NCBI or Ensembl in FASTA format. After downloading, we use the Bowtie2 aligner to construct an index for read alignment and rRNA contamination removal：\n\nbowtie2-build sac.rRNA.fasta sac_rRNA_index/sac_rRNA\n\nAlignment tools such as Bowtie2 and HISAT2 provide pre-built genome indices for many commonly studied species on their official websites. These can be downloaded and used directly to save time. However, if your organism of interest is not included, you can generate the index manually from the reference genome FASTA file using the tool’s indexing function:\n\nbowtie2-build sac.genome.fasta sac_genome_index/sac_genome\n\nhisat2-build sac.genome.fasta sac_genome_index/sac_genome",
    "crumbs": [
      "Preprocessing introduction",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Preprocessing</span>"
    ]
  },
  {
    "objectID": "Preprocessing.html#removal-of-adapter-contamination",
    "href": "Preprocessing.html#removal-of-adapter-contamination",
    "title": "\n1  Preprocessing\n",
    "section": "\n1.4 Removal of Adapter Contamination",
    "text": "1.4 Removal of Adapter Contamination\nTo ensure high-quality input for downstream analysis, we first examine the raw FASTQ files using FastQC to evaluate overall sequence quality and to identify potential adapter contamination. If adapter sequences are present, we remove them using Cutadapt, a commonly used tool for trimming adapter sequences from high-throughput sequencing reads:\n\n# trim\nfor i in WT.1 WT.2 eIF5Ad.1 eIF5Ad.2 WT.1HS WT.2HS eIF5Ad.1HS eIF5Ad.2HS\ndo cutadapt -j 15 -m 20 -M 35 \\\n            --match-read-wildcards \\\n            -a CTGTAGGCACCATCAAT \\\n            -o 1.trim-data/${i}.trim.fq.gz 0.raw-data/${i}.fastq.gz\ndone",
    "crumbs": [
      "Preprocessing introduction",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Preprocessing</span>"
    ]
  },
  {
    "objectID": "Preprocessing.html#removal-of-rrna-contamination",
    "href": "Preprocessing.html#removal-of-rrna-contamination",
    "title": "\n1  Preprocessing\n",
    "section": "\n1.5 Removal of rRNA Contamination",
    "text": "1.5 Removal of rRNA Contamination\nIn eukaryotes, ribosomal RNA (rRNA) can account for approximately 80%–90% of total RNA. Therefore, assessing the proportion of sequencing reads that align to rRNA sequences serves as an important quality control metric for evaluating the effectiveness of RNA library preparation. Many laboratories or sequencing service providers use commercial rRNA depletion kits to remove these abundant molecules prior to sequencing.\nIn this workflow, we use Bowtie2 to align raw reads to the rRNA reference sequences and remove the reads that map to rRNA. Only the unmapped reads are retained for downstream analyses.\nIf more stringent filtering is required to eliminate other unwanted small RNA contaminants, such as tRNA, you can also download the corresponding reference sequences, build a Bowtie2 index, and filter out these reads in a similar manner.\n\n# trim rRNA\nfor i in WT.1 WT.2 eIF5Ad.1 eIF5Ad.2 WT.1HS WT.2HS eIF5Ad.1HS eIF5Ad.2HS\ndo \n    bowtie2 -p 20 -x ../index-data/sac-rRNA-index/Saccharomyces-cerevisiae-rRNA \\\n            --un-gz 2.rmrRNA-data/${i}.rmrRNA.fq.gz \\\n            -U 1.trim-data/${i}.trim.fq.gz \\\n            -S 2.rmrRNA-data/null\ndone",
    "crumbs": [
      "Preprocessing introduction",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Preprocessing</span>"
    ]
  },
  {
    "objectID": "Preprocessing.html#alignment-to-the-reference-genome",
    "href": "Preprocessing.html#alignment-to-the-reference-genome",
    "title": "\n1  Preprocessing\n",
    "section": "\n1.6 Alignment to the Reference Genome",
    "text": "1.6 Alignment to the Reference Genome\nAfter removing rRNA reads, we align the remaining clean reads to the yeast reference genome using HISAT2, a fast and memory-efficient spliced alignment tool optimized for high-throughput sequencing data:\n\nfor i in WT.1 WT.2 eIF5Ad.1 eIF5Ad.2 WT.1HS WT.2HS eIF5Ad.1HS eIF5Ad.2HS\ndo \n    hisat2 -p 20 -x ../index-data/sac-hisat2-index/sac \\\n           -k 1 -U 2.rmrRNA-data/${i}.rmrRNA.fq.gz \\\n           |samtools sort -@ 20 -o 3.map-data/${i}.sorted.bam\ndone",
    "crumbs": [
      "Preprocessing introduction",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Preprocessing</span>"
    ]
  },
  {
    "objectID": "Preprocessing.html#alignment-to-the-transcriptome",
    "href": "Preprocessing.html#alignment-to-the-transcriptome",
    "title": "\n1  Preprocessing\n",
    "section": "\n1.7 Alignment to the Transcriptome",
    "text": "1.7 Alignment to the Transcriptome\nIn certain cases, specific analyses—such as Ribo-seq studies that aim to determine the precise position of each read on a transcript, or assess features like 3-nucleotide periodicity and translation periodicity—require mapping reads directly to the transcriptome rather than the genome.\nTo perform transcriptome alignment, you first need to download the transcript sequences for the species of interest and build a corresponding index file. The reads can then be aligned to the transcriptome using an appropriate aligner (e.g., Bowtie2 or HISAT2), enabling more accurate downstream analysis in transcript-centric workflows.\n\nfor i in WT.1 WT.2 eIF5Ad.1 eIF5Ad.2 WT.1HS WT.2HS eIF5Ad.1HS eIF5Ad.2HS\ndo \n    hisat2 -p 20 -x ../index-data/sac-hisat2-trans-index/sac \\\n           -k 1 -U 2.rmrRNA-data/${i}.rmrRNA.fq.gz \\\n           |samtools sort -@ 20 -o 3.map-data/${i}.sorted.bam\ndone",
    "crumbs": [
      "Preprocessing introduction",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Preprocessing</span>"
    ]
  },
  {
    "objectID": "Extract-sequence.html",
    "href": "Extract-sequence.html",
    "title": "\n2  Sequence Extraction\n",
    "section": "",
    "text": "2.1 Preparing transcript sequences\nThe riboTransVis package provides several functions to extract transcript and CDS sequences, facilitating seamless integration with downstream analyses within the package.",
    "crumbs": [
      "Preprocessing introduction",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Sequence Extraction</span>"
    ]
  },
  {
    "objectID": "Extract-sequence.html#renaming-transcript-sequences-from-ensembl",
    "href": "Extract-sequence.html#renaming-transcript-sequences-from-ensembl",
    "title": "\n2  Sequence Extraction\n",
    "section": "\n2.2 Renaming transcript sequences from Ensembl",
    "text": "2.2 Renaming transcript sequences from Ensembl\nIf you are aligning reads to the transcriptome and working with transcriptome-aligned BAM files, riboTransVis requires transcript sequence names in a specific format: transcript_ID|gene_name.\nIf you downloaded transcriptome sequence files from the Ensembl database, you can use the prepare_transcript_file() function to convert the sequence names to the required format. Below is an example using a transcriptome FASTA file of S. cerevisiae (yeast) downloaded from Ensembl:\n\nwget https://ftp.ensembl.org/pub/release-113/fasta/saccharomyces_cerevisiae/cdna/Saccharomyces_cerevisiae.R64-1-1.cdna.all.fa.gz\n\nzless Saccharomyces_cerevisiae.R64-1-1.cdna.all.fa.gz\n\n&gt;YPL071C_mRNA cdna chromosome:R64-1-1:XVI:420048:420518:-1 gene:YPL071C gene_biotype:protein_coding transcript_biotype:protein_coding description:Putative protein of unknown function; green fluorescent protein (GFP)-fusion protein localizes to both the cytoplasm and the nucleus [Source:SGD;Acc:S000005992]\nATGAGTTCCCGGTTTGCAAGAAGTAATGGCAATCCCAACCACATTAGGAAAAGAAATCAT\nTCTCCAGACCCAATAGGAATTGATAATTATAAAAGAAAAAGACTAATTATAGATTTAGAG\nAATTTATCCTTAAATGATAAAGGGCCCAAGAACGGACATGCAGATGATAACAATCTTATT\nCATAACAATATAGTATTCACAGACGCTATTGATGATAAGGTCCTGAAAGAGATCATCAAG\nTGTTCCACAAGTAAACGCGGCGACAATGACTTGTTTTATGACAAAATATGGGAACGTTTG\nAGAGAAAAAAGGCTACAAATAATAAAATGGGTAGATTATAAGGAAATTGCTTATCTAAGC\nTGGTGGAAGTGGTTCCATAATCAAATGACTTCGAAATACACTTATGATGGAGAGGCTGAT\nACCGATGTTGAAATGATGGCAGTGGATACTGATGTGGATATGGATGCGTAA\n&gt;YLL050C_mRNA cdna chromosome:R64-1-1:XII:39804:40414:-1 gene:YLL050C gene_biotype:protein_coding transcript_biotype:protein_coding gene_symbol:COF1 description:Cofilin, involved in pH-dependent actin filament depolarization; binds both actin monomers and filaments and severs filaments; involved in the selective sorting, export of the secretory cargo from the late golgi; genetically interacts with pmr1; thought to be regulated by phosphorylation at SER4; ubiquitous and essential in eukaryotes [Source:SGD;Acc:S000003973]\nATGTCTAGATCTGGTGTTGCTGTTGCTGATGAATCCCTTACCGCTTTCAATGACTTGAAA\nTTGGGTAAAAAATACAAATTTATTTTATTCGGATTGAACGATGCTAAAACCGAAATCGTT\nGTCAAGGAAACCTCTACTGACCCATCTTACGATGCCTTCTTAGAGAAATTGCCAGAAAAC\nGACTGTCTTTACGCCATTTACGATTTTGAATACGAAATTAATGGTAATGAAGGTAAGAGA\nTCCAAGATTGTTTTCTTCACTTGGTCTCCAGACACTGCTCCAGTCAGATCTAAGATGGTC\nTATGCATCCTCCAAGGATGCCTTAAGAAGAGCCTTAAACGGTGTCTCTACCGATGTTCAA\nGGTACTGATTTTTCCGAAGTTTCTTACGATTCTGTTTTGGAAAGAGTCAGCAGAGGCGCT\nGGTTCTCATTAA\n\nSimply providing the input FASTA file and specifying the output FASTA file is sufficient to complete the conversion:\n\nlibrary(riboTransVis)\n\nprepare_transcipt_file(transcript_fa = \"../Saccharomyces_cerevisiae.R64-1-1.cdna.all.fa\",\n                       output_path = \"../sac_trans.fa\")\n\nThe figure below shows a comparison of the transcriptome FASTA file before and after ID conversion:",
    "crumbs": [
      "Preprocessing introduction",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Sequence Extraction</span>"
    ]
  },
  {
    "objectID": "Extract-sequence.html#extracting-the-transcriptome-file",
    "href": "Extract-sequence.html#extracting-the-transcriptome-file",
    "title": "\n2  Sequence Extraction\n",
    "section": "\n2.3 Extracting the transcriptome File",
    "text": "2.3 Extracting the transcriptome File\nAlternatively, riboTransVis provides the get_transcript_sequence() function, which can be used to extract all transcript sequences based on the genome FASTA file and the corresponding GTF annotation file.\nSince most genes in yeast species lack annotated UTR regions, it is often beneficial to extend the transcript sequences upstream and downstream to facilitate Ribo-seq–related analyses. This can be done using the extend parameter. Typically, an extension of 50 nucleotides is sufficient.\n\nget_transcript_sequence(genome_file = \"../../index-data/Saccharomyces_cerevisiae.R64-1-1.dna.toplevel.fa\",\n                        gtf_file = \"../../index-data/Saccharomyces_cerevisiae.R64-1-1.112.gtf\",\n                        feature = \"exon\",\n                        extend = T,\n                        extend_upstream = 50,\n                        extend_downstream = 50,\n                        output_file = \"sac_trans.fa\")",
    "crumbs": [
      "Preprocessing introduction",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Sequence Extraction</span>"
    ]
  },
  {
    "objectID": "Extract-sequence.html#extracting-cds-sequences",
    "href": "Extract-sequence.html#extracting-cds-sequences",
    "title": "\n2  Sequence Extraction\n",
    "section": "\n2.4 Extracting CDS sequences",
    "text": "2.4 Extracting CDS sequences\nIn certain analyses, coding sequence (CDS) information may be required. You can extract the CDS regions from all transcripts by setting feature = “CDS”:\n\nget_transcript_sequence(genome_file = \"../../index-data/Saccharomyces_cerevisiae.R64-1-1.dna.toplevel.fa\",\n                        gtf_file = \"../../index-data/Saccharomyces_cerevisiae.R64-1-1.112.gtf\",\n                        feature = \"CDS\",\n                        output_file = \"sac_cds.fa\")",
    "crumbs": [
      "Preprocessing introduction",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Sequence Extraction</span>"
    ]
  },
  {
    "objectID": "Object-construct.html",
    "href": "Object-construct.html",
    "title": "Object construction",
    "section": "",
    "text": "Introduction\nThe riboTransVis package provides support for constructing two core S4 object types: ribotrans and serp.\nThe ribotrans object is designed for standard ribosome profiling (Ribo-seq) data analysis. It encapsulates common inputs such as read coverage, transcript features, and annotation metadata, enabling downstream analyses like occupancy profiling, differential translation, and transcript-level visualization.\nThe serp object extends this functionality for analyzing selective ribosome profiling (selective Ribo-seq) experiments, which are often used to investigate specialized ribosome populations (e.g., via immunoprecipitation). In addition to inheriting all slots and methods from ribotrans, the serp class introduces additional slots for IP and total RNA signals, enrichment ratios, and specialized metadata structures.\nBecause serp is derived from ribotrans, many methods implemented for ribotrans objects are also compatible with serp objects, ensuring a consistent and modular workflow across both conventional and selective Ribo-seq data types.\nTogether, these two object classes provide a flexible and extensible structure for managing and analyzing diverse Ribo-seq datasets in an efficient and scalable manner.",
    "crumbs": [
      "Object construction"
    ]
  },
  {
    "objectID": "Extract-reads-info.html",
    "href": "Extract-reads-info.html",
    "title": "Extract reads",
    "section": "",
    "text": "Extracting Alignment Information with generate_summary\nRibosome profiling (Ribo-seq) typically requires detailed analysis of aligned reads — including which genes they map to, their read lengths, alignment positions, and more. These features are critical for downstream analyses such as P-site detection, triplet periodicity evaluation, and ribosome occupancy profiling.\nThe RiboTrans function generate_summary() extracts comprehensive information about all mapped reads from BAM files, including:\nThe extracted data is stored in the Slot \"summary_info\" of the RiboTrans object and forms the foundation for the majority of downstream analyses.\n⚙️ If the parameter mapping_type = \"genome\" is used, the function will automatically convert genome-based coordinates into transcriptomic coordinates before storing the results.\nBecause the output from generate_summary serves as the primary input for most later steps in the pipeline, running this function is a fundamental and essential part of RiboTrans analysis.",
    "crumbs": [
      "Extract reads"
    ]
  },
  {
    "objectID": "Extract-reads-info.html#extracting-alignment-information-with-generate_summary",
    "href": "Extract-reads-info.html#extracting-alignment-information-with-generate_summary",
    "title": "Extract reads",
    "section": "",
    "text": "The gene or transcript each read aligns to\nRead length\nRead start and end positions (in transcriptomic coordinates)\n…\n\n\n\n\nExample:\nThe following code extracts alignment information from BAM files for each sample:\n\n# generate summary data for QC or other analysis\nobj0 &lt;- generate_summary(object = obj0, exp_type = \"ribo\", nThreads = 20)\n\nhead(obj0@summary_info)\n#               rname  pos qwidth count  sample sample_group mstart mstop translen\n# 1 YAL067C_mRNA|SEO1 1774     27     1 wt-rep1      wt-rep1     51  1829     1882\n# 2 YAL067C_mRNA|SEO1 1771     27     1 wt-rep1      wt-rep1     51  1829     1882\n# 3 YAL067C_mRNA|SEO1 1766     20     1 wt-rep1      wt-rep1     51  1829     1882\n# 4 YAL067C_mRNA|SEO1 1761     27     1 wt-rep1      wt-rep1     51  1829     1882\n# 5 YAL067C_mRNA|SEO1 1662     28     1 wt-rep1      wt-rep1     51  1829     1882\n# 6 YAL067C_mRNA|SEO1 1632     25     1 wt-rep1      wt-rep1     51  1829     1882\n\n📌 Column Descriptions\n\nrname: A compound field combining the transcript ID and gene name, separated by a vertical bar (|). If the gene name is missing in the GTF annotation, only the transcript ID is shown.\npos: The position (in transcriptomic coordinates) that the read maps to within the transcript.\nqwidth: The width (i.e., length) of the read in nucleotides.\ncount: The number of reads that map to this exact position with the same length.\nsample: The name of the sample from which the read originated.\nsample_group: The user-defined group the sample belongs to. If no grouping was provided during setup, the sample name is used as the group name by default.\nmstart / mstop: The start and end positions of the coding sequence (CDS) region on the transcript.\ntranslen: The total length of the transcript in nucleotides.\n\nThis detailed read-level summary forms the foundation for various downstream analyses — including ribosome occupancy, metagene profiling, and P-site calibration — making it an essential and informative step in the RiboTransVis workflow.",
    "crumbs": [
      "Extract reads"
    ]
  },
  {
    "objectID": "Ribo-QC.html",
    "href": "Ribo-QC.html",
    "title": "3  Ribo-seq QC check",
    "section": "",
    "text": "3.1 Importance of Ribo-seq Quality Control\nRibosome profiling (Ribo-seq) provides high-resolution insights into translation by capturing ribosome-protected fragments (RPFs). To ensure the biological interpretability of Ribo-seq data, rigorous quality control (QC) is essential before proceeding with downstream analyses such as P-site mapping, translation efficiency assessment, and metagene profiling.\nQC not only evaluates the technical reliability of the experiment but also helps detect and troubleshoot problems such as poor nuclease digestion, contamination by non-ribosomal fragments, or alignment errors.",
    "crumbs": [
      "Quality assessment",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Ribo-seq QC check</span>"
    ]
  },
  {
    "objectID": "Ribo-QC.html#key-ribo-seq-qc-metrics",
    "href": "Ribo-QC.html#key-ribo-seq-qc-metrics",
    "title": "3  Ribo-seq QC check",
    "section": "3.2 Key Ribo-seq QC Metrics",
    "text": "3.2 Key Ribo-seq QC Metrics\nBelow is a list of commonly used QC indicators in Ribo-seq analysis, along with their biological significance and how to interpret them:\n\n\n\n\n\n\n\n\n\nQC Metric\nDescription\nGood Quality\nPotential Issues\n\n\n\n\nRead Length Distribution\nDistribution of lengths of aligned reads (typically 26–34 nt for RPFs)\nClear peak at expected length (e.g., ~28-30 nt)\nBroad or irregular distribution (non-specific cleavage or contamination)\n\n\nMapping Rate\nPercentage of reads aligned to genome/transcriptome\n≥ 70–80%\n&lt; 50% may indicate contamination or poor library complexity\n\n\nrRNA Contamination\nProportion of reads mapped to ribosomal RNA\n~80%\nA lower percentage indicates less rRNA contamination and results in more usable RPF reads for downstream analysis.\n\n\nFraction Mapping to CDS\nPercentage of mapped reads falling within coding sequences\n&gt; 70%\n&lt; 50% may reflect non-specific digestion or contamination\n\n\n3-Nucleotide Periodicity\nTriplet periodicity of reads within CDS regions\nStrong periodic pattern in 1 frame\nWeak/no signal may reflect mixed fragments or poor run-off conditions\n\n\nMetagene Profile\nAggregated read density near TIS or stop codons\nClear peaks around start/stop codons\nFlat or noisy signal indicates low signal-to-noise\n\n\nSample Correlation\nCorrelation between replicates or conditions\nHigh within-group correlation (e.g. ≥ 0.9)\nLow correlation suggests biological/technical variability\n\n\nP-site Offset Calibration\nPosition of the ribosome P-site within RPFs\nConsistent offset (e.g., 12 nt for 28-mers)\nInconsistent offsets reduce positional accuracy",
    "crumbs": [
      "Quality assessment",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Ribo-seq QC check</span>"
    ]
  },
  {
    "objectID": "Ribo-QC.html#interpretation-guidelines",
    "href": "Ribo-QC.html#interpretation-guidelines",
    "title": "3  Ribo-seq QC check",
    "section": "3.3 Interpretation Guidelines",
    "text": "3.3 Interpretation Guidelines\n\n💚 Good QC results indicate that the RPFs are predominantly ribosome-associated, length-specific, and mapped correctly — enabling accurate ribosome profiling.\n⚠️ Deviation in one or more metrics does not always render a dataset unusable but warrants closer inspection.\n❗ Consistent failure across multiple metrics suggests technical issues during library preparation or sequencing and may require repeating the experiment.",
    "crumbs": [
      "Quality assessment",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Ribo-seq QC check</span>"
    ]
  },
  {
    "objectID": "Ribo-QC.html#ribo-seq-quality-assessment-with-ribotransvis",
    "href": "Ribo-QC.html#ribo-seq-quality-assessment-with-ribotransvis",
    "title": "3  Ribo-seq QC check",
    "section": "3.4 Ribo-seq Quality Assessment with riboTransVis",
    "text": "3.4 Ribo-seq Quality Assessment with riboTransVis\nThe riboTransVis package provides a comprehensive suite of visualization tools specifically designed for assessing the quality of Ribo-seq data. These functions enable users to evaluate data fidelity from multiple angles, helping determine whether the experimental library faithfully captures ribosome-protected fragments (RPFs) with the expected biological characteristics.\nRather than relying on a single metric, riboTransVis supports a multi-dimensional approach to quality control (QC), incorporating both read-level features and transcript-level patterns. This enables users to comprehensively inspect the integrity, specificity, and biological relevance of their data.\n\n3.4.1 Core QC Visualization Functions\nBelow is a summary of key QC functions available in riboTransVis, each targeting a specific aspect of Ribo-seq data quality:\n\n\n\n\n\n\n\nFunction Name\nDescription\n\n\n\n\nframe_plot()\nEvaluates 3-nt periodicity by plotting the frame distribution of P-sites within CDS regions.\n\n\nlength_plot()\nVisualizes the distribution of read lengths after filtering, helping identify dominant RPF sizes.\n\n\nfeature_plot()\nAssesses read distributions across genomic features (CDS, UTRs, introns), estimating data purity.\n\n\nwhole_metagene_plot()\nAggregates read density across whole transcript.\n\n\nrelative_dist_plot()\nShows how periodicity relative to start/stop codons.\n\n\nrelative_heatmap_plot()\nGenerates a heatmap showing positional enrichment of reads near start/stop codons.\n\n\nrelative_offset_plot()\nDetermines optimal P-site offsets by comparing positional patterns across read lengths.\n\n\nmetagene_plot()\nDisplays transcript-specific metagene profiles, useful for assessing translation initiation bias.\n\n\n\n\n\n3.4.2 Interpretation and Utility\nThese visualizations collectively allow researchers to:\n\nConfirm the presence of strong triplet periodicity across CDS regions;\nVerify RPF enrichment near annotated start and stop codons;\nDetect contamination or non-ribosome-associated fragments (e.g., reads mapping primarily to UTRs or introns);\nCalibrate and validate P-site offset estimates across read lengths;\nIdentify variations between replicates or conditions that may reflect biological or technical differences.\n\nUsing riboTransVis alongside RiboTrans enables automated, reproducible, and publication-ready QC assessments of Ribo-seq datasets.",
    "crumbs": [
      "Quality assessment",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Ribo-seq QC check</span>"
    ]
  },
  {
    "objectID": "Length-plot.html",
    "href": "Length-plot.html",
    "title": "\n4  Length distribution\n",
    "section": "",
    "text": "4.1 Introduction\nThe length_plot() function is used to visualize the distribution of read lengths in Ribo-seq data, an important metric for quality assessment. In a successful Ribo-seq experiment, most reads—referred to as ribosome-protected fragments (RPFs)—typically fall within a narrow length range (e.g., 28–30 nucleotides) corresponding to the size of the ribosome footprint.\nBy plotting the read length distribution, users can:\nA well-shaped length distribution plot with distinct peaks at expected sizes generally indicates high-quality digestion and successful capture of translating ribosomes.\nlength_plot(obj0)\nBy specifying type = “frame_length”, the function generates a frame-resolved read length distribution plot. The overlaid numbers represent the proportion of reads in frame 0 for each read length, assisting in the identification of lengths with strong 3-nt periodicity：\nlength_plot(obj0,type = \"frame_length\")\nIf you do not wish to display the frame 0 periodicity, you can disable it by setting add_periodicity_label = FALSE.",
    "crumbs": [
      "Quality assessment",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Length distribution</span>"
    ]
  },
  {
    "objectID": "Length-plot.html#introduction",
    "href": "Length-plot.html#introduction",
    "title": "\n4  Length distribution\n",
    "section": "",
    "text": "Confirm the presence of a dominant RPF length.\nDetect potential contamination (non-specific fragments).\nAdjust downstream analysis parameters, such as read-length selection for P-site calibration and metagene profiling.",
    "crumbs": [
      "Quality assessment",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Length distribution</span>"
    ]
  },
  {
    "objectID": "Frame-plot.html",
    "href": "Frame-plot.html",
    "title": "\n5  In frame ratio\n",
    "section": "",
    "text": "5.1 Reading Frame and Quality Assessment in Ribo-seq\nRibosome profiling (Ribo-seq) is a powerful technique to study translation in vivo by sequencing the protected mRNA fragments (RPFs, Ribosome-Protected Fragments) associated with translating ribosomes. One hallmark of high-quality Ribo-seq data is the strong 3-nucleotide (nt) periodicity observed in coding sequences (CDS), reflecting the triplet codon structure recognized by translating ribosomes.",
    "crumbs": [
      "Quality assessment",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>In frame ratio</span>"
    ]
  },
  {
    "objectID": "Frame-plot.html#reading-frame-and-quality-assessment-in-ribo-seq",
    "href": "Frame-plot.html#reading-frame-and-quality-assessment-in-ribo-seq",
    "title": "\n5  In frame ratio\n",
    "section": "",
    "text": "5.1.1 What is “Reading Frame” in Ribo-seq?\nIn Ribo-seq data analysis, each RPF can be assigned to a reading frame based on its P-site position relative to the annotated coding region:\n\nFrame 0: Aligned with the annotated coding frame (i.e., P-site at the first nucleotide of a codon)\nFrame 1: Offset by +1 nt from frame 0\nFrame 2: Offset by +2 nt from frame 0\n\n5.1.2 In-frame ratio: A key quality metric\nA well-annotated and high-quality Ribo-seq experiment typically shows a clear enrichment of reads in frame 0 within annotated CDS regions. This behavior is quantified by the in-frame ratio, which measures the proportion of reads that fall into frame 0 among all reads mapping to coding regions.\nA strong in-frame signal indicates:\n\nAccurate P-site offset calibration\nHigh signal-to-noise ratio (i.e., true ribosome-derived footprints dominate)\nProper rRNA/tRNA depletion and library preparation\n\n\nTip: In-frame ratio is best evaluated on well-expressed coding sequences to avoid sampling noise from low-coverage genes.\n\n\n5.1.3 To check frame periodicity:\nYou can use visualization tools (e.g., metagene analysis, frame_length plots) or frame-specific coverage summaries to assess periodicity. Some Ribo-seq analysis packages provide automatic frame bias summaries for quick evaluation.",
    "crumbs": [
      "Quality assessment",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>In frame ratio</span>"
    ]
  },
  {
    "objectID": "Frame-plot.html#periodicity-plot",
    "href": "Frame-plot.html#periodicity-plot",
    "title": "\n5  In frame ratio\n",
    "section": "\n5.2 Periodicity plot",
    "text": "5.2 Periodicity plot\nThe frame_plot() function can be used to evaluate and visualize the overall distribution of reads across the three reading frames (0, 1, and 2) in a sample:\n\nframe_plot(obj0)\n\nThis plot helps assess the quality of Ribo-seq data by revealing frame-specific read enrichment—ideally showing a strong bias toward frame 0 in coding regions, which reflects good 3-nt periodicity.",
    "crumbs": [
      "Quality assessment",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>In frame ratio</span>"
    ]
  },
  {
    "objectID": "Meta-heatmap-plot.html",
    "href": "Meta-heatmap-plot.html",
    "title": "\n9  Meta heatmap plot\n",
    "section": "",
    "text": "9.1 Heatmap of read distribution relative to start/stop Codons",
    "crumbs": [
      "Quality assessment",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Meta heatmap plot</span>"
    ]
  },
  {
    "objectID": "Meta-heatmap-plot.html#heatmap-of-read-distribution-relative-to-startstop-codons",
    "href": "Meta-heatmap-plot.html#heatmap-of-read-distribution-relative-to-startstop-codons",
    "title": "\n9  Meta heatmap plot\n",
    "section": "",
    "text": "9.1.1 Translational landscape around start/stop Sites\nIn Ribo-seq analysis, visualizing how ribosome footprints (RPFs) are distributed around translation start and stop codons provides valuable insights into translation initiation and termination dynamics. One common approach is to summarize read density by both position and fragment length (read width), and display it as a heatmap centered on CDS boundaries.\n\n9.1.2 What Does the Heatmap Show?\nThe relative_heatmap_plot() function generates a two-dimensional heatmap showing the abundance of RPFs aligned relative to either:\n\nThe start codon (type = “rel2start”), or\nThe stop codon (type = “rel2stop”)\n\nThe heatmap shows:\n\nX-axis: Relative distance from start/stop codon in nucleotides\nY-axis: Read length (fragment size in nt)\nColor scale: Read count (optionally log-scaled)\n\nThis enables quick inspection of read length distributions and framing periodicity near initiation and termination sites across all samples.\n\n9.1.3 Function usage\n\n9.1.4 To generate heatmap centered on start codon:\n\nrelative_heatmap_plot(obj0)\n\n\n\n\n\n\n9.1.5 Enhancing visualization of low-abundance reads\nThe log_scale argument allows you to apply a log2 transformation to the read counts in the heatmap:\n\nrelative_heatmap_plot(obj0,log_scale = T)\n\n\n\n\n\n\n9.1.6 Interpreting the heatmap\n\nA strong signal centered at positions ~+12 nt indicates high-quality P-site calibration (distance is measured from codon to footprint center/P-site).\nEnrichment for canonical read lengths (e.g., 28–30 nt in eukaryotes) indicates expected ribosomal protection.\nA vertical “stripe” of strong signal for a specific fragment size suggests dominant ribosome-protected fragments.\nIf log_scale = TRUE, low-abundance signals can be visualized more clearly.\n\n\nNote: This heatmap is a powerful diagnostic tool for detecting irregularities in read size distribution, impaired library prep, or incorrect P-site offset settings.\n\n\n9.1.7 To generate heatmap centered on stop codon:\n\nrelative_heatmap_plot(obj0,\n                      type = \"rel2stop\",\n                      log_scale = T)",
    "crumbs": [
      "Quality assessment",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Meta heatmap plot</span>"
    ]
  },
  {
    "objectID": "Feature-plot.html",
    "href": "Feature-plot.html",
    "title": "\n7  Feature distribution\n",
    "section": "",
    "text": "7.1 Read distribution across transcript regions\nRibosome-protected fragments (RPFs) are predominantly derived from coding sequence (CDS) regions, as ribosomes actively translate these parts of the mRNA. Consequently, high-quality Ribo-seq data should show a strong enrichment of reads mapping to CDS regions, with relatively fewer reads aligning to untranslated regions (5′UTR and 3′UTR).\nAnalyzing the proportion of reads mapping to CDS versus 5′UTR and 3′UTR provides an important metric for assessing Ribo-seq data quality.\nA typical high-quality Ribo-seq dataset has &gt;70–80% of reads mapping within annotated CDS regions under standard conditions.",
    "crumbs": [
      "Quality assessment",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Feature distribution</span>"
    ]
  },
  {
    "objectID": "Feature-plot.html#ribo-seq-read-distribution-across-transcript-regions",
    "href": "Feature-plot.html#ribo-seq-read-distribution-across-transcript-regions",
    "title": "\n6  Feature distribution\n",
    "section": "",
    "text": "High CDS enrichment indicates efficient ribosome footprint capture and proper rRNA/tRNA depletion.\nExcessive 5′UTR or 3′UTR mapping may suggest contamination from non-translating RNA fragments or suboptimal library preparation.",
    "crumbs": [
      "Extract reads",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Feature distribution</span>"
    ]
  },
  {
    "objectID": "Feature-plot.html#feature-plot",
    "href": "Feature-plot.html#feature-plot",
    "title": "\n7  Feature distribution\n",
    "section": "\n7.2 Feature plot",
    "text": "7.2 Feature plot\nThe feature_plot() function can be used to analyze and visualize the distribution of aligned reads across different transcript features, including the coding sequence (CDS), 5′ untranslated region (5′UTR), and 3′ untranslated region (3′UTR):\n\nfeature_plot(obj0)\n\n\n\n\n\nThis plot helps assess the quality of Ribo-seq data by showing the relative proportion of reads mapping to each region. High-quality datasets typically show strong enrichment in CDS regions, as ribosome-protected fragments originate mainly from translated coding regions.\nA high percentage of reads in UTRs may indicate contamination or non-specific signals.",
    "crumbs": [
      "Quality assessment",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Feature distribution</span>"
    ]
  },
  {
    "objectID": "Meta-frame-plot.html",
    "href": "Meta-frame-plot.html",
    "title": "\n8  Meta frame plot\n",
    "section": "",
    "text": "8.1 Intro\nThe relative_dist_plot() function visualizes the positional distribution of ribosome-protected fragments (RPFs) relative to either the start codon or stop codon within annotated coding sequences (CDS). This plot reveals the 3-nt periodicity of translating ribosomes and can be used to assess the overall translational signature and framing around translation initiation and termination sites.",
    "crumbs": [
      "Quality assessment",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Meta frame plot</span>"
    ]
  },
  {
    "objectID": "Meta-frame-plot.html#intro",
    "href": "Meta-frame-plot.html#intro",
    "title": "\n8  Meta frame plot\n",
    "section": "",
    "text": "8.1.1 What It Does\nThis function produces barplots showing the distribution of RPFs relative to start or stop codons. Each bar indicates the count of reads at a given position (x = rel), grouped and colored by frame (0, 1, 2). The frame is calculated as (position - mstart_or_mstop) %% 3.",
    "crumbs": [
      "Quality assessment",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Meta frame plot</span>"
    ]
  },
  {
    "objectID": "Meta-frame-plot.html#plot",
    "href": "Meta-frame-plot.html#plot",
    "title": "\n8  Meta frame plot\n",
    "section": "\n8.2 Plot",
    "text": "8.2 Plot\nA periodic signal beginning ~+12 nt from the start codon suggests correct P-site assignment and genuine ribosome footprints:\n\nrelative_dist_plot(obj0)\n\n\n\n\n\nThe read_length parameter allows users to specify the range of fragment sizes (in nucleotides) to include in the plot. This is useful for focusing on canonical ribosome-protected fragment (RPF) sizes—typically ~28–32 nt—while excluding shorter or longer reads that may arise from noise or non-ribosomal sources:\n\nrelative_dist_plot(obj0,read_length = c(25, 30))\n\n\n\n\n\n\n8.2.1 To generate heatmap centered on stop codon:\n\nrelative_dist_plot(obj0,\n                   type = \"rel2stop\",\n                   read_length = c(25, 30))",
    "crumbs": [
      "Quality assessment",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Meta frame plot</span>"
    ]
  },
  {
    "objectID": "Offset-check.html",
    "href": "Offset-check.html",
    "title": "\n10  Offset check\n",
    "section": "",
    "text": "10.1 Inferring offset",
    "crumbs": [
      "Quality assessment",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Offset check</span>"
    ]
  },
  {
    "objectID": "Offset-check.html#inferring-offset",
    "href": "Offset-check.html#inferring-offset",
    "title": "\n10  Offset check\n",
    "section": "",
    "text": "10.1.1 Motivation: Determining the P-site Offset\nIn ribosome profiling (Ribo-seq), precisely estimating the P-site position—the nucleotide on the mRNA where the ribosome’s peptidyl site is located—is critical for accurate analysis of translational dynamics. Because different read (fragment) lengths may result in different P-site offsets, it’s important to determine where each read length tends to accumulate relative to the translation start or stop site.\nRPFs often peak at stereotypical distances (e.g., +12 nt downstream of the start codon), and these characteristic peak positions can be used to assign P-site offsets by read length.\nThe relative_offset_plot() function visualizes this behavior and helps determine P-site positioning across varying read lengths.\n\n10.1.2 What does relative_offset_plot() Show?\nThis function generates a per-read-length line plot showing the distribution of RPF read counts centered around either:\n\nThe start codon (type = “rel2start”), or\nThe stop codon (type = “rel2stop”)\n\nFor each read length:\n\nThe X-axis marks the relative position from the codon (in nucleotides)\nThe Y-axis shows the read count at each position\nA vertical dashed reference line is placed at common offsets (e.g., +12 nt), expected to align with the P-site\nThe position with maximum signal is automatically annotated as a suggested offset\n\nThis plot assists the user in manually or programmatically determining correct P-site offsets per read length.\n\n10.1.3 Why it Matters\nAccurate P-site offset assignment:\n✅ Enables frame-level periodicity analysis\n✅ Improves quantitative interpretation of translation initiation/elongation\n✅ Is essential for detecting codon-level ribosome pausing or accumulation\n\n10.1.4 Function usage\nIn the offset plot generated by relative_offset_plot(), the orange dashed vertical lines highlight positions upstream of the start codon at 12, 15, and 18 nucleotides—commonly observed P-site locations in high-quality Ribo-seq data. These serve as visual guides for interpreting where ribosome footprints (RPFs) tend to accumulate. Ideally, the correct P-site offset for each fragment length can be inferred from the peak position of read counts—i.e., the relative distance where the maximum signal occurs. However, the accuracy of offset identification strongly depends on data quality; in lower-quality or noisy samples, clear signal enrichment may be absent or ambiguous, making offset determination less reliable. In such cases, it is recommended to combine this visualization with other quality control metrics (e.g., frame-periodicity plots) or to use specialized tools such as riboWaltz, RiboCode, or RiboTISH for offset inference. These tools apply statistical or model-based approaches to improve the robustness and reproducibility of P-site calibration. Altogether, careful offset selection is critical for downstream analyses like codon-level profiling, pausing detection, and frame-specific translation quantification：\n{ndefined{r,eval=FALSE} relative_offset_plot(obj0)\n\n\n\n\n\n10.1.5 To check offset peaks near stop codon:\n\nrelative_offset_plot(obj0, type = \"rel2stop\")\n\n\n\n\n\n\n10.1.6 To extract offset positions\nThe plot can be used analytically, not just visually. Use return_offset = TRUE to extract peak positions per fragment size:\n\noffset_table &lt;- relative_offset_plot(obj0, return_offset = TRUE)",
    "crumbs": [
      "Quality assessment",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Offset check</span>"
    ]
  },
  {
    "objectID": "Metagene-plot.html",
    "href": "Metagene-plot.html",
    "title": "\n15  Metagene plot\n",
    "section": "",
    "text": "15.1 Average ribosome occupancy around start or stop codons",
    "crumbs": [
      "Quality assessment",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Metagene plot</span>"
    ]
  },
  {
    "objectID": "Metagene-plot.html#average-ribosome-occupancy-around-start-or-stop-codons",
    "href": "Metagene-plot.html#average-ribosome-occupancy-around-start-or-stop-codons",
    "title": "\n15  Metagene plot\n",
    "section": "",
    "text": "15.1.1 Visualizing global initiation and termination trends\nIn Ribo-seq analysis, the metagene plot is a widely used tool to visualize the average ribosome occupancy near translation start or stop codons across transcripts. By aggregating reads from a large set of coding sequences (CDSs), it reveals global patterns in translation initiation or termination.\nRibosomes are expected to accumulate at the start codon during initiation, and in certain conditions, near the stop codon during termination or ribosome stalling. Examining these patterns provides insight into translational dynamics, data quality, and the fidelity of P-site assignment.\n\n15.1.2 What does metagene_plot() show?\nThe metagene_plot() function generates a smoothed line plot showing average ribosome occupancy (normalized read density) relative to either:\n\nThe start codon (type = “rel2start”), or\nThe stop codon (type = “rel2stop”)\n\nVisualization is performed in either nucleotide (nt) or codon scale, across all coding sequences that pass user-defined filters for length and minimum counts.\nWhat the plot displays:\n\nX-axis: Distance from start/stop codon (in nt or codon units)\nY-axis: Average normalized ribosome occupancy\nFacets: One line per sample or sample group (with replicates optionally merged)\n\nThis metagene-level alignment enables detection of global features such as:\n\nRibosomal accumulation at initiation sites (initiation peaks)\nPeriodicity along coding regions (indicative of translation elongation)\nRibosome drop-off or stalling near stop codons\n\n15.1.3 Normalization approaches\nNormalization helps adjust for transcript length, library size, and gene-level expression. Two approaches are supported:\n\naverage: raw read counts normalized by CDS length and transcript-specific mean coverage\ntpm: TPM-like normalization using reads per kilobase (RPK) divided by sample-level totals\n\nThese methods ensure that highly expressed CDSs do not dominate the signal, allowing for unbiased meta-level averages.\n\n15.1.4 Additional controls & filters\n\ndo_offset_correct: Apply a position shift to correct P-site offset (optional)\nread_length: Select only ribosome footprint fragment sizes of interest\nexclude_length: Exclude regions near CDS boundaries to avoid ambiguous mapping\nmin_cds_length: Filter out short CDSs (e.g. &lt;600 nt)\nmin_counts: Require minimum read support per transcript\nfacet_wrap: Customize the faceting layout (e.g. by sample or condition)\nmerge_rep: Aggregate replicates of the same sample group for cleaner profiles\n\n15.1.5 Example : metagene plot centered at start codon\nA noticeable increase in ribosome occupancy around the start codon is observed upon eIF5A knockout compared to the wild-type (WT), suggesting enhanced ribosome accumulation at translation initiation sites:\n\nmetagene_plot(object = obj0)\n\n\n\n\n\nBy setting mode = “codon”, the unit of relative position is converted from nucleotides (nt) to codons. The rel2st_dist parameter defines the positional window around the start codon. As shown, the overall trend remains consistent with the original nucleotide-based plot:\n\nmetagene_plot(object = obj0,\n              mode = \"codon\",\n              rel2st_dist = c(-50, 900))\n\n\n\n\n\nThe ribosome occupancy profile, aligned relative to the stop codon, displays the averaged translation read density across transcripts within the defined region. Notably, in the eIF5A knockout condition, a marked increase in ribosome occupancy is observed near the stop codon, suggesting enhanced ribosome stalling or delayed termination compared to the wild-type:\n\nmetagene_plot(object = obj0,\n              type = \"rel2stop\",\n              mode = \"codon\",\n              rel2sp_dist = c(-900, 50))\n\n\n\n\n\nThe authors also observed that loss of eIF5A impairs translation termination, as indicated by a clear ribosome stalling peak approximately 30 nucleotides(offset corrected) upstream of the stop codon：",
    "crumbs": [
      "Quality assessment",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Metagene plot</span>"
    ]
  },
  {
    "objectID": "Quality-assessment.html",
    "href": "Quality-assessment.html",
    "title": "Quality assessment",
    "section": "",
    "text": "Extracting Alignment Information with generate_summary\nRibosome profiling (Ribo-seq) typically requires detailed analysis of aligned reads — including which genes they map to, their read lengths, alignment positions, and more. These features are critical for downstream analyses such as P-site detection, triplet periodicity evaluation, and ribosome occupancy profiling.\nThe RiboTrans function generate_summary() extracts comprehensive information about all mapped reads from BAM files, including:\nThe extracted data is stored in the Slot \"summary_info\" of the RiboTrans object and forms the foundation for the majority of downstream analyses.\n⚙️ If the parameter mapping_type = \"genome\" is used, the function will automatically convert genome-based coordinates into transcriptomic coordinates before storing the results.\nBecause the output from generate_summary serves as the primary input for most later steps in the pipeline, running this function is a fundamental and essential part of RiboTrans analysis.",
    "crumbs": [
      "Quality assessment"
    ]
  },
  {
    "objectID": "Quality-assessment.html#extracting-alignment-information-with-generate_summary",
    "href": "Quality-assessment.html#extracting-alignment-information-with-generate_summary",
    "title": "Quality assessment",
    "section": "",
    "text": "The gene or transcript each read aligns to\nRead length\nRead start and end positions (in transcriptomic coordinates)\n…\n\n\n\n\nExample:\nThe following code extracts alignment information from BAM files for each sample:\n\n# generate summary data for QC or other analysis\nobj0 &lt;- generate_summary(object = obj0, exp_type = \"ribo\", nThreads = 20)\n\nhead(obj0@summary_info)\n#               rname  pos qwidth count  sample sample_group mstart mstop translen\n# 1 YAL067C_mRNA|SEO1 1774     27     1 wt-rep1      wt-rep1     51  1829     1882\n# 2 YAL067C_mRNA|SEO1 1771     27     1 wt-rep1      wt-rep1     51  1829     1882\n# 3 YAL067C_mRNA|SEO1 1766     20     1 wt-rep1      wt-rep1     51  1829     1882\n# 4 YAL067C_mRNA|SEO1 1761     27     1 wt-rep1      wt-rep1     51  1829     1882\n# 5 YAL067C_mRNA|SEO1 1662     28     1 wt-rep1      wt-rep1     51  1829     1882\n# 6 YAL067C_mRNA|SEO1 1632     25     1 wt-rep1      wt-rep1     51  1829     1882\n\nColumn Descriptions\n\nrname: A compound field combining the transcript ID and gene name, separated by a vertical bar (|). If the gene name is missing in the GTF annotation, only the transcript ID is shown.\npos: The position (in transcriptomic coordinates) that the read maps to within the transcript.\nqwidth: The width (i.e., length) of the read in nucleotides.\ncount: The number of reads that map to this exact position with the same length.\nsample: The name of the sample from which the read originated.\nsample_group: The user-defined group the sample belongs to. If no grouping was provided during setup, the sample name is used as the group name by default.\nmstart / mstop: The start and end positions of the coding sequence (CDS) region on the transcript.\ntranslen: The total length of the transcript in nucleotides.\n\nThis detailed read-level summary forms the foundation for various downstream analyses — including ribosome occupancy, metagene profiling, and P-site calibration — making it an essential and informative step in the RiboTransVis workflow.\nThe generate_summary function will save the data locally as tinfo.anno.rda by default. For large datasets, rerunning the analysis may be time-consuming. Therefore, you can set load_local = TRUE to directly load the locally saved data:\n\nobj0 &lt;- generate_summary(object = obj0, \n                         exp_type = \"ribo\", \n                         load_local = T)",
    "crumbs": [
      "Quality assessment"
    ]
  },
  {
    "objectID": "Polarity-calculation.html",
    "href": "Polarity-calculation.html",
    "title": "Polarity score",
    "section": "",
    "text": "What does the polarity score tell us?\nRibosome profiling (Ribo-seq) captures the positions of ribosomes on mRNAs at nucleotide resolution. The Polarity Score is a metric used to quantify the positional bias of ribosome-protected fragments (RPFs) along the coding sequence (CDS) of transcripts. Specifically, it determines whether ribosomes tend to accumulate more toward the 5′ end or the 3′ end of coding regions during translation.\nThis metric is commonly used for quality control, sample comparison, and interpretation of mechanistic changes in translation, such as those caused by certain knockdowns or treatments that affect elongation or termination.",
    "crumbs": [
      "Polarity score"
    ]
  },
  {
    "objectID": "Polarity-calculation.html#what-does-the-polarity-score-tell-us",
    "href": "Polarity-calculation.html#what-does-the-polarity-score-tell-us",
    "title": "Polarity score",
    "section": "",
    "text": "A negative polarity score (e.g., -0.2 or lower) indicates that ribosomes are skewed toward the 5′ end of the coding sequence. This may suggest:\n\nNormal co-translational initiation and early elongation.\nPossible slowdown or pausing at the beginning of ORFs.\n\n\nA positive polarity score (e.g., +0.2 or higher) indicates ribosomes accumulate more toward the 3′ end, which may reflect:\n\nDelayed termination or ribosome stalling near stop codons.\nTranslation elongation inefficiency or stress-induced slowdowns.\n\n\nA score near zero suggests relatively uniform ribosome distribution along the CDS, often considered a sign of regular translation dynamics.",
    "crumbs": [
      "Polarity score"
    ]
  },
  {
    "objectID": "Polarity-calculation.html#polarity-calculation",
    "href": "Polarity-calculation.html#polarity-calculation",
    "title": "Polarity score",
    "section": "Polarity calculation",
    "text": "Polarity calculation\nThe polarity score for a given position i can be calculated as:\n\n\\[\np_i = \\frac{d_i w_i}{\\sum_{i=1}^{l} d_i} \\tag{1}\n\\]\nWhere:\n\\[\nw_i = \\frac{2i - (l+1)}{l - 1} \\tag{2}\n\\]\n\n\n\\(d_i\\) is the ribosome read density at position \\(i\\).\n\n\\(l\\) is the total length along the CDS.\n\n\\(w_i\\) defines a scale from -1 at the 5′ end to +1 at the 3′ end.\n\n\nEffectively, \\(w_i\\) linearly increases from -1 to +1 across the CDS. The final polarity score is a weighted average of the read densities, reflecting whether RPFs are concentrated at the start or the end of transcripts.",
    "crumbs": [
      "Polarity score"
    ]
  },
  {
    "objectID": "Polarity-calculation.html#polarity-plot",
    "href": "Polarity-calculation.html#polarity-plot",
    "title": "Polarity score",
    "section": "Polarity plot",
    "text": "Polarity plot\nUsing the polarity_plot function, we assessed the ribosome occupancy bias along coding regions. The resulting plot closely recapitulates the findings from the original study. Notably, in the eEIF5A knockout condition, a leftward shift in polarity was observed, reflecting ribosome accumulation toward the 5′ end of mRNAs. This shift implies attenuated translational elongation efficiency relative to wild-type cells, potentially resulting from impaired ribosome progression or pausing early in the CDS:\n\npolarity_plot(obj0)\n\n\n\n\n\nWhen return_data = TRUE is set in the polarity_plot() function, the function returns the data used for plotting instead of rendering the figure directly. This allows users to create customized visualizations using their preferred plotting libraries such as ggplot2:\n\npt &lt;- polarity_plot(obj0, return_data = T)\n\nhead(pt)\n#            x         y       sample\n# 1 -0.9509882 0.1482262 sgeIF5A-rep1\n# 2 -0.9472065 0.2133719 sgeIF5A-rep1\n# 3 -0.9434249 0.3019287 sgeIF5A-rep1\n# 4 -0.9396433 0.4201396 sgeIF5A-rep1\n# 5 -0.9358616 0.5751527 sgeIF5A-rep1\n# 6 -0.9320800 0.7749276 sgeIF5A-rep1\n# ...",
    "crumbs": [
      "Polarity score"
    ]
  },
  {
    "objectID": "Offset-correction.html",
    "href": "Offset-correction.html",
    "title": "Offset correction",
    "section": "",
    "text": "Intro\nAccurate offset correction is a critical preprocessing step in ribosome profiling data analysis. Because ribosome-protected fragments are heterogeneous in length, the precise location of the ribosomal P-site varies depending on fragment size. Without correcting for this bias, downstream analyses such as metagene profiles, translation initiation site identification, and codon-level ribosome occupancy patterns may be distorted or misinterpreted.\nBy assigning the correct P-site position for each read, offset correction ensures that signals from ribosome footprints are properly aligned with annotated coding features. This improves the resolution of translation dynamics and enables more accurate characterization of start site selection, elongation patterns, and termination efficiency.\nBased on the results of the relative_offset_plot() and length_plot() functions, users can selectively retain reads of appropriate fragment lengths and strong 3-nt periodicity for downstream analysis. For each read length (e.g., 28–32 nt), an optimal P-site offset (relative position from the 5′ end of the read to the start codon) should be determined.\nTo manually specify the offset values for different read lengths, users can create a custom data frame and store it in the reads_offset_info slot of the ribotrans object. This data frame must contain the following three columns:\nOnce the reads_offset_info slot is filled, downstream functions that support offset correction will apply these offsets when the argument do_offset = TRUE is set.",
    "crumbs": [
      "Offset correction"
    ]
  },
  {
    "objectID": "Offset-correction.html#intro",
    "href": "Offset-correction.html#intro",
    "title": "Offset correction",
    "section": "",
    "text": "sample: the sample name (must match names defined in the ribotrans object)\nqwidth: read length (integer)\nrel_pos: P-site offset relative to the start codon (e.g., -12, -13)\n\n\nExample\nBelow is an example of how to create an offset data frame and assign it back to the ribotrans object:\n\n# ==============================================================================\noffset &lt;- rbind(data.frame(list(sample = \"sgeIF5A-rep1\",\n                                qwidth = 25:32,\n                                rel_pos = -13)),\n                data.frame(list(sample = \"sgeIF5A-rep2\",\n                                qwidth = 25:32,\n                                rel_pos = -13)),\n                data.frame(list(sample = \"wt-rep1\",\n                                qwidth = 25:32,\n                                rel_pos = -13)),\n                data.frame(list(sample = \"wt-rep2\",\n                                qwidth = 25:32,\n                                rel_pos = -13))\n)\n\n# assign offset info\nobj0@reads_offset_info &lt;- offset",
    "crumbs": [
      "Offset correction"
    ]
  },
  {
    "objectID": "Codon-occupancy.html",
    "href": "Codon-occupancy.html",
    "title": "Codon occupancy",
    "section": "",
    "text": "Background\nRibosome profiling (Ribo-seq) captures snapshots of ribosome positions on mRNAs at near-codon resolution. One key metric derived from Ribo-seq data is codon occupancy—the measurement of how frequently ribosomes are found at specific codons within coding sequences (CDSs).\nCodon occupancy reflects the ribosome’s dwell time at individual codons and provides insight into the kinetics of translation elongation. Longer dwell times at particular codons may indicate ribosome stalling, slow tRNA decoding, or structural hindrance of the mRNA.",
    "crumbs": [
      "Codon occupancy"
    ]
  },
  {
    "objectID": "Codon-occupancy.html#biological-significance",
    "href": "Codon-occupancy.html#biological-significance",
    "title": "Codon occupancy",
    "section": "Biological significance",
    "text": "Biological significance\nAnalyzing codon occupancy helps elucidate:\n\nTranslation elongation efficiency, potentially influenced by codon optimality and tRNA abundance\nRibosome pausing at specific motifs, such as rare codons or structured regions\nRegulation of gene expression via elongation-level control\nStress responses or genetic perturbations, which may alter elongation dynamics\n\nFor example, comparing codon occupancy between wild-type and mutant conditions (e.g., a tRNA knockout) can reveal changes in translation efficiency at specific codons.",
    "crumbs": [
      "Codon occupancy"
    ]
  },
  {
    "objectID": "Codon-occupancy.html#how-it-works",
    "href": "Codon-occupancy.html#how-it-works",
    "title": "Codon occupancy",
    "section": "How It Works",
    "text": "How It Works\nCodon occupancy is typically calculated using E/P/A-site–assigned Ribo-seq reads. For a given \\(codon_x\\) occupancy is computed as:\n\\[\n\\text{Relative }Codon_x\\text{ Occupancy} = \\frac{\\sum_{i=1}^{n} \\text{Average reads at }codon_x}{n\\text{(The number of codons)}} \\tag{1}\n\\]\nWhere:\n\\[\n\\text{Average reads at }codon_i\\text{ along a trascript} =  \\frac{\\text{Observed reads at codon}_i}{\\text{Average reads per codon}} \\tag{2}\n\\]\nWhere:\n\\[\n\\text{Average reads per codon} = \\frac{\\text{Total reads along CDS}}{\\text{Total length of CDS}} \\tag{3}\n\\]\nThis allows detection of codons that are overrepresented (slowly translated) or underrepresented (quickly passed) relative to expectation.",
    "crumbs": [
      "Codon occupancy"
    ]
  },
  {
    "objectID": "Codon-occupancy.html#applications",
    "href": "Codon-occupancy.html#applications",
    "title": "Codon occupancy",
    "section": "Applications",
    "text": "Applications\n\n\n\n\n\n\nPurpose\nDescription\n\n\n\nIdentify ribosome pause sites\nDetect codons with high occupancy, indicating slow translation or stalling\n\n\nCompare elongation between conditions\nHighlight differences in translational dynamics across stress or knockout models\n\n\nInfer tRNA availability\nCodons with increased pause times may reflect low tRNA abundance or competition\n\n\nStudy translational regulation\nUnderstand how viruses, drugs, or translation factors affect elongation rates",
    "crumbs": [
      "Codon occupancy"
    ]
  },
  {
    "objectID": "Codon-occupancy.html#example",
    "href": "Codon-occupancy.html#example",
    "title": "Codon occupancy",
    "section": "Example",
    "text": "Example\nCodon occupancy analysis was performed by using RiboMiner, and observed a marked increase in occupancy for codons encoding the amino acids P, D, L, I, and M (Proline, Aspartic acid, Leucine, Isoleucine, and Methionine), suggesting potential ribosome pausing or elongation slowdown at these sites:\n\n\n\n\nBefore performing codon occupancy analysis using the codon_occupancy_plot() function from the riboTransVis package, it is necessary to extract the coding sequences (CDS) for each gene. This ensures that the function can accurately map ribosome footprints to codons.\nThe get_transcript_sequence() function can be used to extract CDS sequences from genome and GTF files as shown below:\n\nget_transcript_sequence(genome_file = \"../../index-data/Saccharomyces_cerevisiae.R64-1-1.dna.toplevel.fa\",\n                        gtf_file = \"../../index-data/Saccharomyces_cerevisiae.R64-1-1.112.gtf\",\n                        feature = \"CDS\",\n                        output_file = \"sac_cds.fa\")\n\nOnce the CDS sequences have been obtained, codon occupancy can be calculated and visualized using the codon_occupancy_plot() function from the riboTransVis package:\n\ncodon_occupancy_plot(object = obj0, \n                     cds_fa = \"./sac_cds.fa\",\n                     do_offset_correct = T)\n\n\n\ndo_offset_correct = TRUE enables P-site offset correction to improve positional accuracy.\n\n\n\n\n\nSetting the argument plot_abbreviation = TRUE in the codon_occupancy_plot() function will display amino acid abbreviations (single-letter codes) on the x-axis instead of individual codon sequences. This can help simplify the visualization by grouping codons by the amino acid they encode:\n\ncodon_occupancy_plot(object = obj0, \n                     cds_fa = \"./sac_cds.fa\",\n                     do_offset_correct = T,\n                     plot_abbreviation = T)\n\n\n\n\n\nAlternatively, instead of generating the default plot, you can set return_data = TRUE in the codon_occupancy_plot() function to extract the underlying codon occupancy data for custom plotting. Here, we use the returned data to calculate the log₂ enrichment of codon occupancy between sample groups (e.g., sgeIF5A vs. wt) at the amino acid level:\n\nccdf &lt;- codon_occupancy_plot(object = obj0,\n                             cds_fa = \"./sac_cds.fa\",\n                             do_offset_correct = T,\n                             return_data = T)\n\nhead(ccdf)\n# # A tibble: 6 × 12\n#     sample       sample_group codon_seq   occup  freq reloccup AminoAcid  Abbreviation3 Abbreviation1 codon   abbrev  group  \n#     &lt;chr&gt;        &lt;chr&gt;        &lt;chr&gt;       &lt;dbl&gt; &lt;int&gt;    &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;         &lt;chr&gt;         &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;  \n# 1 sgeIF5A-rep1 sgeIF5A-rep1 AAA       112028. 37155     3.02 Lysine     Lys           K             AAA | K Lys | K sgeIF5A\n# 2 sgeIF5A-rep1 sgeIF5A-rep1 AAC       123727. 31161     3.97 Asparagine Asn           N             AAC | N Asn | N sgeIF5A\n# 3 sgeIF5A-rep1 sgeIF5A-rep1 AAG        87373. 35449     2.46 Lysine     Lys           K             AAG | K Lys | K sgeIF5A\n# 4 sgeIF5A-rep1 sgeIF5A-rep1 AAT       176460. 40086     4.40 Asparagine Asn           N             AAT | N Asn | N sgeIF5A\n# 5 sgeIF5A-rep1 sgeIF5A-rep1 ACA        88907. 21447     4.15 Threonine  Thr           T             ACA | T Thr | T sgeIF5A\n# 6 sgeIF5A-rep1 sgeIF5A-rep1 ACC        57954. 17177     3.37 Threonine  Thr           T             ACC | T Thr | T sgeIF5A\n\nCustom visualization:\n\n# plot\nlibrary(ggplot2)\nccdf$group &lt;- sapply(strsplit(ccdf$sample,split = \"\\\\-\"),\"[\",1)\n\n# log2 ratio\nccdf_aa &lt;- ccdf %&gt;%\n  dplyr::group_by(group,abbrev,AminoAcid) %&gt;%\n  dplyr::summarise(reloccup = mean(reloccup)) %&gt;%\n  tidyr::pivot_wider(names_from = group,values_from = reloccup) %&gt;%\n  dplyr::mutate(ratio = log2(sgeIF5A/wt)) %&gt;%\n  dplyr::arrange(ratio)\n\n# order\nccdf_aa$abbrev &lt;- factor(ccdf_aa$abbrev,levels = ccdf_aa$abbrev)\n\nggplot(ccdf_aa) +\n  geom_col(aes(x = abbrev,y = ratio,fill = AminoAcid),\n           position = position_dodge2(),width = 0.6) +\n  # theme_bw() +\n  theme(axis.text.x = element_text(angle = 90,vjust = 0.5),\n        panel.grid = element_blank(),\n        strip.text = element_text(face = \"bold\"),\n        axis.text = element_text(colour = \"black\")) +\n  xlab(\"Codons (Amino acids)\") +\n  ylab(\"Codon occupancy\")",
    "crumbs": [
      "Codon occupancy"
    ]
  },
  {
    "objectID": "Multipeptide-occupancy.html",
    "href": "Multipeptide-occupancy.html",
    "title": "Multiple peptides occupancy",
    "section": "",
    "text": "Intro",
    "crumbs": [
      "Multiple peptides occupancy"
    ]
  },
  {
    "objectID": "Multipeptide-occupancy.html#biological-significance-of-dipeptide-and-tripeptide-motif-analysis",
    "href": "Multipeptide-occupancy.html#biological-significance-of-dipeptide-and-tripeptide-motif-analysis",
    "title": "Multiple peptides occupancy",
    "section": "Biological Significance of Dipeptide and Tripeptide Motif Analysis",
    "text": "Biological Significance of Dipeptide and Tripeptide Motif Analysis\nAnalyzing ribosome occupancy at the resolution of short peptide motifs reveals:\n\negions of ribosome stalling and queuing, e.g., polyproline (PP, PPP), or DVG, RDK, as highlighted in the 2017 eIF5A study (Schuller et al., Molecular Cell).\nDifferential sensitivity of motifs to elongation factors such as eIF5A.\nTranscripts with low elongation efficiency caused by repetitive or structurally difficult motifs.\nInsights into codon context effects, independent of codon optimality.\n\nThese analyses are foundational for understanding translational control under different cellular conditions or genetic perturbations.",
    "crumbs": [
      "Multiple peptides occupancy"
    ]
  },
  {
    "objectID": "Multipeptide-occupancy.html#get-multiple-peptide-occupancy",
    "href": "Multipeptide-occupancy.html#get-multiple-peptide-occupancy",
    "title": "Multiple peptides occupancy",
    "section": "Get multiple peptide occupancy",
    "text": "Get multiple peptide occupancy\nThe ·multi_peptide_occupancy· function can be used to calculate the relative ribosome occupancy over peptide motifs. The peptide_length parameter specifies the length of the peptide motif to analyze (e.g., 2 for dipeptides, 3 for tripeptides).\nThe function returns a list containing both long-format and wide-format data on multi-peptide occupancy. The long-format data includes average occupancy values for each peptide in each sample, while the wide-format version organizes this information into a matrix, making it easier to visualize and compare across samples.\nWe can extract and examine the wide-format data as follows:\n\npeptide_df &lt;- multi_peptide_occupancy(object = obj0,\n                                      cds_fa = \"./sac_cds.fa\",\n                                      do_offset_correct = T,\n                                      peptide_length = 3)\n\npdf &lt;- peptide_df$wider_format\n\nhead(pdf)\n# # A tibble: 6 × 5\n#   pep_seq `sgeIF5A-rep1` `sgeIF5A-rep2` `wt-rep1` `wt-rep2`\n#   &lt;chr&gt;            &lt;dbl&gt;          &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;\n# 1 AAA               7.05           8.19      8.86      10.2\n# 2 AAD              10.5           12.2      11.8       13.7\n# 3 AAE               9.81          10.8      11.4       12.6\n# 4 AAF               9.21           9.90      9.33      12.7\n# 5 AAG               9.75           9.73      9.67      11.3\n# 6 AAI               8.70           9.24     10.1       12.0\n\nWe provide a simple function, peptide_scatter_plot, for visualizing peptide motif occupancy between different samples using scatter plots. As shown below, our analysis results are consistent with previous literature: in eIF5A knockout samples, tripeptide motifs enriched in proline residues—such as PPP—exhibit increased ribosome occupancy:\n\n# Generate scatter plots comparing wild-type and eIF5A-depleted replicates\nr1 &lt;- peptide_scatter_plot(data = pdf, x = \"wt-rep1\", y = \"sgeIF5A-rep1\")\nr2 &lt;- peptide_scatter_plot(data = pdf, x = \"wt-rep2\", y = \"sgeIF5A-rep2\")\n\n# Combine the two plots using the patchwork package\nlibrary(patchwork)\nr1 + r2",
    "crumbs": [
      "Multiple peptides occupancy"
    ]
  },
  {
    "objectID": "Motif-centered.html",
    "href": "Motif-centered.html",
    "title": "Motif centered analysis",
    "section": "",
    "text": "Intro\nIn our previous analysis, we identified significant ribosome pausing at motifs enriched in proline residues following eIF5A depletion. These stalling events were especially prominent at polyproline stretches, consistent with the known role of eIF5A in facilitating translation elongation at such sites.\nTo further support and visualize these findings, we can perform a motif-centered ribosome occupancy analysis. This approach involves aligning ribosome footprint data around specific amino acid motifs and measuring the average occupancy within a defined window upstream and downstream of each motif. By focusing on ribosomes positioned near motifs of interest—such as known stalling sequences identified in eIF5Ad cells—we can generate metagene-like plots that highlight the local translation dynamics.\nFor example, by centering ribosome profiles around high-scoring pause motifs (e.g., PPP, PPG, PXD), we can observe localized peaks in ribosome density. Notably, in the absence of eIF5A, we often detect an additional accumulation of ribosomes ~30 nucleotides upstream of pause sites, indicative of ribosome queuing behind stalled complexes. These occupancy patterns provide detailed insights into how specific sequence contexts contribute to translational bottlenecks in eIF5A-deficient cells.\nThis motif-centered analysis complements global pause score comparisons by offering a high-resolution view of ribosome behavior near individual stalling elements, helping to clarify the mechanistic impact of eIF5A depletion on translation elongation efficiency.",
    "crumbs": [
      "Motif centered analysis"
    ]
  },
  {
    "objectID": "Motif-centered.html#motif-centered-analysis",
    "href": "Motif-centered.html#motif-centered-analysis",
    "title": "Motif centered analysis",
    "section": "Motif centered analysis",
    "text": "Motif centered analysis\nTo quantitatively assess ribosome pausing around specific sequence motifs, we apply the relative_motif_occupancy function. This function computes the average ribosome occupancy at defined distances upstream and downstream of user-specified amino acid motifs across coding sequences.\nFor example, in the following code, we analyze ribosome occupancy profiles centered around proline-rich motifs such as “PP” and “PPP”. These motifs are known to induce translation pausing, particularly under eIF5A-depleted conditions:\n\n# ribosome occupancy distance to specific motif\nrelmotif &lt;- relative_motif_occupancy(object = obj0, \n                                     cds_fa = \"sac_cds.fa\",\n                                     do_offset_correct = T,\n                                     motif_pattern = c(\"PP\",\"PPP\"))\n\n# check\nhead(relmotif)\n# # A tibble: 6 × 5\n#   sample       motif  dist  value avg_val\n#   &lt;chr&gt;        &lt;chr&gt; &lt;dbl&gt;  &lt;dbl&gt;   &lt;dbl&gt;\n# 1 sgeIF5A-rep1 PP      -50  5873.   0.844\n# 2 sgeIF5A-rep1 PP      -49  5134.   0.738\n# 3 sgeIF5A-rep1 PP      -48 10371.   1.49 \n# 4 sgeIF5A-rep1 PP      -47  5329.   0.766\n# 5 sgeIF5A-rep1 PP      -46  5607.   0.806\n# 6 sgeIF5A-rep1 PP      -45 12169.   1.75 \n\nThe relative_motif_plot function is used to visualize the data generated by the relative_motif_occupancy analysis:\n\nrelative_motif_plot(relmotif)\n\n\n\n\n\nThe motif_pattern parameter allows the inclusion of multiple distinct motifs for an integrated ribosome occupancy analysis. This is particularly useful for evaluating the translational effect of various sequence contexts beyond polyproline motifs.\nFor instance, in the study, several high-pause tripeptide motifs identified under eIF5A depletion conditions do not contain consecutive prolines (i.e., non-Pro-Pro motifs). These motifs can be collectively analyzed using the relative_motif_occupancy function as shown below:\n\n# Calculate ribosome occupancy relative to a set of non-Pro-Pro pausing motifs\nrelmotif2 &lt;- relative_motif_occupancy(object = obj0, \n                                      cds_fa = \"sac_cds.fa\",\n                                      do_offset_correct = TRUE,\n                                      motif_pattern = c(\"DDP\", \"FDR\", \"PDP\", \"DPG\", \"DNP\",\n                                                        \"RDK\", \"DGP\", \"PDA\", \"PDK\", \"PDV\",\n                                                        \"PDG\", \"DVG\", \"GDP\", \"DDG\", \"PDI\",\n                                                        \"GGT\", \"PGP\", \"DSP\"))\n\n# Plot average ribosome occupancy relative to motif position\nrelative_motif_plot(relmotif2)\n\n\n\n\n\nTo provide a more consolidated view of ribosome occupancy around a collection of stalling motifs, we aggregate the data across multiple motifs and summarize it collectively, enabling clearer visualization of ribosome pausing trends:\n\n# group by motifs\nrelmotif2.cm &lt;- relmotif2 %&gt;% \n  dplyr::mutate(motif = \"Non-Pro-Pro\") %&gt;% \n  dplyr::group_by(sample,motif,dist) %&gt;% \n  dplyr::summarise(mn = mean(avg_val))\n  \n# plot\nggplot(relmotif2.cm) +\n  geom_path(aes(x = dist,y = mn)) +\n  facet_grid(motif~sample,scales = \"free_y\") +\n  theme(panel.grid = element_blank(),\n        strip.text = element_text(face = \"bold\"),\n        axis.text = element_text(colour = \"black\")) +\n  xlab(\"Distance of P site to motif\") +\n  ylab(\"Average ribosome occupancy\")",
    "crumbs": [
      "Motif centered analysis"
    ]
  },
  {
    "objectID": "Multipeptide-occupancy.html#intro",
    "href": "Multipeptide-occupancy.html#intro",
    "title": "Multiple peptides occupancy",
    "section": "",
    "text": "Role of dipeptide and tripeptide motifs analysis\nRibosome profiling (Ribo-seq) is a powerful technique that captures snapshots of ribosome positions on actively translated mRNAs, providing codon-resolution views of translation dynamics. Among the most informative features derived from such analysis are short amino acid motifs—particularly dipeptides and tripeptides—which are useful in identifying translational pauses and elongation efficiency.\nBiological significance\nAnalyzing ribosome occupancy at the resolution of short peptide motifs reveals:\n\negions of ribosome stalling and queuing, e.g., polyproline (PP, PPP), or DVG, RDK, as highlighted in the 2017 eIF5A study (Schuller et al., Molecular Cell).\nDifferential sensitivity of motifs to elongation factors such as eIF5A.\nTranscripts with low elongation efficiency caused by repetitive or structurally difficult motifs.\nInsights into codon context effects, independent of codon optimality.\n\nThese analyses are foundational for understanding translational control under different cellular conditions or genetic perturbations.",
    "crumbs": [
      "Multiple peptides occupancy"
    ]
  },
  {
    "objectID": "Motif-centered.html#centered-codon-analysis",
    "href": "Motif-centered.html#centered-codon-analysis",
    "title": "Motif centered analysis",
    "section": "Centered codon analysis",
    "text": "Centered codon analysis\nBeyond amino acid motif analysis, ribosome occupancy can also be studied at the codon level. This approach helps reveal whether specific codons, such as those encoding Proline, are associated with ribosome pausing.\nFor example, here we analyze ribosome occupancy around the four Pro codons (CCT, CCC, CCA, CCG):\n\n# Perform codon-centered ribosome occupancy analysis on proline codons\nrelmotif3 &lt;- relative_motif_occupancy(object = obj0, \n                                      cds_fa = \"sac_cds.fa\",\n                                      do_offset_correct = TRUE,\n                                      search_type = \"codon\",\n                                      motif_pattern = c(\"CCT\", \"CCC\", \"CCA\", \"CCG\"))\n\n# Plot ribosome occupancy surrounding individual Pro codons\nrelative_motif_plot(relmotif3)",
    "crumbs": [
      "Motif centered analysis"
    ]
  },
  {
    "objectID": "Track-plot.html",
    "href": "Track-plot.html",
    "title": "Track plot",
    "section": "",
    "text": "Intro\nIn ribo-seq analysis, it is often necessary to visualize the ribosomal occupancy over specific genes to understand their translational dynamics. The package riboTransVis facilitates this by allowing rapid, gene-specific extraction of reads directly from BAM files. Instead of loading and filtering the entire BAM file, riboTransVis searches for target gene-associated reads and performs post-processing just on those, resulting in significantly faster plotting and reduced memory usage.\nWhen working with BAM files aligned to the genome, the get_occupancy function includes a coordinate_to_trans = TRUE option. This converts genomic coordinates into transcriptomic coordinates, enabling users to easily inspect read distributions along full-length transcripts. For BAM files aligned against transcriptome sequences, this conversion is unnecessary.\nFurthermore, the function provides a useful do_reads_offset parameter that adjusts P-site offsets to more accurately reflect ribosomal E/P/A site occupancy distributions.",
    "crumbs": [
      "Track plot"
    ]
  },
  {
    "objectID": "Track-plot.html#visualizing-transcriptomic-read-density-tracks",
    "href": "Track-plot.html#visualizing-transcriptomic-read-density-tracks",
    "title": "Track plot",
    "section": "Visualizing Transcriptomic Read Density Tracks",
    "text": "Visualizing Transcriptomic Read Density Tracks\nWhen the get_occupancy function is called with the gene_name argument, the ribotrans object stores the gene-specific ribosome occupancy data in its ribo_occupancy slot. Below is an example using the gene THO1, as reported in the literature:\n\nobj0 &lt;- get_occupancy(object = obj0, \n                      gene_name = \"THO1\", \n                      coordinate_to_trans = T,\n                      do_reads_offset = T)\n\nhead(obj0@ribo_occupancy)\n# # A tibble: 6 × 6\n#   sample  rname               pos count    rpm smooth\n#   &lt;chr&gt;   &lt;chr&gt;             &lt;dbl&gt; &lt;int&gt;  &lt;dbl&gt;  &lt;dbl&gt;\n# 1 wt-rep1 YER063W_mRNA|THO1    20     2 0.0452 0.0452\n# 2 wt-rep1 YER063W_mRNA|THO1    22     3 0.0679 0.0679\n# 3 wt-rep1 YER063W_mRNA|THO1    27     1 0.0226 0.0226\n# 4 wt-rep1 YER063W_mRNA|THO1    28     1 0.0226 0.0226\n# 5 wt-rep1 YER063W_mRNA|THO1    29     1 0.0226 0.0226\n# 6 wt-rep1 YER063W_mRNA|THO1    41     1 0.0226 0.0226\n\nSee ribotrans object structure:\n\n\n\n\nAfter extracting the ribosome occupancy data, use the trans_plot function for visualization:\n\ntrans_plot(object = obj0, type = \"ribo\")\n\n\n\n\n\nSet the layer parameter to choose different plotting styles: “line” corresponds to the geom_path layer, while “col” corresponds to the geom_col layer.\n\ntrans_plot(object = obj0, type = \"ribo\",layer = \"col\")\n\n\n\n\n\nSetting new_signal_range allows the display of a conventional y-axis scale:\n\ntrans_plot(object = obj0, type = \"ribo\",\n           new_signal_range = F)",
    "crumbs": [
      "Track plot"
    ]
  },
  {
    "objectID": "Track-plot.html#visualizing-genomic-read-density-tracks",
    "href": "Track-plot.html#visualizing-genomic-read-density-tracks",
    "title": "Track plot",
    "section": "Visualizing Genomic Read Density Tracks",
    "text": "Visualizing Genomic Read Density Tracks\nIn addition to visualizing ribosome occupancy across genes in transcriptomic coordinates, users may sometimes need to view occupancy data in the context of genomic coordinates. This can be particularly useful for aligning ribosome profiling data with genomic features such as introns, intergenic regions, or regulatory elements. The riboTransVis package supports visualization directly in the genomic coordinate system, providing greater flexibility for diverse analysis needs.\nWhen your upstream aligned BAM files are mapped to the genome reference rather than the transcriptome, you can retain the original genomic coordinates during the occupancy extraction step. To do this, simply set the parameter coordinate_to_trans = FALSE in the get_occupancy function. This disables the transcript coordinate transformation process, allowing visualizations to reflect the original genome-based alignment information:\n\nobj0 &lt;- get_occupancy(object = obj0, \n                      gene_name = \"THO1\", \n                      coordinate_to_trans = F,\n                      do_reads_offset = T)\n\nhead(obj0@ribo_occupancy)\n# # A tibble: 6 × 6\n#   sample  rname    pos count    rpm smooth\n#   &lt;chr&gt;   &lt;fct&gt;  &lt;dbl&gt; &lt;int&gt;  &lt;dbl&gt;  &lt;dbl&gt;\n# 1 wt-rep1 V     281679     2 0.0452 0.0452\n# 2 wt-rep1 V     281681     3 0.0679 0.0679\n# 3 wt-rep1 V     281686     1 0.0226 0.0226\n# 4 wt-rep1 V     281687     1 0.0226 0.0226\n# 5 wt-rep1 V     281688     1 0.0226 0.0226\n# 6 wt-rep1 V     281700     1 0.0226 0.0226\n\nAt this point, to visualize ribosome occupancy data mapped in genomic coordinates, we need to use the genome_trans_plot function instead of trans_plot. Unlike trans_plot, which is designed for transcriptomic coordinate systems, genome_trans_plot allows users to generate read density tracks directly based on the original genomic positions:\n\ngenome_trans_plot(object = obj0, type = \"ribo\")",
    "crumbs": [
      "Track plot"
    ]
  },
  {
    "objectID": "Track-plot.html#examples-in-literature",
    "href": "Track-plot.html#examples-in-literature",
    "title": "Track plot",
    "section": "Examples in literature",
    "text": "Examples in literature\nWe now demonstrate how to generate track plots for three genes commonly referenced in the literature: CHC1, THO1, and PCL6:\n\nplist &lt;- lapply(c(\"CHC1\", \"THO1\", \"PCL6\"),function(x){\n  obj0 &lt;- get_occupancy(object = obj0, \n                        gene_name = x, \n                        coordinate_to_trans = T,\n                        do_reads_offset = T)\n  \n  p &lt;- trans_plot(object = obj0, type = \"ribo\")\n  \n  return(p)\n})\n\n# combine\ncowplot::plot_grid(plotlist = plist,nrow = 1)\n\n\n\n\n\n\nMore example see DENR promotes translation reinitiation chapter.",
    "crumbs": [
      "Track plot"
    ]
  },
  {
    "objectID": "Whole-metagene-plot.html",
    "href": "Whole-metagene-plot.html",
    "title": "\n10  Whole metegene plot\n",
    "section": "",
    "text": "10.1 Intro\nThe whole_metagene_plot() function in the riboTransVis package provides an aggregated view of ribosome footprint distribution across all expressed transcripts. It aligns coding regions (CDS), 5′ untranslated regions (5′ UTR), and 3′ untranslated regions (3′ UTR) into a normalized meta-transcript for comparative analysis of ribosome occupancy patterns across conditions or samples.",
    "crumbs": [
      "Quality assessment",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Whole metegene plot</span>"
    ]
  },
  {
    "objectID": "Whole-metagene-plot.html#how-it-works",
    "href": "Whole-metagene-plot.html#how-it-works",
    "title": "\n10  Whole metegene plot\n",
    "section": "\n10.2 How it works",
    "text": "10.2 How it works\n\n\nRelative Positioning:\nThe function computes the relative position of ribosome footprints in transcripts, normalized into three regions:\n\n5′ UTR: [0, 1)\nCDS: [1, 2)\n3′ UTR: [2, 3)\n\n\nRescaling Axis:\nThe x-axis is rescaled to assign relative sizes to the 5′ and 3′ UTRs based on either auto-scaling from gene features or manually defined scaling.\nDensity Plotting:\nA smoothed density plot of ribosome positions is computed across all transcripts and displayed per replicate or per condition.\n\n\ngeom_density_bw (numeric, default = 0.0005): Bandwidth used in estimating the density curve. Smaller values increase resolution but may add noise.",
    "crumbs": [
      "Quality assessment",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Whole metegene plot</span>"
    ]
  },
  {
    "objectID": "Whole-metagene-plot.html#example",
    "href": "Whole-metagene-plot.html#example",
    "title": "\n10  Whole metegene plot\n",
    "section": "\n10.3 Example",
    "text": "10.3 Example\nWe now use the whole_metagene_plot function to visualize the distribution of ribosome fragment density across different regions of the transcriptome. This metagene plot aligns all expressed transcripts by their annotated 5′ UTR, coding sequence (CDS), and 3′ UTR regions, enabling a global view of ribosome occupancy patterns:\n\nwhole_metagene_plot(object = obj0)",
    "crumbs": [
      "Quality assessment",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Whole metegene plot</span>"
    ]
  },
  {
    "objectID": "More-examples.html",
    "href": "More-examples.html",
    "title": "More examples",
    "section": "",
    "text": "Introduction\nThis vignette demonstrates how to use riboTransVis to reproduce key findings from several high-impact Ribo-seq publications. Ribosome profiling (Ribo-seq) has revolutionized our understanding of translation by providing genome-wide snapshots of ribosome positions with codon-level resolution. Here, we showcase the versatility of riboTransVis by recreating analyses from landmark studies in the field.",
    "crumbs": [
      "More examples"
    ]
  },
  {
    "objectID": "Ubiquitin-conjugase-Rad6.html",
    "href": "Ubiquitin-conjugase-Rad6.html",
    "title": "\n13  Ubiquitin conjugase Rad6\n",
    "section": "",
    "text": "13.1 Intro\nIn this section, we demonstrate how to use riboTransVis to reproduce the key findings from the Cell Reports article titled “The ubiquitin conjugase Rad6 mediates ribosome pausing during oxidative stress” by Meydan et al. (2023).\nThis study uncovers a novel mechanism of translation regulation in Saccharomyces cerevisiae mediated by the ubiquitin-conjugating enzyme Rad6 under conditions of oxidative stress. Using Ribo-seq and Disome-seq approaches, the researchers show that Rad6 is essential for promoting ribosome pausing—particularly at isoleucine-proline (XIP) motifs—upon treatment with hydrogen peroxide (H₂O₂). These pause sites are thought to trigger ribosome collisions and contribute to translation repression.\nImportantly, Rad6 modifies ribosomes via K63-linked polyubiquitin chains, a process independent of the ribosome-associated quality control (RQC) pathway. In rad6Δ cells, redox-induced pausing signatures are lost, global translation is less inhibited, and there is abnormal activation of antioxidant response genes. The study also reveals that Rad6 contributes to activation of the integrated stress response (ISR) via eIF2α phosphorylation and modulates the translation of the transcription factor GCN4.\nThese findings highlight an alternative translation control pathway—termed redox control of translation by ubiquitin (RTU)—where Rad6-mediated ubiquitination regulates translation elongation during oxidative stress, thereby shaping the cellular stress response.",
    "crumbs": [
      "More examples",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Ubiquitin conjugase Rad6</span>"
    ]
  },
  {
    "objectID": "Ubiquitin-conjugase-Rad6.html#data-download",
    "href": "Ubiquitin-conjugase-Rad6.html#data-download",
    "title": "\n13  Ubiquitin conjugase Rad6\n",
    "section": "\n13.2 Data Download",
    "text": "13.2 Data Download\nThe GEO accession number for the dataset associated with the study is GSE226082. To access the sequencing data, you can search for this number in the GEO (Gene Expression Omnibus) database. Additionally, the corresponding SRA (Sequence Read Archive) project number is PRJNA938481. Using this SRA ID, you can retrieve the FASTQ raw sequencing data from the SRA Explorer platform.\nTo speed up the download, we recommend using the Aspera high-speed file transfer protocol. On the SRA Explorer website, you can locate the Aspera download links for the FASTQ data files corresponding to each sample in the study:\n\n\n\n\n\n#!/usr/bin/env bash\nascp -QT -l 300m -P33001 -i $HOME/.aspera/connect/etc/asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:vol1/fastq/SRR236/023/SRR23617123/SRR23617123.fastq.gz . && mv SRR23617123.fastq.gz SUB280_WT_rep1_F.fastq.gz\nascp -QT -l 300m -P33001 -i $HOME/.aspera/connect/etc/asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:vol1/fastq/SRR236/021/SRR23617121/SRR23617121.fastq.gz . && mv SRR23617121.fastq.gz SUB280_WT_peroxide_rep1_F.fastq.gz\nascp -QT -l 300m -P33001 -i $HOME/.aspera/connect/etc/asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:vol1/fastq/SRR236/020/SRR23617120/SRR23617120.fastq.gz . && mv SRR23617120.fastq.gz SUB280_WT_peroxide_rep2_F.fastq.gz\nascp -QT -l 300m -P33001 -i $HOME/.aspera/connect/etc/asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:vol1/fastq/SRR236/022/SRR23617122/SRR23617122.fastq.gz . && mv SRR23617122.fastq.gz SUB280_WT_rep2_F.fastq.gz\nascp -QT -l 300m -P33001 -i $HOME/.aspera/connect/etc/asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:vol1/fastq/SRR236/018/SRR23617118/SRR23617118.fastq.gz . && mv SRR23617118.fastq.gz SUB280_rad6_rep2_F.fastq.gz\nascp -QT -l 300m -P33001 -i $HOME/.aspera/connect/etc/asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:vol1/fastq/SRR236/019/SRR23617119/SRR23617119.fastq.gz . && mv SRR23617119.fastq.gz SUB280_rad6_rep1_F.fastq.gz\nascp -QT -l 300m -P33001 -i $HOME/.aspera/connect/etc/asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:vol1/fastq/SRR236/017/SRR23617117/SRR23617117.fastq.gz . && mv SRR23617117.fastq.gz SUB280_rad6_peroxide_rep1_F.fastq.gz\nascp -QT -l 300m -P33001 -i $HOME/.aspera/connect/etc/asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:vol1/fastq/SRR236/014/SRR23617114/SRR23617114.fastq.gz . && mv SRR23617114.fastq.gz SUB280_hel2_peroxide_F.fastq.gz\nascp -QT -l 300m -P33001 -i $HOME/.aspera/connect/etc/asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:vol1/fastq/SRR236/016/SRR23617116/SRR23617116.fastq.gz . && mv SRR23617116.fastq.gz SUB280_rad6_peroxide_rep2_F.fastq.gz\nascp -QT -l 300m -P33001 -i $HOME/.aspera/connect/etc/asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:vol1/fastq/SRR236/015/SRR23617115/SRR23617115.fastq.gz . && mv SRR23617115.fastq.gz SUB280_hel2_F.fastq.gz\nascp -QT -l 300m -P33001 -i $HOME/.aspera/connect/etc/asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:vol1/fastq/SRR236/011/SRR23617111/SRR23617111.fastq.gz . && mv SRR23617111.fastq.gz SUB280_rad6_RAD6_C88A_F.fastq.gz\nascp -QT -l 300m -P33001 -i $HOME/.aspera/connect/etc/asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:vol1/fastq/SRR236/013/SRR23617113/SRR23617113.fastq.gz . && mv SRR23617113.fastq.gz SUB280_rad6_RAD6_F.fastq.gz\nascp -QT -l 300m -P33001 -i $HOME/.aspera/connect/etc/asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:vol1/fastq/SRR236/012/SRR23617112/SRR23617112.fastq.gz . && mv SRR23617112.fastq.gz SUB280_rad6_RAD6_peroxide_F.fastq.gz\nascp -QT -l 300m -P33001 -i $HOME/.aspera/connect/etc/asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:vol1/fastq/SRR236/008/SRR23617108/SRR23617108.fastq.gz . && mv SRR23617108.fastq.gz S288C_WT_peroxide_F.fastq.gz\nascp -QT -l 300m -P33001 -i $HOME/.aspera/connect/etc/asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:vol1/fastq/SRR236/010/SRR23617110/SRR23617110.fastq.gz . && mv SRR23617110.fastq.gz SUB280_rad6_RAD6_C88A_peroxide_F.fastq.gz\nascp -QT -l 300m -P33001 -i $HOME/.aspera/connect/etc/asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:vol1/fastq/SRR236/009/SRR23617109/SRR23617109.fastq.gz . && mv SRR23617109.fastq.gz S288C_WT_F.fastq.gz\nascp -QT -l 300m -P33001 -i $HOME/.aspera/connect/etc/asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:vol1/fastq/SRR236/007/SRR23617107/SRR23617107.fastq.gz . && mv SRR23617107.fastq.gz S288C_rad6_F.fastq.gz\nascp -QT -l 300m -P33001 -i $HOME/.aspera/connect/etc/asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:vol1/fastq/SRR236/005/SRR23617105/SRR23617105.fastq.gz . && mv SRR23617105.fastq.gz SUB280_WT_rep1_Fd.fastq.gz\nascp -QT -l 300m -P33001 -i $HOME/.aspera/connect/etc/asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:vol1/fastq/SRR236/003/SRR23617103/SRR23617103.fastq.gz . && mv SRR23617103.fastq.gz SUB280_WT_peroxide_rep1_Fd.fastq.gz\nascp -QT -l 300m -P33001 -i $HOME/.aspera/connect/etc/asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:vol1/fastq/SRR236/006/SRR23617106/SRR23617106.fastq.gz . && mv SRR23617106.fastq.gz S288C_rad6_peroxide_F.fastq.gz\nascp -QT -l 300m -P33001 -i $HOME/.aspera/connect/etc/asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:vol1/fastq/SRR236/002/SRR23617102/SRR23617102.fastq.gz . && mv SRR23617102.fastq.gz SUB280_WT_peroxide_rep2_Fd.fastq.gz\nascp -QT -l 300m -P33001 -i $HOME/.aspera/connect/etc/asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:vol1/fastq/SRR236/004/SRR23617104/SRR23617104.fastq.gz . && mv SRR23617104.fastq.gz SUB280_WT_rep2_Fd.fastq.gz\nascp -QT -l 300m -P33001 -i $HOME/.aspera/connect/etc/asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:vol1/fastq/SRR236/001/SRR23617101/SRR23617101.fastq.gz . && mv SRR23617101.fastq.gz SUB280_rad6_Fd.fastq.gz\nascp -QT -l 300m -P33001 -i $HOME/.aspera/connect/etc/asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:vol1/fastq/SRR236/000/SRR23617100/SRR23617100.fastq.gz . && mv SRR23617100.fastq.gz SUB280_rad6_peroxide_Fd.fastq.gz",
    "crumbs": [
      "More examples",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Ubiquitin conjugase Rad6</span>"
    ]
  },
  {
    "objectID": "Ubiquitin-conjugase-Rad6.html#adapter-trimming",
    "href": "Ubiquitin-conjugase-Rad6.html#adapter-trimming",
    "title": "\n13  Ubiquitin conjugase Rad6\n",
    "section": "\n13.3 Adapter Trimming",
    "text": "13.3 Adapter Trimming\nAfter running FastQC on the raw FASTQ files, we observed the presence of adapter contamination in the sequencing reads. According to the Methods section of the original publication, adapter trimming was performed using Cutadapt.\nWe applied Cutadapt to remove unwanted bases from both ends of the reads. In particular, we trimmed 2 nucleotides from the 5′ end (using -u 2) and 5 nucleotides from the 3′ end (using -u -5).\nHere is the bash script we used to batch-process multiple FASTQ files:\n\n# Adapter trimming with Cutadapt for all samples\nfor i in SUB280_WT_rep1_F SUB280_WT_rep2_F SUB280_WT_peroxide_rep1_F SUB280_WT_peroxide_rep2_F SUB280_rad6_rep1_F SUB280_rad6_rep2_F SUB280_rad6_peroxide_rep1_F SUB280_rad6_peroxide_rep2_F SUB280_hel2_F SUB280_hel2_peroxide_F SUB280_rad6_RAD6_F SUB280_rad6_RAD6_peroxide_F SUB280_rad6_RAD6_C88A_F SUB280_rad6_RAD6_C88A_peroxide_F S288C_WT_F S288C_WT_peroxide_F S288C_rad6_F S288C_rad6_peroxide_F SUB280_WT_rep1_Fd SUB280_WT_rep2_Fd SUB280_WT_peroxide_rep1_Fd SUB280_WT_peroxide_rep2_Fd SUB280_rad6_Fd SUB280_rad6_peroxide_Fd\ndo\n        cutadapt -j 20 -u 2 -u -5 -o ./${i}_trim.fq.gz ../1.raw-data/${i}.fastq.gz\ndone",
    "crumbs": [
      "More examples",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Ubiquitin conjugase Rad6</span>"
    ]
  },
  {
    "objectID": "Ubiquitin-conjugase-Rad6.html#removal-of-rrna-contamination",
    "href": "Ubiquitin-conjugase-Rad6.html#removal-of-rrna-contamination",
    "title": "\n13  Ubiquitin conjugase Rad6\n",
    "section": "\n13.4 Removal of rRNA Contamination",
    "text": "13.4 Removal of rRNA Contamination\nAfter adapter trimming, the cleaned sequencing reads still contain a proportion of ribosomal RNA (rRNA) contaminants, which can interfere with downstream translational profiling. To eliminate these reads, we aligned the trimmed reads against a reference index of Saccharomyces cerevisiae rRNA sequences using Bowtie2.\nFollowing the original study’s pipeline, reads that did not map to rRNA were retained for downstream analyses. The alignment was performed with the following shell script:\n\n# Remove reads that map to rRNA\nfor i in SUB280_WT_rep1_F SUB280_WT_rep2_F SUB280_WT_peroxide_rep1_F SUB280_WT_peroxide_rep2_F SUB280_rad6_rep1_F SUB280_rad6_rep2_F SUB280_rad6_peroxide_rep1_F SUB280_rad6_peroxide_rep2_F SUB280_hel2_F SUB280_hel2_peroxide_F SUB280_rad6_RAD6_F SUB280_rad6_RAD6_peroxide_F SUB280_rad6_RAD6_C88A_F SUB280_rad6_RAD6_C88A_peroxide_F S288C_WT_F S288C_WT_peroxide_F S288C_rad6_F S288C_rad6_peroxide_F SUB280_WT_rep1_Fd SUB280_WT_rep2_Fd SUB280_WT_peroxide_rep1_Fd SUB280_WT_peroxide_rep2_Fd SUB280_rad6_Fd SUB280_rad6_peroxide_Fd\ndo\n        bowtie2 -p 20 -x ../../index-data/sac-rRNA-index/Saccharomyces-cerevisiae-rRNA \\\n                --un-gz ${i}.rmrRNA.fq.gz \\\n                -U ../2.trim-data/${i}_trim.fq.gz \\\n                -S ./null\ndone",
    "crumbs": [
      "More examples",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Ubiquitin conjugase Rad6</span>"
    ]
  },
  {
    "objectID": "Ubiquitin-conjugase-Rad6.html#genome-alignment",
    "href": "Ubiquitin-conjugase-Rad6.html#genome-alignment",
    "title": "\n13  Ubiquitin conjugase Rad6\n",
    "section": "\n13.5 Genome Alignment",
    "text": "13.5 Genome Alignment\nAfter removing rRNA contaminants, the remaining clean reads were aligned to the reference genome of Saccharomyces cerevisiae using the STAR aligner, which is well-suited for spliced alignment of both RNA-seq and ribosome profiling reads. Prior to read alignment, a STAR genome index must be generated.\n\n13.5.1 Step 1: Build STAR Genome Index\nBefore mapping reads to the genome, we need to generate an indexed genome with a corresponding annotation file (GTF). Below is the command used to build the STAR index:\n\nSTAR --runThreadN 15 \\\n     --runMode genomeGenerate \\\n     --genomeDir sac-star-genome-index/ \\\n     --genomeFastaFiles ./Saccharomyces_cerevisiae.R64-1-1.dna.toplevel.fa \\\n     --sjdbGTFfile Saccharomyces_cerevisiae.R64-1-1.112.gtf\n\n\n13.5.1.1 Explanation of parameters:\n\n--runThreadN 15: Use 15 CPU threads to speed up indexing.\n--runMode genomeGenerate: Instructs STAR to generate the genome index.\n--genomeDir: Output directory for the STAR index files.\n--genomeFastaFiles: Path to the FASTA file of the yeast genome (S. cerevisiae R64-1-1 build).\n--sjdbGTFfile: Path to the GTF annotation file for splice junctions.\n\nOnce built, this index can be reused for alignment across all samples.\n\n13.5.2 Step 2: Align reads to the genome\nWith the index in place, we mapped the rRNA-depleted FASTQ files to the genome using the following shell script:\n\n# Align reads to the yeast genome using STAR\nfor i in SUB280_WT_rep1_F SUB280_WT_rep2_F SUB280_WT_peroxide_rep1_F SUB280_WT_peroxide_rep2_F \\\n         SUB280_rad6_rep1_F SUB280_rad6_rep2_F SUB280_rad6_peroxide_rep1_F SUB280_rad6_peroxide_rep2_F \\\n         SUB280_hel2_F SUB280_hel2_peroxide_F SUB280_rad6_RAD6_F SUB280_rad6_RAD6_peroxide_F \\\n         SUB280_rad6_RAD6_C88A_F SUB280_rad6_RAD6_C88A_peroxide_F S288C_WT_F S288C_WT_peroxide_F \\\n         S288C_rad6_F S288C_rad6_peroxide_F \\\n         SUB280_WT_rep1_Fd SUB280_WT_rep2_Fd SUB280_WT_peroxide_rep1_Fd SUB280_WT_peroxide_rep2_Fd \\\n         SUB280_rad6_Fd SUB280_rad6_peroxide_Fd\ndo\n    STAR --runThreadN 20 \\\n         --outFilterType Normal \\\n         --alignEndsType EndToEnd \\\n         --outFilterMismatchNmax 1 \\\n         --outFilterMultimapNmax 1 \\\n         --genomeDir ../../index-data/sac-star-genome-index \\\n         --readFilesCommand gunzip -c \\\n         --readFilesIn ../3.rmrRNA-data/${i}.rmrRNA.fq.gz \\\n         --outFileNamePrefix ./${i} \\\n         --outSAMtype BAM SortedByCoordinate \\\n         --quantMode GeneCounts \\\n         --outSAMattributes All\ndone",
    "crumbs": [
      "More examples",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Ubiquitin conjugase Rad6</span>"
    ]
  },
  {
    "objectID": "Ubiquitin-conjugase-Rad6.html#constructing-a-ribotrans-object",
    "href": "Ubiquitin-conjugase-Rad6.html#constructing-a-ribotrans-object",
    "title": "\n13  Ubiquitin conjugase Rad6\n",
    "section": "\n13.6 Constructing a ribotrans Object",
    "text": "13.6 Constructing a ribotrans Object\nAfter obtaining the aligned BAM files, we proceeded to downstream analysis using the riboTransVis package. The first step involves creating a ribotrans object by selecting a subset of ribosome profiling (Ribo-seq) samples representative of different genetic backgrounds and experimental conditions. Once constructed, we performed a quality control (QC) analysis by extracting read information from all alignments.\nIn accordance with the original publication, ribosome footprints were assigned using the 3′ end of reads (assignment_mode = \"end3\"):\n\nlibrary(riboTransVis)\n\n# sample names\nsp &lt;- c(\"WT_rep1\",\"WT_rep2\",\n        \"WT_peroxide_rep1\",\"WT_peroxide_rep2\",\n        \"rad6_rep1\",\"rad6_rep2\",\n        \"rad6_peroxide_rep1\",\"rad6_peroxide_rep2\")\n\n# group names\ngp &lt;- c(\"WT\",\"WT\",\"WT_peroxide\",\"WT_peroxide\",\n        \"rad6\",\"rad6\",\"rad6_peroxide\",\"rad6_peroxide\")\n\n# bams\nribobams &lt;- c(\"SUB280_WT_rep1_FAligned.sortedByCoord.out.bam\",\n              \"SUB280_WT_rep2_FAligned.sortedByCoord.out.bam\",\n              \"SUB280_WT_peroxide_rep1_FAligned.sortedByCoord.out.bam\",\n              \"SUB280_WT_peroxide_rep2_FAligned.sortedByCoord.out.bam\",\n              \"SUB280_rad6_rep1_FAligned.sortedByCoord.out.bam\",\n              \"SUB280_rad6_rep2_FAligned.sortedByCoord.out.bam\",\n              \"SUB280_rad6_peroxide_rep1_FAligned.sortedByCoord.out.bam\",\n              \"SUB280_rad6_peroxide_rep2_FAligned.sortedByCoord.out.bam\")\n\n# construct_ribotrans\nobj &lt;- construct_ribotrans(genome_file = \"../../index-data/Saccharomyces_cerevisiae.R64-1-1.dna.toplevel.fa\",\n                           gtf_file = \"../../index-data/Saccharomyces_cerevisiae.R64-1-1.112.gtf\",\n                           mapping_type = \"genome\",\n                           assignment_mode = \"end3\",\n                           extend = TRUE,\n                           extend_upstream = 50,\n                           extend_downstream = 50,\n                           Ribo_bam_file = ribobams,\n                           Ribo_sample_name = sp,\n                           Ribo_sample_group = gp,\n                           choose_longest_trans = T)\n\n# generate summary data for QC or other analysis\nobj &lt;- generate_summary(object = obj, exp_type = \"ribo\", nThreads = 40)",
    "crumbs": [
      "More examples",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Ubiquitin conjugase Rad6</span>"
    ]
  },
  {
    "objectID": "Ubiquitin-conjugase-Rad6.html#ribo-seq-quality-control",
    "href": "Ubiquitin-conjugase-Rad6.html#ribo-seq-quality-control",
    "title": "\n13  Ubiquitin conjugase Rad6\n",
    "section": "\n13.7 Ribo-seq Quality Control",
    "text": "13.7 Ribo-seq Quality Control\n\n13.7.1 Length distribution\nPlotting the RPF Fragment Length Distribution:\n\n# qc\nlibrary(ggplot2)\n\nlength_plot(obj) +\n  scale_x_continuous(labels = scales::label_number(accuracy = 1)) +\n  facet_wrap(~sample, nrow = 2,scales = \"free\")\n\n\n\n\n\nSetting the option merge_rep = TRUE can be used to combine biological replicates for each condition:\n\nlength_plot(obj,merge_rep = T) +\n  scale_x_continuous(labels = scales::label_number(accuracy = 1)) +\n  facet_wrap(~sample, nrow = 1,scales = \"free\")\n\n\n\n\n\nAdding frame infomation:\n\nlength_plot(obj,type = \"frame_length\") +\n  facet_wrap(~sample, nrow = 2,scales = \"free\") +\n  scale_fill_grey()\n\n\n\n\n\n\n13.7.2 Frame proportion\nwe can visualize the overall proportion of reads aligning to frame 0, 1, and 2 using the frame_plot() function:\n\nframe_plot(obj) +\n  facet_wrap(~sample, nrow = 2,scales = \"free\")\n\n\n\n\n\n\n13.7.3 Feature distribution\nTo analyze the distribution of ribosome-protected fragments (RPFs) across different transcript features—including the 5′ untranslated region (5′ UTR), coding sequence (CDS), and 3′ untranslated region (3′ UTR)—you can use the feature_plot() function provided by the riboTransVis package as shown below:\n\nfeature_plot(obj) +\n  facet_wrap(~sample, nrow = 2,scales = \"free\")\n\n\n\n\n\n\n13.7.4 Distribution around start and stop codons\nDistribution relative to the start codon:\n\nrelative_dist_plot(obj, merge_rep = T)\n\n\n\n\n\nDistribution relative to the stop codon:\n\nrelative_dist_plot(obj,\n                   type = \"rel2stop\",\n                   merge_rep = T)\n\n\n\n\n\n\n13.7.5 Offset check\nRibo-seq reads were aligned by their 3′ ends. For Ribo-seq data, the reads were shifted 15 nt from their 3′ end to align the P-site to the beginning of each gene:\n\nrelative_offset_plot(obj)\n\n\n\n\n\n\n13.7.6 Save ribotrans object\nUse the save function to store our riboTrans object for future analysis. This saves the riboTrans object into an .rda file named “obj.rda”, so it can be loaded and reused in future R sessions without reprocessing.\n\nsave(obj,file = \"obj.rda\")",
    "crumbs": [
      "More examples",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Ubiquitin conjugase Rad6</span>"
    ]
  },
  {
    "objectID": "Ubiquitin-conjugase-Rad6.html#offset-correction",
    "href": "Ubiquitin-conjugase-Rad6.html#offset-correction",
    "title": "\n13  Ubiquitin conjugase Rad6\n",
    "section": "\n13.8 Offset correction",
    "text": "13.8 Offset correction\nAccording to the Methods section of the publication, only fragments with lengths between 25–34 nucleotides were retained for analysis. The authors applied a shift of 18 nucleotides from the 3′ end of each fragment to position the E-site correctly. Based on this approach, we shift the 3′ end of the reads by 18 nucleotides for alignment:\n\nlibrary(riboTransVis)\nlibrary(patchwork)\n\n# Load the saved riboTrans object\nload(\"obj.rda\")\n\n# Define the offset table for each sample and read length\noffset &lt;- rbind(\n  data.frame(list(sample = \"WT_rep1\",\n                  qwidth = 25:34,\n                  rel_pos = 18)),\n  data.frame(list(sample = \"WT_rep2\",\n                  qwidth = 25:34,\n                  rel_pos = 18)),\n  data.frame(list(sample = \"WT_peroxide_rep1\",\n                  qwidth = 25:34,\n                  rel_pos = 18)),\n  data.frame(list(sample = \"WT_peroxide_rep2\",\n                  qwidth = 25:34,\n                  rel_pos = 18)),\n  data.frame(list(sample = \"rad6_rep1\",\n                  qwidth = 25:34,\n                  rel_pos = 18)),\n  data.frame(list(sample = \"rad6_rep2\",\n                  qwidth = 25:34,\n                  rel_pos = 18)),\n  data.frame(list(sample = \"rad6_peroxide_rep1\",\n                  qwidth = 25:34,\n                  rel_pos = 18)),\n  data.frame(list(sample = \"rad6_peroxide_rep2\",\n                  qwidth = 25:34,\n                  rel_pos = 18))\n)\n\n# Assign the offset to the riboTrans object\nobj@reads_offset_info &lt;- offset",
    "crumbs": [
      "More examples",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Ubiquitin conjugase Rad6</span>"
    ]
  },
  {
    "objectID": "Ubiquitin-conjugase-Rad6.html#tri-peptide-analysis",
    "href": "Ubiquitin-conjugase-Rad6.html#tri-peptide-analysis",
    "title": "\n13  Ubiquitin conjugase Rad6\n",
    "section": "\n13.9 Tri-peptide analysis",
    "text": "13.9 Tri-peptide analysis\nIn the study, a tri-peptide (three-amino-acid motif) analysis was conducted based on the Ribo-seq data. It was observed that oxidative stress induces strong ribosome stalling at XIP motifs. However, this stalling effect disappears in RAD6 knockout cells, even under oxidative stress conditions.\n\n13.9.1 Extract CDS sequence\nAs a first step, we extract the coding sequences (CDS) of protein-coding genes for further tri-peptide analysis:\n\nget_transcript_sequence(genome_file = \"../../index-data/Saccharomyces_cerevisiae.R64-1-1.dna.toplevel.fa\",\n                        gtf_file = \"../../index-data/Saccharomyces_cerevisiae.R64-1-1.112.gtf\",\n                        feature = \"CDS\",\n                        output_file = \"sac_cds.fa\")\n\n🧬 Note: XIP represents a motif where “X” can be any amino acid, followed by isoleucine (I) at the P-site and proline (P) at the A-site of the ribosome — a major redox-responsive stalling signal identified in the paper.\n\n13.9.2 Tri-peptide pause score calculation\nTo investigate motif-specific translational pausing, we calculate the pause scores of tri-peptide sequences under different conditions and visualize the results:\n\npeptide_df &lt;- multi_peptide_occupancy(\n  object = obj,\n  cds_fa = \"./sac_cds.fa\",\n  do_offset_correct = TRUE,\n  peptide_length = 3,\n  peptide_occurrence = 100\n)\n\n# Access the pause scores in wide format (peptides × samples)\npdf &lt;- peptide_df$wider_format\n\n# View column names\ncolnames(pdf)\n# [1] \"pep_seq\"            \"WT_peroxide_rep1\"   \"WT_peroxide_rep2\"   \"WT_rep1\"            \"WT_rep2\"           \n# [6] \"rad6_peroxide_rep1\" \"rad6_peroxide_rep2\" \"rad6_rep1\"          \"rad6_rep2\"\n\nWe next compare the tri-peptide pause scores between oxidized vs control samples using scatter plots:\n\n# Plot pause score changes in WT samples\nwt1 &lt;- peptide_scatter_plot(data = pdf, x = \"WT_rep1\", y = \"WT_peroxide_rep1\")\nwt2 &lt;- peptide_scatter_plot(data = pdf, x = \"WT_rep2\", y = \"WT_peroxide_rep2\")\n\n# Plot pause score changes in Rad6-deletion samples\nrad61 &lt;- peptide_scatter_plot(data = pdf, x = \"rad6_rep1\", y = \"rad6_peroxide_rep1\")\nrad62 &lt;- peptide_scatter_plot(data = pdf, x = \"rad6_rep2\", y = \"rad6_peroxide_rep2\")\n\n# Combine plots for side-by-side comparison\n(wt1 + wt2) / (rad61 + rad62)\n\n\n\n\n\n\n13.9.2.1 Custom plot\nWe can customize our tri-peptide pause score plots using ggplot2 syntax for enhanced visualization and highlighting of specific motifs. Here’s an example:\n\n# Load required package\nlibrary(ggplot2)\n\n# define plot function\npeptide_scatter_plot2 &lt;- function(data = NULL,\n                                 x = NULL,y = NULL,\n                                 color = \"#003366\",\n                                 label_size = 3,\n                                 hjust = 1.2,vjust = 1.2,\n                                 motif = NULL){\n  \n  # get ratio\n  label_df &lt;- data[,c(\"pep_seq\",x,y)]\n  label_df &lt;- subset(label_df, pep_seq %in% motif)\n  \n  if (requireNamespace(\"grDevices\", quietly = TRUE)) {\n    xlims &lt;- grDevices::extendrange(data[,2:ncol(data)],f = 0.1)[2]\n  } else {\n    warning(\"Package 'grDevices' is needed for this function to work.\")\n  }\n  \n  \n  # plot\n  ggplot(data) +\n    geom_point(aes(x = get(x),y = get(y)),fill = color,shape = 21,color = \"grey50\") +\n    geom_text(data = label_df,\n              aes(x = get(x), y = get(y), label = pep_seq),\n              hjust = hjust, vjust = vjust, size = label_size, check_overlap = TRUE) +\n    geom_abline(slope = 1,intercept = 0,lty = \"dashed\", color = \"grey40\") +\n    theme_bw() +\n    theme(panel.grid = element_blank(),\n          axis.text = element_text(colour = \"black\")) +\n    coord_equal() +\n    xlab(x) + ylab(y) +\n    xlim(0, xlims) +\n    ylim(0, xlims)\n}\n\n\n# Define motifs of interest\nmotif &lt;- c(\"KIP\", \"MIP\", \"QIP\", \"KIH\", \"EIH\", \"RKK\", \"PPD\", \"PPE\")\n\n# Generate scatter plots highlighting specific motifs in each comparison\nwt1 &lt;- peptide_scatter_plot2(\n  data  = pdf,\n  x     = \"WT_rep1\",\n  y     = \"WT_peroxide_rep1\",\n  motif = motif,\n  color = \"#1DCD9F\"  # turquoise color for WT\n)\n\nwt2 &lt;- peptide_scatter_plot2(\n  data  = pdf,\n  x     = \"WT_rep2\",\n  y     = \"WT_peroxide_rep2\",\n  motif = motif,\n  color = \"#1DCD9F\"\n)\n\nrad61 &lt;- peptide_scatter_plot2(\n  data  = pdf,\n  x     = \"rad6_rep1\",\n  y     = \"rad6_peroxide_rep1\",\n  motif = motif,\n  color = \"#FEBA17\"  # amber color for rad6Δ\n)\n\nrad62 &lt;- peptide_scatter_plot2(\n  data  = pdf,\n  x     = \"rad6_rep2\",\n  y     = \"rad6_peroxide_rep2\",\n  motif = motif,\n  color = \"#FEBA17\"\n)\n\n# Arrange plots using patchwork\n(wt1 + wt2) / (rad61 + rad62)\n\n\n\n\n\n\n13.9.2.2 Combine biological replicates\nTo reduce variability and improve statistical power, we merge multiple biological replicates using the parameter merge_rep = TRUE in the multi_peptide_occupancy function:\n\n# Merge replicates\npeptide_df2 &lt;- multi_peptide_occupancy(\n  object = obj,\n  cds_fa = \"./sac_cds.fa\",\n  do_offset_correct = TRUE,\n  peptide_length = 3,\n  merge_rep = TRUE\n)\n\n# Retrieve data in wide format\npdf2 &lt;- peptide_df2$wider_format\n\n# Check column names\ncolnames(pdf2)\n# [1] \"pep_seq\"       \"WT\"            \"WT_peroxide\"   \"rad6\"          \"rad6_peroxide\"\n\nWe then visualize motif-specific pause score changes between conditions using customized scatter plots:\n\n# Generate scatter plot comparing WT with and without oxidative stress\nwt &lt;- peptide_scatter_plot2(\n  data = pdf2,\n  x = \"WT\",\n  y = \"WT_peroxide\",\n  motif = motif,\n  color = \"#1DCD9F\"\n)\n\n# Generate scatter plot comparing rad6Δ with and without oxidative stress\nrad6 &lt;- peptide_scatter_plot2(\n  data = pdf2,\n  x = \"rad6\",\n  y = \"rad6_peroxide\",\n  motif = motif,\n  color = \"#FEBA17\"\n)\n\n# Combine plots for side-by-side comparison\nwt + rad6",
    "crumbs": [
      "More examples",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Ubiquitin conjugase Rad6</span>"
    ]
  },
  {
    "objectID": "Ubiquitin-conjugase-Rad6.html#gene-ribosome-occupancy",
    "href": "Ubiquitin-conjugase-Rad6.html#gene-ribosome-occupancy",
    "title": "\n13  Ubiquitin conjugase Rad6\n",
    "section": "\n13.10 Gene ribosome occupancy",
    "text": "13.10 Gene ribosome occupancy\nThis study demonstrated that the SKI2 and PCF11 genes exhibit pronounced ribosome pausing following oxidative stress, specifically at the LIP and KIP tri-peptide motifs. Interestingly, this stress-induced stalling is lost in RAD6-deficient (rad6Δ) cells.\nTo visualize ribosome occupancy for these two genes, we can generate ribosome profiling (Ribo-seq) track plots that include biological replicates.\n\n13.10.1 With biological replicates\nThe following code generates ribosome occupancy tracks for SKI2 and PCF11, retaining biological replicate information:\n\n# Generate gene track plots with biological replicates\nplist &lt;- lapply(c(\"SKI2\", \"PCF11\"), function(x) {\n  obj &lt;- get_occupancy(\n    object = obj, \n    gene_name = x, \n    coordinate_to_trans = TRUE,\n    do_reads_offset = TRUE,\n    merge_rep = FALSE  # Retain individual replicates\n  )\n  \n  # Create ribosome occupancy plot\n  p &lt;- trans_plot(object = obj, type = \"ribo\")\n  return(p)\n})\n\n# Combine plots side by side\ncowplot::plot_grid(plotlist = plist, nrow = 1)\n\n\n\n\n\n\n13.10.2 Biological replicates combination\nTo improve signal clarity and reduce variability, we combine biological replicates when visualizing ribosome occupancy for the SKI2 and PCF11 genes:\n\n# Plot ribosome occupancy tracks for SKI2 and PCF11 with merged biological replicates\nplist &lt;- lapply(c(\"SKI2\", \"PCF11\"), function(x) {\n  obj &lt;- get_occupancy(\n    object = obj,\n    gene_name = x,\n    coordinate_to_trans = TRUE,\n    do_reads_offset = TRUE,\n    merge_rep = TRUE  # Merge biological replicates\n  )\n\n  # Generate ribosome footprint plot\n  p &lt;- trans_plot(object = obj, type = \"ribo\")\n  return(p)\n})\n\n# Display plots side by side\ncowplot::plot_grid(plotlist = plist, nrow = 1)",
    "crumbs": [
      "More examples",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Ubiquitin conjugase Rad6</span>"
    ]
  },
  {
    "objectID": "Ubiquitin-conjugase-Rad6.html#motif-centered-analysis",
    "href": "Ubiquitin-conjugase-Rad6.html#motif-centered-analysis",
    "title": "\n13  Ubiquitin conjugase Rad6\n",
    "section": "\n13.11 Motif-centered analysis",
    "text": "13.11 Motif-centered analysis\nThe authors identified an increased ribosome occupancy at XIP motifs based on global tri-peptide pause score analysis. To further characterize this observation, they examined ribosome occupancy profiles upstream and downstream of these motifs. Here, we reproduce this analysis using biological replicates.\n\n13.11.1 With biological replicates\nIn the XIP motif, “X” represents any amino acid. Therefore, we first generate all possible amino acid combinations that match the pattern “XIP”, and then compute and visualize the ribosome occupancy around these motif sites:\n\n# Define all 20 amino acids by one-letter code\naa_one_letter &lt;- c(\"A\", \"R\", \"N\", \"D\", \"C\", \"Q\", \"E\", \"G\", \"H\", \"I\", \n                   \"L\", \"K\", \"M\", \"F\", \"P\", \"S\", \"T\", \"W\", \"Y\", \"V\")\n\n# Extract relative ribosome occupancy around XIP-like motifs (±30 nt window)\nrelmotif &lt;- relative_motif_occupancy(\n  object = obj, \n  cds_fa = \"sac_cds.fa\",\n  do_offset_correct = FALSE,\n  motif_upstream = 30,\n  motif_downstream = 30,\n  motif_pattern = paste(aa_one_letter, \"IP\", sep = \"\")\n)\n\n# Preview the first few rows\nhead(relmotif)\n\n# Group and summarize occupancy values per distance and sample\nrelmotif &lt;- relmotif %&gt;% \n  dplyr::mutate(motif = \"XIP\") %&gt;% \n  dplyr::group_by(sample, motif, dist) %&gt;% \n  dplyr::summarise(mn = mean(avg_val), .groups = \"drop\")\n\n# Plot ribosome occupancy profiles across samples\nggplot(relmotif) +\n  geom_path(aes(x = dist, y = mn)) +\n  facet_wrap(~sample, scales = \"fixed\", nrow = 2) +\n  theme(panel.grid = element_blank(),\n        strip.text = element_text(face = \"bold\"),\n        axis.text = element_text(color = \"black\")) +\n  xlab(\"Distance of 3'end to motif center\") +\n  ylab(\"Average ribosome occupancy\")\n\n\n\n\n\n\n13.11.2 Biological replicates combination\nThe R code used to perform motif-centered ribosome occupancy analysis on merged replicate data, followed by a line plot of average occupancy profiles:\n\n# Compute ribosome occupancy around combined XIP motifs with merged replicates\nrelmotif2 &lt;- relative_motif_occupancy(\n  object = obj, \n  cds_fa = \"sac_cds.fa\",\n  do_offset_correct = FALSE,\n  merge_rep = TRUE,\n  motif_upstream = 30,\n  motif_downstream = 30,\n  motif_pattern = paste(aa_one_letter, \"IP\", sep = \"\")\n)\n\n# Summarize and tag motif\nrelmotif2 &lt;- relmotif2 %&gt;%\n  dplyr::mutate(motif = \"XIP\") %&gt;%\n  dplyr::group_by(sample, motif, dist) %&gt;%\n  dplyr::summarise(mn = mean(avg_val), .groups = \"drop\")\n\n# Plot ribosome occupancy profiles\nggplot(relmotif2) +\n  geom_path(aes(x = dist, y = mn, color = sample)) +\n  facet_wrap(~sample, scales = \"fixed\", nrow = 1) +\n  theme_bw() +\n  theme(\n    panel.grid = element_blank(),\n    strip.text = element_text(face = \"bold\"),\n    axis.text = element_text(color = \"black\")\n  ) +\n  xlab(\"Distance of 3'end to motif\") +\n  ylab(\"Average ribosome occupancy\")\n\n\n\n\n\nFurther analysis of the remaining samples can be performed at the users’ discretion.",
    "crumbs": [
      "More examples",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Ubiquitin conjugase Rad6</span>"
    ]
  },
  {
    "objectID": "Periodicy-check.html",
    "href": "Periodicy-check.html",
    "title": "\n6  Periodicity check\n",
    "section": "",
    "text": "6.1 Introduction\nIn addition to evaluating ribosome profiling (Ribo-seq) data periodicity by analyzing the distribution of reads across the three translational reading frames (frame 0, 1, 2), another powerful approach is to apply Discrete Fourier Transform (DFT) to directly assess periodic patterns in the data. This method can quantitatively capture the characteristic 3-nucleotide (3-nt) periodicity associated with actively translating ribosomes. A notable example of this approach is demonstrated in the Cell Reports article “Genome-wide Survey of Ribosome Collision” where DFT was used to investigate periodic features in ribosome footprint data.\nThe figure below illustrates the detection of 3-nt periodicity using Discrete Fourier Transform (DFT) as presented in the article:",
    "crumbs": [
      "Quality assessment",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Periodicity check</span>"
    ]
  },
  {
    "objectID": "Periodicy-check.html#discrete-fourier-transform-for-periodiciy-check",
    "href": "Periodicy-check.html#discrete-fourier-transform-for-periodiciy-check",
    "title": "\n6  Periodicity check\n",
    "section": "\n6.2 Discrete fourier transform for periodiciy check",
    "text": "6.2 Discrete fourier transform for periodiciy check\nThe period_plot function can be used to analyze and visualize the 3-nucleotide (3-nt) periodicity of Ribo-seq reads. In this example, we use the ribo_trans object generated in the “Ubiquitin Conjugase Rad6” section. For details on data processing and object construction, please refer to that section.\nBy default, the function plots periodicity across all read lengths:\n\nperiod_plot(object = obj)\n\n\n\n\n\nTo merge biological replicates before performing the analysis:\n\nperiod_plot(object = obj,merge_rep = T)\n\n\n\n\n\nTo ignore read-length grouping and show combined periodicity:\n\nperiod_plot(object = obj,\n            group_by_readlength = F)",
    "crumbs": [
      "Quality assessment",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Periodicity check</span>"
    ]
  },
  {
    "objectID": "DENR-promotes-translation-reinitiation.html",
    "href": "DENR-promotes-translation-reinitiation.html",
    "title": "\n17  DENR promotes translation reinitiation\n",
    "section": "",
    "text": "17.1 Intro\nIn this section, we demonstrate how to reproduce the findings of the 2020 Nature Communications publication titled “DENR promotes translation reinitiation via ribosome recycling to drive expression of oncogenes including ATF4” using the riboTransVis tool.\nThis study reveals that the translation factors DENR and MCTS1 are crucial for promoting translation reinitiation after certain upstream open reading frames (uORFs), especially under stress conditions. They enable efficient expression of key stress-response and cancer-related genes like ATF4 by recycling 40S ribosomal subunits on mRNAs with specific uORF features, notably certain penultimate codons that otherwise hinder ribosome recycling.\nThe authors show that without DENR or MCTS1, the translation of ATF4 and other oncogenes such as a-Raf, c-Raf, and CDK4 is significantly impaired. They also find a strong correlation between DENR-MCTS1 expression and ATF4 activity across various cancer types, suggesting a broader role in tumor progression and highlighting a potential therapeutic vulnerability.",
    "crumbs": [
      "More examples",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>DENR promotes translation reinitiation</span>"
    ]
  },
  {
    "objectID": "DENR-promotes-translation-reinitiation.html#data-download",
    "href": "DENR-promotes-translation-reinitiation.html#data-download",
    "title": "\n17  DENR promotes translation reinitiation\n",
    "section": "\n17.2 Data download",
    "text": "17.2 Data download\nTo begin, we use the GEO accession number GSE140084 provided in the paper to download the raw FASTQ data from the GEO database. In this case, we focus only on downloading datasets related to 80S ribosome profiling and RNA-seq:\n\n\n\n\nThe Aspera download link is as follows:\n\nascp -QT -l 300m -P33001 -i $HOME/.aspera/connect/etc/asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:/vol1/fastq/SRR104/060/SRR10416860/SRR10416860.fastq.gz .\nascp -QT -l 300m -P33001 -i $HOME/.aspera/connect/etc/asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:/vol1/fastq/SRR104/061/SRR10416861/SRR10416861.fastq.gz .\nascp -QT -l 300m -P33001 -i $HOME/.aspera/connect/etc/asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:/vol1/fastq/SRR115/069/SRR11553469/SRR11553469.fastq.gz .\nascp -QT -l 300m -P33001 -i $HOME/.aspera/connect/etc/asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:/vol1/fastq/SRR104/057/SRR10416857/SRR10416857.fastq.gz .\nascp -QT -l 300m -P33001 -i $HOME/.aspera/connect/etc/asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:/vol1/fastq/SRR104/056/SRR10416856/SRR10416856.fastq.gz .\nascp -QT -l 300m -P33001 -i $HOME/.aspera/connect/etc/asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:/vol1/fastq/SRR104/058/SRR10416858/SRR10416858.fastq.gz .\nascp -QT -l 300m -P33001 -i $HOME/.aspera/connect/etc/asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:/vol1/fastq/SRR104/059/SRR10416859/SRR10416859.fastq.gz .\nascp -QT -l 300m -P33001 -i $HOME/.aspera/connect/etc/asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:/vol1/fastq/SRR115/070/SRR11553470/SRR11553470.fastq.gz .\nascp -QT -l 300m -P33001 -i $HOME/.aspera/connect/etc/asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:/vol1/fastq/SRR115/068/SRR11553468/SRR11553468.fastq.gz .",
    "crumbs": [
      "More examples",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>DENR promotes translation reinitiation</span>"
    ]
  },
  {
    "objectID": "DENR-promotes-translation-reinitiation.html#adapter-trimming",
    "href": "DENR-promotes-translation-reinitiation.html#adapter-trimming",
    "title": "\n17  DENR promotes translation reinitiation\n",
    "section": "\n17.3 Adapter trimming",
    "text": "17.3 Adapter trimming\nFirst, we remove the universal adapter sequences:\n\n# Remove universal adapter sequences\nfor i in SRR10416856 SRR10416857 SRR10416858 SRR10416859 SRR10416860 SRR10416861 SRR11553468 SRR11553469 SRR11553470\ndo\n    trim_galore -j 20 -q 25 --stringency 3 --length 25 \\\n        -o ./ ../1.raw-data/${i}.fastq.gz\ndone\n\nNext, we remove custom adapter sequences that were specifically added:\n\n# Remove custom adapter sequences (e.g., 3' end clipping of 8 bases)\nfor i in SRR10416856 SRR10416857 SRR10416858 SRR10416859 SRR10416860 SRR10416861\ndo\n    trim_galore -j 20 -q 25 --stringency 3 \\\n                --length 25 --three_prime_clip_R1 8 \\\n                -o ./ ./trim1/${i}_trimmed.fq.gz\ndone\n\n\n17.3.1 Removing rRNA contamination\nTo eliminate reads originating from rRNA, we first download human rRNA sequences and build a Bowtie2 index. We then align each FASTQ file to the rRNA reference and retain only the reads that do not align (i.e., non-rRNA reads):\n\n# Remove rRNA-mapped reads using Bowtie2\nfor i in SRR10416856 SRR10416857 SRR10416858 SRR10416859 SRR10416860 SRR10416861\ndo\n    bowtie2 -p 20 -x ../../index-data/human-rRNA-index/human-rRNA \\\n            --un-gz ./${i}.rmrRNA.fq.gz \\\n            -U ../2.trim-data/${i}_trimmed_trimmed.fq.gz \\\n            -S ./null\ndone",
    "crumbs": [
      "More examples",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>DENR promotes translation reinitiation</span>"
    ]
  },
  {
    "objectID": "DENR-promotes-translation-reinitiation.html#alignment-to-reference",
    "href": "DENR-promotes-translation-reinitiation.html#alignment-to-reference",
    "title": "\n17  DENR promotes translation reinitiation\n",
    "section": "\n17.4 Alignment to reference",
    "text": "17.4 Alignment to reference\n\n17.4.1 Alignment to the transcriptome\nFirst, extract all transcript sequences from the reference genome and annotation files:\n\n# Extract transcript sequences from genome and GTF annotation\nget_transcript_sequence(\n  genome_file = \"Homo_sapiens.GRCh38.dna.primary_assembly.fa\",\n  gtf_file = \"Homo_sapiens.GRCh38.94.gtf.gz\",\n  output_file = \"ribo_trans.fa\"\n)\n\nNext, build a HISAT2 index from the extracted transcript sequences:\n\n# Build transcriptome index using HISAT2\nhisat2-build -p 20 ./ribo_trans.fa hisat-index/trans\n\nThen, align reads that have had rRNA removed to the transcriptome and sort the alignments:\n\n# Align reads to transcriptome and sort alignments\nfor i in SRR10416856 SRR10416857 SRR10416858 SRR10416859 SRR10416860 SRR10416861\ndo\n  hisat2 -p 20 -x ../hisat-index/trans \\\n         --summary-file ${i}.mapinfo.txt \\\n         -U ../3.rmrRNA-data/${i}.rmrRNA.fq.gz \\\n  | samtools sort -@ 20 -o ${i}.h2sorted.bam\ndone\n\n\n17.4.2 Alignment to the reference genome\nTo save time and computational resources, pre-built HISAT2 indices for the human genome can be downloaded from the HISAT2 official website.\nOnce the index is available, map the reads directly to the genome:\n\n# Align to the human reference genome using a prebuilt index and sort alignments\nfor i in SRR10416856 SRR10416857 SRR10416858 SRR10416859 SRR10416860 SRR10416861\ndo\n  hisat2 -p 20 -x ../../index-data/grch38_hisat2_index/genome \\\n         --summary-file ${i}.mapinfo.txt \\\n         -U ../3.rmrRNA-data/${i}.rmrRNA.fq.gz \\\n  | samtools sort -@ 20 -o ./genome/${i}.genome.bam\ndone",
    "crumbs": [
      "More examples",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>DENR promotes translation reinitiation</span>"
    ]
  },
  {
    "objectID": "DENR-promotes-translation-reinitiation.html#constructing-the-ribotrans-object",
    "href": "DENR-promotes-translation-reinitiation.html#constructing-the-ribotrans-object",
    "title": "\n17  DENR promotes translation reinitiation\n",
    "section": "\n17.5 Constructing the ribotrans object",
    "text": "17.5 Constructing the ribotrans object\nIn this step, we use BAM files aligned to the transcriptome to build a ribotrans object for downstream analysis:\n\n# Set the working directory\nsetwd(\"~/junjun_proj/22.ribo_4060s/\")\ngetwd()\n\n# Install and load the riboTransVis package\ndevtools::install_github(\"junjunlab/riboTransVis\", force = TRUE)\nlibrary(riboTransVis)\n\n# Define sample names and their corresponding experimental groups\nsp &lt;- c(\"wt1\", \"wt2\", \"ko1\", \"ko2\")\ngp &lt;- c(\"wt\", \"wt\", \"ko\", \"ko\")\n\n# Specify RNA-seq BAM file paths\nrnabams &lt;- c(\"./4.map-data/SRR10416859.h2sorted.bam\",\n             \"./4.map-data/SRR10416859.h2sorted.bam\",\n             \"./4.map-data/SRR10416860.h2sorted.bam\",\n             \"./4.map-data/SRR10416861.h2sorted.bam\")\n\n# Specify Ribo-seq BAM file paths\nribobams &lt;- c(\"./4.map-data/SRR10416856.h2sorted.bam\",\n              \"./4.map-data/SRR10416856.h2sorted.bam\",\n              \"./4.map-data/SRR10416857.h2sorted.bam\",\n              \"./4.map-data/SRR10416858.h2sorted.bam\")\n\n# Construct the ribotrans object using transcriptome-aligned BAMs\nobj &lt;- construct_ribotrans(\n  gtf_file = \"./Homo_sapiens.GRCh38.94.gtf.gz\",\n  RNA_bam_file = rnabams,\n  RNA_sample_name = sp,\n  RNA_sample_group = gp,\n  mapping_type = \"transcriptome\",\n  assignment_mode = \"end5\",\n  Ribo_bam_file = ribobams,\n  Ribo_sample_name = sp,\n  Ribo_sample_group = gp,\n  choose_longest_trans = TRUE\n)\n\n# Generate summary statistics for visualization and analysis\nobj &lt;- generate_summary(\n  object = obj,\n  exp_type = \"ribo\",\n  nThreads = 40\n)",
    "crumbs": [
      "More examples",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>DENR promotes translation reinitiation</span>"
    ]
  },
  {
    "objectID": "DENR-promotes-translation-reinitiation.html#qc-check",
    "href": "DENR-promotes-translation-reinitiation.html#qc-check",
    "title": "\n17  DENR promotes translation reinitiation\n",
    "section": "\n17.6 QC check",
    "text": "17.6 QC check\nTo inspect the distribution of read fragment lengths across samples, use the following code:\n\n# Plot the distribution of read fragment lengths for each sample\nlength_plot(obj) +\n  scale_x_continuous(labels = scales::label_number(accuracy = 1)) +\n  facet_wrap(~sample, nrow = 2, scales = \"free\")",
    "crumbs": [
      "More examples",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>DENR promotes translation reinitiation</span>"
    ]
  },
  {
    "objectID": "DENR-promotes-translation-reinitiation.html#metagene-analysis",
    "href": "DENR-promotes-translation-reinitiation.html#metagene-analysis",
    "title": "\n17  DENR promotes translation reinitiation\n",
    "section": "\n17.7 Metagene analysis",
    "text": "17.7 Metagene analysis\nThe ribosome occupancy around the start and stop codons as presented in the figure is derived from the data shown in the article:\n\n\n\n\n\n17.7.1 Nucleotide mode\nTo visualize ribosome occupancy profiles with single-nucleotide precision around the start and stop codons, use the code below:\n\n# Meta-gene plot aligned to the start codon, at nucleotide (base-pair) resolution\nmt1 &lt;- metagene_plot(object = obj) +\n  geom_path(aes(color = sample))\n\n# Meta-gene plot aligned to the stop codon, at nucleotide resolution\nmt2 &lt;- metagene_plot(object = obj, type = \"rel2stop\") +\n  geom_path(aes(color = sample))\n\n# Load patchwork to combine the plots\nlibrary(patchwork)\n\n# Display both plots side by side\nmt1 + mt2\n\n\n\n\n\n\n17.7.2 Codon mode\nTo display ribosome occupancy relative to the start and stop codons with codon-level resolution, use the following code:\n\n# Create a meta-gene plot aligned to the start codon, shown at codon resolution\nmt3 &lt;- metagene_plot(object = obj,\n                     mode = \"codon\",\n                     rel2st_dist = c(-150, 500)) +\n  geom_path(aes(color = sample))\n\n# Create a meta-gene plot aligned to the stop codon, shown at codon resolution\nmt4 &lt;- metagene_plot(object = obj, \n                     type = \"rel2stop\",\n                     mode = \"codon\",\n                     rel2st_dist = c(-150, 500)) +\n  geom_path(aes(color = sample))\n\n# Combine the two plots side by side\nmt3 + mt4",
    "crumbs": [
      "More examples",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>DENR promotes translation reinitiation</span>"
    ]
  },
  {
    "objectID": "DENR-promotes-translation-reinitiation.html#track-plot-for-single-gene",
    "href": "DENR-promotes-translation-reinitiation.html#track-plot-for-single-gene",
    "title": "\n17  DENR promotes translation reinitiation\n",
    "section": "\n17.8 Track plot for single gene",
    "text": "17.8 Track plot for single gene\nThe following track plot depicts ribosome occupancy indicating reinitiation at uORFs of representative genes upon DENR depletion, as reported in the study:\n\n\n\n\nThe plots were generated by first normalizing Ribo-seq and RNA-seq datasets to account for sequencing depth. Ribosome footprint densities were then adjusted based on mRNA expression levels to estimate translational efficiency at the transcript level. A smoothing algorithm (e.g., sliding window averaging) was applied to reduce noise and highlight translational features:\n\n\n\n\n\n17.8.1 Track plot for RNA coverage\nThe get_coverage() function can extract read coverage data for a specified gene directly from BAM files and output the results as RPM (Reads Per Million) values:\n\n# Specify the gene of interest\ngene_name &lt;- \"DROSHA\"\n\n# Extract coverage data for the given gene from the BAM file\nobj &lt;- get_coverage(object = obj, gene_name = gene_name)\n\n# Preview the resulting RNA-seq coverage table\nhead(obj@RNA_coverage)\n\n# Output example:\n#                    rname pos count        rpm sample sample_group     smooth\n# 1 ENST00000511367|DROSHA   1     1 0.02683300    wt1           wt 0.02683300\n# 2 ENST00000511367|DROSHA   2     1 0.02683300    wt1           wt 0.02683300\n# 3 ENST00000511367|DROSHA   3     2 0.05366601    wt1           wt 0.05366601\n# 4 ENST00000511367|DROSHA   4     2 0.05366601    wt1           wt 0.05366601\n# 5 ENST00000511367|DROSHA   5     3 0.08049901    wt1           wt 0.08049901\n# 6 ENST00000511367|DROSHA   6     6 0.16099802    wt1           wt 0.16099802\n\nYou can visualize the coverage using the trans_plot() function:\n\ntrans_plot(object = obj, type = \"rna\")\n\n\n\n\n\nApply a different track style for visualization:\n\ntrans_plot(object = obj, type = \"rna\", layer = \"col\")\n\n\n\n\n\n\n17.8.2 Track plot for ribosome occupancy\nThe get_occupancy() function retrieves ribosome-protected fragment (RPF) reads mapped to a specified gene from BAM files and calculates ribosome occupancy in units of RPM (Reads Per Million mapped reads):\n\n# Specify the target gene (e.g., ATF4)\nobj &lt;- get_occupancy(object = obj, gene_name = gene_name)\n\n# View the resulting ribosome occupancy data\nhead(obj@ribo_occupancy)\n# A tibble: 6 × 7\n#   sample_group sample rname                  pos count   rpm smooth\n#   &lt;chr&gt;        &lt;chr&gt;  &lt;fct&gt;                &lt;int&gt; &lt;int&gt; &lt;dbl&gt;  &lt;dbl&gt;\n# 1 wt           wt1    ENST00000337304|ATF4     3     1 0.0200 0.0200\n# 2 wt           wt1    ENST00000337304|ATF4     5     3 0.0600 0.0600\n# 3 wt           wt1    ENST00000337304|ATF4     6     3 0.0600 0.0600\n# 4 wt           wt1    ENST00000337304|ATF4     7     5 0.1000 0.1000 \n# 5 wt           wt1    ENST00000337304|ATF4     8    11 0.2200 0.2200 \n# 6 wt           wt1    ENST00000337304|ATF4     9    55 1.1000 1.1000\n\nVisualize the ribosome occupancy along the transcript:\n\ntrans_plot(object = obj, type = \"ribo\") +\ntrans_plot(object = obj, type = \"ribo\", layer = \"col\")\n\n\n\n\n\n\n17.8.3 Scaled to mRNA abundence\nThe get_scaled_occupancy() function normalizes ribosome occupancy to mRNA expression by calculating, for each nucleotide position along a transcript, the ratio of ribosome occupancy (in RPM) to RNA-seq coverage (also in RPM). This returns a scaled occupancy value for each position, reflecting translation efficiency adjusted for mRNA abundance:\n\n# Calculate scaled occupancy with smoothing enabled\nobj &lt;- get_scaled_occupancy(object = obj,\n                            smooth = TRUE,\n                            slide_window = 60)\n\n\n# examine the scaled occupancy data\nhead(obj@scaled_occupancy)\n\n# Output example:\n#                    rname pos sample      rpm.x    rpm.y    enrich  smooth\n# 1 ENST00000511367|DROSHA   1    wt1 0.00000000 0.000000 0.0000000       0\n# 2 ENST00000511367|DROSHA   2    wt1 0.00000000 0.000000 0.0000000       0\n# 3 ENST00000511367|DROSHA   3    wt1 0.00000000 0.000000 0.0000000       0\n# 4 ENST00000511367|DROSHA   4    wt1 0.00000000 0.000000 0.0000000       0\n# 5 ENST00000511367|DROSHA   5    wt1 0.00000000 0.000000 0.0000000       0\n# 6 ENST00000511367|DROSHA   6    wt1 0.03998232 0.160998 0.2483405       0\n\nParameter explanation:\n\nsmooth: Logical. When set to TRUE, applies smoothing to the position-wise scaled occupancy (rpm.ribo / rpm.rna) values.\nslide_window: Integer. Specifies the width (in nucleotides) of the sliding window used for smoothing.\n\nVisualize the data:\n\ntrans_plot(object = obj, type = \"scaled_ribo\")\n\n\n\n\n\nCombine the samples:\n\ntrans_plot(object = obj, \n           type = \"scaled_ribo\",\n           facet_layer = ggplot2::facet_grid(~rname,switch = \"y\"))\n\n\n\n\n\n\n17.8.4 Batch track plot for multiple genes\nTo visualize ribosome occupancy tracks for several genes simultaneously, we performed a batch plot by looping through a selected list of genes. For each gene, we calculated RNA coverage, ribosome occupancy (RPM), and scaled ribosome density (occupancy normalized to mRNA abundance), followed by smoothed plotting:\n\n# Gene list to be visualized\ngenes &lt;- c(\"DROSHA\", \"ATF4\", \"TUBA1B\", \"RAN\", \"MAP2K6\", \"ARAF\", \"RAF1\")\n\n# Batch processing and plotting\nplist &lt;- lapply(seq_along(genes), function(x) {\n  obj &lt;- get_coverage(object = obj, gene_name = genes[x])\n  obj &lt;- get_occupancy(object = obj, gene_name = genes[x])\n  \n  obj &lt;- get_scaled_occupancy(object = obj,\n                              smooth = TRUE,\n                              slide_window = 60)\n  \n  trans_plot(object = obj,\n             type = \"scaled_ribo\",\n             facet_layer = ggplot2::facet_grid(~rname, switch = \"y\"))\n})\n\n# Combine all gene plots into a single panel (2 columns)\ncowplot::plot_grid(plotlist = plist, ncol = 2)",
    "crumbs": [
      "More examples",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>DENR promotes translation reinitiation</span>"
    ]
  },
  {
    "objectID": "Pathway-enrichment-analysis.html",
    "href": "Pathway-enrichment-analysis.html",
    "title": "Pathway enrichment analysis",
    "section": "",
    "text": "Intro\nIn the previous section, we introduced how to quantify RNA, extract normalized data, and perform differential analysis. We also discussed which pathways might be associated with up- and down-regulated genes. In this section, we demonstrate how to conduct pathway enrichment analysis on the differentially expressed genes identified.",
    "crumbs": [
      "Pathway enrichment analysis"
    ]
  },
  {
    "objectID": "Pathway-enrichment-analysis.html#go-enrichment-analysis",
    "href": "Pathway-enrichment-analysis.html#go-enrichment-analysis",
    "title": "Pathway enrichment analysis",
    "section": "Go enrichment analysis",
    "text": "Go enrichment analysis\nThe enrich_analysis function can be applied to the differential analysis results obtained previously. It utilizes the clusterProfiler package to carry out pathway enrichment and returns a list containing both the GO and KEGG enrichment objects as well as corresponding tables.\nFor example, the following code snippet selects up-regulated genes for Biological Process (BP) pathway enrichment:\n\nlibrary(clusterProfiler)\nlibrary(org.Hs.eg.db)\n\nen &lt;- enrich_analysis(diff_data = te.rex$deg_anno,\n                      log2fc_col = \"log2FoldChange\",\n                      pval_col = \"pvalue\",\n                      type = \"go\",\n                      trend = \"up\",\n                      ont = \"BP\",\n                      organism = \"hsa\",\n                      OrgDb = org.Hs.eg.db)\n\n\n\n\n\nAfter obtaining the enrichment results, you can use the enrichplot package to produce various visualizations:\n\n# dotplot\nenrichplot::dotplot(en$enrich.go.obj)",
    "crumbs": [
      "Pathway enrichment analysis"
    ]
  },
  {
    "objectID": "Pathway-enrichment-analysis.html#gsea-enrichment-analysis",
    "href": "Pathway-enrichment-analysis.html#gsea-enrichment-analysis",
    "title": "Pathway enrichment analysis",
    "section": "GSEA enrichment analysis",
    "text": "GSEA enrichment analysis\nSpecifying type = “gsea” includes all genes in the GSEA-based enrichment analysis:\n\nen2 &lt;- enrich_analysis(diff_data = te.rex$deg_anno,\n                      log2fc_col = \"log2FoldChange\",\n                      pval_col = \"pvalue\",\n                      type = \"gsea\",\n                      ont = \"BP\",\n                      organism = \"hsa\",\n                      OrgDb = org.Hs.eg.db)\n\n\n\n\n\nGSEA visualization:\n\nhead(en2$enrich.go.df$ID)\n# [1] \"GO:0003044\" \"GO:0050818\" \"GO:1900118\" \"GO:0007030\" \"GO:0030193\" \"GO:1900046\"\n\nenrichplot::gseaplot2(x = en2$enrich.go.obj,\n                      geneSetID = \"GO:0003044\")\n\n\n\n\n\nMultiple pathway visualization:\n\nenrichplot::gseaplot2(x = en2$enrich.go.obj,\n                      geneSetID = c(\"GO:0003044\", \"GO:0050818\", \"GO:1900118\"))",
    "crumbs": [
      "Pathway enrichment analysis"
    ]
  },
  {
    "objectID": "Gene-expression-analysis.html",
    "href": "Gene-expression-analysis.html",
    "title": "Global gene expression analysis",
    "section": "",
    "text": "Intro\nIn addition to analyzing ribosome profiling (Ribo-seq) data from the perspective of codon usage, amino acid composition, or other sequence-based features, a key focus in translational research lies in assessing changes in gene-level expression and translational regulation. Specifically, researchers are often interested in how translational efficiency (TE) and mRNA abundance vary across different conditions.\nThis section introduces how to use the riboTransVis toolkit for global RNA and RPF (Ribosome-Protected Fragment) quantification, differential expression analysis, and calculation of translational efficiency. By integrating Ribo-seq and RNA-seq data, riboTransVis facilitates systematic identification of genes with altered protein synthesis, enabling insights into translational control mechanisms that cannot be captured by transcriptome data alone.\nThrough this approach, we aim to provide a comprehensive framework for analyzing genome-wide translational changes, which can support functional discovery and reveal phenomena such as selective translation, stress response adaptation, and oncogenic translation reprogramming.",
    "crumbs": [
      "Global gene expression analysis"
    ]
  },
  {
    "objectID": "Gene-expression-analysis.html#quantify-gene-expression-with-counts",
    "href": "Gene-expression-analysis.html#quantify-gene-expression-with-counts",
    "title": "Global gene expression analysis",
    "section": "Quantify gene expression with counts",
    "text": "Quantify gene expression with counts\nThe get_counts() function utilizes the featureCounts algorithm from the Rsubread package to efficiently quantify gene-level expression from RNA-seq and Ribo-seq data. By default, it performs read counting over exon features for RNA-seq and coding sequence (CDS) features for RPF (ribosome-protected fragments) data. Users can explicitly specify the annotation features used for quantification via the options: rna_feature = “exon” and ribo_feature = “CDS”.\nAdditionally, if the BAM files are aligned to the genome, Rsubread’s featureCounts is used for quantification. If instead the BAM files are aligned to the transcriptome, the function directly obtains read counts from the BAM files themselves.\nThe resulting count information is stored in the counts slot of the input object:\n\nobj &lt;- get_counts(obj, nThreads = 15)\n\n# check\nstr(obj@counts)\n# List of 2\n# $ rpf:'data.frame':   14647 obs. of  4 variables:\n#   ..$ wt1: num [1:14647] 1 15 482 616 239 935 262 101 647 274 ...\n# ..$ wt2: num [1:14647] 1 15 482 616 239 935 262 101 647 274 ...\n# ..$ ko1: num [1:14647] 0 43 491 783 323 ...\n# ..$ ko2: num [1:14647] 0 21 280 464 90 713 232 64 543 290 ...\n# $ rna:'data.frame':   57169 obs. of  4 variables:\n#   ..$ wt1: num [1:57169] 6 1 2 0 0 2 5 7 0 0 ...\n# ..$ wt2: num [1:57169] 6 1 2 0 0 2 5 7 0 0 ...\n# ..$ ko1: num [1:57169] 6 0 1 0 0 1 6 9 0 0 ...\n# ..$ ko2: num [1:57169] 3 1 0 0 0 1 7 1 0 0 ...",
    "crumbs": [
      "Global gene expression analysis"
    ]
  },
  {
    "objectID": "Gene-expression-analysis.html#extract-normalized-expression",
    "href": "Gene-expression-analysis.html#extract-normalized-expression",
    "title": "Global gene expression analysis",
    "section": "Extract normalized expression",
    "text": "Extract normalized expression\nThe function get_normalized_reads calculates RNA, RPF, and translation efficiency (TE). The normalized values for RNA and RPF are standardized using TPM values, while translation efficiency (TE) is defined as:\n\\[\n\\text{TE (translation efficiency)} = \\frac{\\text{RPF}_tpm}{\\text{RNA}_tpm} \\tag{1}\n\\]\n\nnorm &lt;- get_normalized_reads(object = obj,\n                             type = c(\"rna\", \"ribo\", \"te\"))\n\n# check\nstr(norm)\n# List of 3\n# $ tpm.rna :'data.frame':  57169 obs. of  5 variables:\n#   ..$ wt1      : num [1:57169] 0.2551 0.0344 0.0154 0 0 ...\n# ..$ wt2      : num [1:57169] 0.2551 0.0344 0.0154 0 0 ...\n# ..$ ko1      : num [1:57169] 0.22734 0 0.00686 0 0 ...\n# ..$ ko2      : num [1:57169] 0.1312 0.0354 0 0 0 ...\n# ..$ gene_name: chr [1:57169] \"A1BG\" \"A1BG-AS1\" \"A1CF\" \"A2M\" ...\n# $ tpm.ribo:'data.frame':  14647 obs. of  5 variables:\n#   ..$ wt1      : num [1:14647] 0.0257 0.6961 50.8271 81.9381 17.6403 ...\n# ..$ wt2      : num [1:14647] 0.0257 0.6961 50.8271 81.9381 17.6403 ...\n# ..$ ko1      : num [1:14647] 0 1.44 37.4 75.23 17.22 ...\n# ..$ ko2      : num [1:14647] 0 1.24 37.61 78.61 8.46 ...\n# ..$ gene_name: chr [1:14647] \"A1CF\" \"A4GALT\" \"AAAS\" \"AACS\" ...\n# $ te      :'data.frame':  14647 obs. of  5 variables:\n#   ..$ wt1      : num [1:14647] 1.672 0 0.394 8.632 19.743 ...\n# ..$ wt2      : num [1:14647] 1.672 0 0.394 8.632 19.743 ...\n# ..$ ko1      : num [1:14647] 0 9.397 0.427 9.333 22.229 ...\n# ..$ ko2      : num [1:14647] NaN 0 0.554 9.186 27.907 ...\n# ..$ gene_name: chr [1:14647] \"A1CF\" \"A2ML1\" \"A4GALT\" \"AAAS\" ...",
    "crumbs": [
      "Global gene expression analysis"
    ]
  },
  {
    "objectID": "Gene-expression-analysis.html#differential-analysis",
    "href": "Gene-expression-analysis.html#differential-analysis",
    "title": "Global gene expression analysis",
    "section": "Differential analysis",
    "text": "Differential analysis\nThe gene_differential_analysis function uses DESeq2 to perform differential expression analysis separately on RNA or RPF data and returns the corresponding results:\n\ndiff.rna &lt;- gene_differential_analysis(obj, \n                                       type = \"rna\",\n                                       control_samples = c(\"wt1\",\"wt2\"),\n                                       treat_samples = c(\"ko1\",\"ko2\"))\n\n# check\nhead(diff.rna)\n#            baseMean log2FoldChange    lfcSE       stat    pvalue padj gene_name   type\n# A1BG      5.0888259     -0.2345798 1.248392 -0.1879055 0.8509508   NA      A1BG nonSig\n# A1BG-AS1  0.7829185     -0.6432696 3.213131 -0.2002002 0.8413240   NA  A1BG-AS1 nonSig\n# A1CF      1.1471459     -1.8219647 2.754492 -0.6614522 0.5083223   NA      A1CF nonSig\n# A2ML1     1.4697527     -0.7623221 2.236789 -0.3408109 0.7332459   NA     A2ML1 nonSig\n# A2ML1-AS1 5.9189416      0.6372937 1.177298  0.5413188 0.5882879   NA A2ML1-AS1 nonSig\n# A2ML1-AS2 5.5834917     -0.4017920 1.313643 -0.3058609 0.7597106   NA A2ML1-AS2 nonSig\n\ndiff.ribo &lt;- gene_differential_analysis(obj, \n                                        type = \"ribo\",\n                                        control_samples = c(\"wt1\",\"wt2\"),\n                                        treat_samples = c(\"ko1\",\"ko2\"))\n\n# check\nhead(diff.ribo)\n#           baseMean log2FoldChange     lfcSE       stat      pvalue      padj gene_name   type\n# A1CF     0.5143687     -2.5281257 4.5894024 -0.5508616 0.581728523        NA      A1CF nonSig\n# A4GALT  22.3216385      0.9254935 0.6865945  1.3479477 0.177675211 0.6322686    A4GALT nonSig\n# AAAS   427.6743989     -0.4642721 0.1766959 -2.6275206 0.008600965 0.1247037      AAAS nonSig\n# AACS   609.1352834     -0.1178472 0.1558609 -0.7561051 0.449586198 0.8723837      AACS nonSig\n# AADAT  210.8025653     -0.4692803 0.3222716 -1.4561639 0.145347309 0.5805468     AADAT nonSig\n# AAGAB  921.2909124     -0.1293514 0.1392711 -0.9287745 0.353005973 0.8165758     AAGAB nonSig\n\nVocalno plot for differential results:\n\nvocalno_plot(diff_data = diff.rna)\n\n\n\n\n\n\nvocalno_plot(diff_data = diff.ribo)",
    "crumbs": [
      "Global gene expression analysis"
    ]
  },
  {
    "objectID": "Gene-expression-analysis.html#translation-efficiency-differential-analysis",
    "href": "Gene-expression-analysis.html#translation-efficiency-differential-analysis",
    "title": "Global gene expression analysis",
    "section": "Translation efficiency differential analysis",
    "text": "Translation efficiency differential analysis\nThe TE_differential_analysis function performs a differential analysis of translation efficiency. Users can select either RiboReX or Xtail as their preferred tool for this analysis:\n\n# use riborex for te analysis\nte.rex &lt;- TE_differential_analysis(object = obj,\n                                   pkg = \"riborex\",\n                                   control_samples = c(\"wt1\",\"wt2\"),\n                                   treat_samples = c(\"ko1\",\"ko2\"))\n\n# check\nstr(te.rex)\n# List of 2\n# $ deg_raw :Formal class 'DESeqResults' [package \"DESeq2\"] with 7 slots\n# .. ..@ priorInfo      : list()\n# .. ..@ rownames       : chr [1:13204] \"A4GALT\" \"AAAS\" \"AACS\" \"AADAT\" ...\n# .. ..@ nrows          : int 13204\n# .. ..@ elementType    : chr \"ANY\"\n# .. ..@ elementMetadata:Formal class 'DFrame' [package \"S4Vectors\"] with 6 slots\n# .. .. .. ..@ rownames       : NULL\n# .. .. .. ..@ nrows          : int 6\n# .. .. .. ..@ elementType    : chr \"ANY\"\n# .. .. .. ..@ elementMetadata: NULL\n# .. .. .. ..@ metadata       : list()\n# .. .. .. ..@ listData       :List of 2\n# .. .. .. .. ..$ type       : chr [1:6] \"intermediate\" \"results\" \"results\" \"results\" ...\n# .. .. .. .. ..$ description: chr [1:6] \"mean of normalized counts for all samples\" \"log2 fold change (MLE): EXTRA1 treated vs control\" \"standard error: EXTRA1 treated vs control\" \"Wald statistic: EXTRA1 treated vs control\" ...\n# .. ..@ metadata       :List of 6\n# .. .. ..$ filterThreshold: Named num 93\n# .. .. .. ..- attr(*, \"names\")= chr \"40.71429%\"\n# .. .. ..$ filterTheta    : num 0.407\n# .. .. ..$ filterNumRej   :'data.frame':   50 obs. of  2 variables:\n#   .. .. .. ..$ theta : num [1:50] 0 0.0194 0.0388 0.0582 0.0776 ...\n# .. .. .. ..$ numRej: num [1:50] 112 116 116 117 118 118 118 120 121 124 ...\n# .. .. ..$ lo.fit         :List of 2\n# .. .. .. ..$ x: num [1:50] 0 0.0194 0.0388 0.0582 0.0776 ...\n# .. .. .. ..$ y: num [1:50] 114 115 116 117 117 ...\n# .. .. ..$ alpha          : num 0.1\n# .. .. ..$ lfcThreshold   : num 0\n# .. ..@ listData       :List of 6\n# .. .. ..$ baseMean      : num [1:13204] 56.7 246.1 341.4 143.7 568 ...\n# .. .. ..$ log2FoldChange: num [1:13204] 0.0106 -0.1939 0.0381 -0.1659 0.0415 ...\n# .. .. ..$ lfcSE         : num [1:13204] 0.578 0.285 0.241 0.54 0.208 ...\n# .. .. ..$ stat          : num [1:13204] 0.0183 -0.681 0.158 -0.3072 0.1996 ...\n# .. .. ..$ pvalue        : num [1:13204] 0.985 0.496 0.874 0.759 0.842 ...\n# .. .. ..$ padj          : num [1:13204] NA 0.915 0.983 0.968 0.98 ...\n# $ deg_anno:'data.frame':  13204 obs. of  8 variables:\n#   ..$ baseMean      : num [1:13204] 56.7 246.1 341.4 143.7 568 ...\n# ..$ log2FoldChange: num [1:13204] 0.0106 -0.1939 0.0381 -0.1659 0.0415 ...\n# ..$ lfcSE         : num [1:13204] 0.578 0.285 0.241 0.54 0.208 ...\n# ..$ stat          : num [1:13204] 0.0183 -0.681 0.158 -0.3072 0.1996 ...\n# ..$ pvalue        : num [1:13204] 0.985 0.496 0.874 0.759 0.842 ...\n# ..$ padj          : num [1:13204] NA 0.915 0.983 0.968 0.98 ...\n# ..$ gene_name     : chr [1:13204] \"A4GALT\" \"AAAS\" \"AACS\" \"AADAT\" ...\n# ..$ type          : chr [1:13204] \"nonSig\" \"nonSig\" \"nonSig\" \"nonSig\" ...\n\n\nvocalno_plot(diff_data = te.rex$deg_anno)\n\n\n\n\n\nXtail for differential analysis:\n\nte.xtail &lt;- TE_differential_analysis(object = obj,\n                                     pkg = \"xtail\",\n                                     control_samples = c(\"wt1\",\"wt2\"),\n                                     treat_samples = c(\"ko1\",\"ko2\"),\n                                     min_count = 4)\n# Calculating the library size factors\n# 1. Estimate the log2 fold change in mrna\n# converting counts to integer mode\n# 2. Estimate the log2 fold change in rpf\n# converting counts to integer mode\n# 3. Estimate the difference between two log2 fold changes\n# 4. Estimate the log2 ratio in first condition\n# converting counts to integer mode\n# 5. Estimate the log2 ratio in second condition\n# converting counts to integer mode\n# 6. Estimate the difference between two log2 ratios\n# Number of the log2FC and log2R used in determining the final p-value\n# log2FC: 7530\n# log2R: 5484\n\n\n# check\nstr(te.xtail)\n# List of 2\n# $ deg_raw :Formal class 'xtail' [package \"\"] with 4 slots\n# .. ..@ listData       :List of 5\n# .. .. ..$ resultsTable        :Formal class 'DFrame' [package \"S4Vectors\"] with 6 slots\n# .. .. .. .. ..@ rownames       : chr [1:13014] \"A4GALT\" \"AAAS\" \"AACS\" \"AADAT\" ...\n# .. .. .. .. ..@ nrows          : int 13014\n# .. .. .. .. ..@ elementType    : chr \"ANY\"\n# .. .. .. .. ..@ elementMetadata: NULL\n# .. .. .. .. ..@ metadata       : list()\n# .. .. .. .. ..@ listData       :List of 11\n# .. .. .. .. .. ..$ mRNA_log2FC    : num [1:13014] 0.907 -0.283 -0.172 -0.32 -0.189 ...\n# .. .. .. .. .. ..$ RPF_log2FC     : num [1:13014] 0.908 -0.481 -0.134 -0.487 -0.145 ...\n# .. .. .. .. .. ..$ log2FC_TE_v1   : num [1:13014] 0.00488 -0.19712 0.03861 -0.16493 0.04371 ...\n# .. .. .. .. .. ..$ pvalue_v1      : num [1:13014] 0.938 0.41 0.861 0.632 0.813 ...\n# .. .. .. .. .. ..$ control_log2TE : num [1:13014] -2.485 1.119 1.128 0.458 0.722 ...\n# .. .. .. .. .. ..$ treated_log2TE : num [1:13014] -2.484 0.921 1.166 0.291 0.765 ...\n# .. .. .. .. .. ..$ log2FC_TE_v2   : num [1:13014] 0.0106 -0.1984 0.0378 -0.167 0.0431 ...\n# .. .. .. .. .. ..$ pvalue_v2      : num [1:13014] 0.985 0.309 0.823 0.618 0.773 ...\n# .. .. .. .. .. ..$ log2FC_TE_final: num [1:13014] 0.0106 -0.1971 0.0386 -0.1649 0.0437 ...\n# .. .. .. .. .. ..$ pvalue_final   : num [1:13014] 0.985 0.41 0.861 0.632 0.813 ...\n# .. .. .. .. .. ..$ pvalue.adjust  : num [1:13014] 1 1 1 1 1 ...\n# .. .. ..$ log2FC_determine_num: int 7530\n# .. .. ..$ log2R_determine_num : int 5484\n# .. .. ..$ condition1          : chr \"control\"\n# .. .. ..$ condition2          : chr \"treated\"\n# .. ..@ elementType    : chr \"ANY\"\n# .. ..@ elementMetadata: NULL\n# .. ..@ metadata       : list()\n# $ deg_anno:'data.frame':  13014 obs. of  10 variables:\n#   ..$ log2FC_TE_v1   : num [1:13014] 0.00488 -0.19712 0.03861 -0.16493 0.04371 ...\n# ..$ pvalue_v1      : num [1:13014] 0.938 0.41 0.861 0.632 0.813 ...\n# ..$ treated_log2TE : num [1:13014] -2.484 0.921 1.166 0.291 0.765 ...\n# ..$ log2FC_TE_v2   : num [1:13014] 0.0106 -0.1984 0.0378 -0.167 0.0431 ...\n# ..$ pvalue_v2      : num [1:13014] 0.985 0.309 0.823 0.618 0.773 ...\n# ..$ log2FC_TE_final: num [1:13014] 0.0106 -0.1971 0.0386 -0.1649 0.0437 ...\n# ..$ pvalue_final   : num [1:13014] 0.985 0.41 0.861 0.632 0.813 ...\n# ..$ pvalue.adjust  : num [1:13014] 1 1 1 1 1 ...\n# ..$ type           : chr [1:13014] \"nonSig\" \"nonSig\" \"nonSig\" \"nonSig\" ...\n# ..$ gene_name      : chr [1:13014] \"A4GALT\" \"AAAS\" \"AACS\" \"AADAT\" ...\n\n\nGitHub - smithlabcode/riborex: Riborex: Fast and flexible identification of differential translation from Ribo-seq data\nGitHub - xryanglab/xtail: Genome-wide assessment of differential translations with ribosome profiling data",
    "crumbs": [
      "Global gene expression analysis"
    ]
  },
  {
    "objectID": "Peptide-motif-plot.html",
    "href": "Peptide-motif-plot.html",
    "title": "Peptide motif plot",
    "section": "",
    "text": "Intro\nThis section focuses on visualizing peptide motifs derived from ribosome profiling (Ribo-seq) analyses. During translation, the ribosome orchestrates protein synthesis by cycling through three key active sites: the E (exit), P (peptidyl), and A (aminoacyl) sites. Each of these sites plays a critical role in decoding mRNA and elongating the nascent peptide chain. The A site is responsible for decoding the mRNA codon by matching it with the correct aminoacyl-tRNA; the P site holds the growing peptide chain and participates in peptide bond formation; and the E site facilitates the exit of deacylated tRNA.\nThe time a ribosome spends decoding a codon—often referred to as dwell time—can vary depending on the sequence context around these EPA sites. This variability can lead to ribosome stalling, particularly when rare codons, nascent peptide-induced structural constraints, or regulatory elements interfere with efficient translation. For instance, negatively charged or bulky amino acids at the A site may delay tRNA accommodation and peptide bond formation, thereby increasing the decoding time. Similarly, specific dipeptide or tripeptide motifs spanning the P and A sites can hinder peptide elongation due to steric or electrostatic interactions.\nRibosome profiling (Ribo-seq) enables high-resolution mapping of ribosome positions on mRNAs, providing a powerful tool to quantify dwell times at codon-level resolution. By mapping footprint reads centered at specific positions (e.g., aligning the A site), researchers can aggregate sequence motifs that correspond to prolonged ribosome occupancy, revealing patterns of enrichment or depletion in amino acid usage.\nTo visualize such motifs, statistical tools like pLogo can be employed. Unlike traditional sequence logos that scale residues by frequency, pLogo represents amino acid enrichment or depletion as a function of statistical significance against a defined background. This enables a more rigorous interpretation of sequence features that tend to promote or hinder translation at the ribosome’s active sites. Moreover, pLogo allows for motif conditioning by fixing residues at specific positions (e.g., a conserved P-site proline), thus uncovering context-dependent translation dynamics.\nkpLogo is an another powerful computational tool designed to visualize position-specific k-mer enrichment patterns in biological sequences such as DNA, RNA, or protein sequences. It builds upon the concept of traditional sequence logos by enabling the detection and display of statistically significant k-mers — not just single residues — at individual motif positions.\nUnlike conventional logo tools that scale individual residue heights based on frequency or information content, kpLogo tests all possible k-length substrings (k-mers) at each sequence position and ranks them according to p-values derived from appropriate statistical tests (e.g., binomial, rank-sum, etc.). This results in highly informative visualizations that reveal both overrepresented and underrepresented k-mers across sequence positions.\nIn summary, decoding time at the EPA sites is a nuanced reflection of codon usage, tRNA availability, peptide chemistry, and regulatory sequence elements. Motif visualization strategies such as pLogo help unravel the sequence determinants influencing ribosome kinetics in a biologically meaningful and statistically interpretable way.",
    "crumbs": [
      "Peptide motif plot"
    ]
  },
  {
    "objectID": "Peptide-motif-plot.html#extract-overrepresented-motifs",
    "href": "Peptide-motif-plot.html#extract-overrepresented-motifs",
    "title": "Peptide motif plot",
    "section": "Extract Overrepresented motifs",
    "text": "Extract Overrepresented motifs\nPreviously, we observed that in the absence of eIF5A, many tripeptide motifs showed increased abundance. Visualizing these motifs as sequence logos can help us identify which amino acids tend to be enriched at the ribosomal E, P, and A sites, potentially reflecting altered decoding or elongation dynamics.\nWe used the logo_plot() function to visualize enriched tripeptide motifs. Based on the article’s methodology, we selected the top 29 upregulated motifs (based on fold change) in each replicate as the foreground sequences. Motifs with less than 1.5-fold change were used as the background set:\n\n# Calculate fold changes\npdf$ratio1 &lt;- pdf$`sgeIF5A-rep1` / pdf$`wt-rep1`\npdf$ratio2 &lt;- pdf$`sgeIF5A-rep2` / pdf$`wt-rep2`\n\n# Select top 29 enriched motifs for each replicate\nenrich1 &lt;- subset(pdf, ratio1 &gt;= 1.5) %&gt;%\n  dplyr::slice_max(order_by = ratio1, n = 29)\n\nenrich1.bg &lt;- subset(pdf, ratio1 &lt; 1.5)\n\nenrich2 &lt;- subset(pdf, ratio2 &gt;= 1.5) %&gt;%\n  dplyr::slice_max(order_by = ratio2, n = 29)\n\nenrich2.bg &lt;- subset(pdf, ratio2 &lt; 1.5)",
    "crumbs": [
      "Peptide motif plot"
    ]
  },
  {
    "objectID": "Peptide-motif-plot.html#motif-logo-visualization",
    "href": "Peptide-motif-plot.html#motif-logo-visualization",
    "title": "Peptide motif plot",
    "section": "Motif logo visualization",
    "text": "Motif logo visualization\nDefault plot:\n\nlogo_plot(foreground_seqs = enrich1$pep_seq,\n          method = \"bits\") +\n  logo_plot(foreground_seqs = enrich2$pep_seq,\n            method = \"bits\")\n\n\n\n\n\nSet method = \"prob\":\n\nlogo_plot(foreground_seqs = enrich1$pep_seq,\n          method = \"prob\")+\n  logo_plot(foreground_seqs = enrich2$pep_seq,\n            method = \"prob\")\n\n\n\n\n\nWe further used the EDLogo method from the logolas R package to visualize motif enrichment:\n\nlogo_plot(foreground_seqs = enrich1$pep_seq,\n          method = \"EDLogo\")\n\nlogo_plot(foreground_seqs = enrich2$pep_seq,\n            method = \"EDLogo\")\n\n\n\n\n\nVisualize frequency enrichment by incorporating background sequences. Residue height represents the log₂ enrichment ratio of the amino acid frequency at a given position in the foreground relative to the background.\nTo visualize frequency enrichment using background sequences, each amino acid at a given position is evaluated for its level of enrichment or depletion in the foreground set compared to the background.\nThe height of each amino acid character represents the log₂ enrichment ratio between its frequency in the foreground and background sequences:\n\\[\n\\text{Enrichment ratio for residue } X_i = \\log_2 \\left( \\frac{f_{\\text{foreground}}(X_i)}{f_{\\text{background}}(X_i)} \\right) \\tag{1}\n\\]\n\n\nX refers to a specific amino acid (from the 20 standard amino acids).\n\ni indicates a specific position in the aligned sequence.\n\nIf the ratio is greater than 1 (log₂ &gt; 0), the residue is statistically overrepresented and appears taller above the x-axis.\nIf the ratio is less than 1 (log₂ &lt; 0), the residue is underrepresented and appears below the x-axis.\n\nlogo_plot(foreground_seqs = enrich1$pep_seq,\n          background_seqs = enrich1.bg$pep_seq,\n          method = \"enrich\") +\n  logo_plot(foreground_seqs = enrich2$pep_seq,\n            background_seqs = enrich2.bg$pep_seq,\n            method = \"enrich\")\n\n\n\n\n\nIf background sequences are not available, you can generate them by using the generate_kmers function to extract all possible amino acid k-mers of a specified length from the entire proteome. Here we load CDS fasta file and translate it into amino acid:\n\n# generate kmers\nkmer &lt;- generate_kmers(fa_file = \"sac_cds.fa\",\n                       fa_type = \"dna\", \n                       kmer_length = 3,\n                       translate = T)\n\n# plot\nlogo_plot(foreground_seqs = enrich1$pep_seq,\n          background_seqs = kmer,\n          method = \"enrich\") +\n  logo_plot(foreground_seqs = enrich2$pep_seq,\n            background_seqs = kmer,\n            method = \"enrich\")",
    "crumbs": [
      "Peptide motif plot"
    ]
  },
  {
    "objectID": "Gene-expression-analysis.html#correlation-plot",
    "href": "Gene-expression-analysis.html#correlation-plot",
    "title": "Global gene expression analysis",
    "section": "Correlation plot",
    "text": "Correlation plot\nPlot the correlation for the replicates based on counts data:\n\nrna &lt;- obj@counts$rna\n\ncor_plot(data = rna,x = \"ko1\",y = \"ko2\")",
    "crumbs": [
      "Global gene expression analysis"
    ]
  },
  {
    "objectID": "Peptide-motif-plot.html#statistical-significance-visualization",
    "href": "Peptide-motif-plot.html#statistical-significance-visualization",
    "title": "Peptide motif plot",
    "section": "Statistical significance visualization",
    "text": "Statistical significance visualization\nProbability logo is first proposed and implemented in pLogo for unweighted sequences, especially protein sequences. In probability logos, residues are scaled relative to the statistical significance (-log10(P value)) of each residue at each position. Enriched residues stack on the top, whereas depleted residues stack on the bottom. Significant positions have coordinates colored in red.\nThe official pLogo tool is only available online and imposes size limitations on uploaded background sequences. To address this limitation and enable greater flexibility, we implemented an R-based version of the pLogo algorithm based on its original principles.\nOur custom function, plogo_plot, allows users to perform motif enrichment analysis using their own foreground and background sequences and to generate corresponding motif visualizations.\nThe figure below is adapted from Figure 1 of the pLogo publication and illustrates specific sequence motifs from human and mouse data. To reproduce this figure, we downloaded the sequence datasets provided in the article’s supplementary materials and reanalyzed them using our own implementation.\n\n\n\n\nGet background k-mers\nTo build background sequence datasets, we first downloaded the complete human and mouse proteomes from the Ensembl database. Using the custom R function generate_kmers, we generated all possible 15-mer peptide subsequences using a 1-residue sliding window.\nWe select the longest amino acid sequence for analysis to reduce computation time:\n\n# Download human and mouse protein sequences from Ensembl\n# wget https://ftp.ensembl.org/pub/release-113/fasta/homo_sapiens/pep/Homo_sapiens.GRCh38.pep.all.fa.gz\n# wget https://ftp.ensembl.org/pub/release-113/fasta/mus_musculus/pep/Mus_musculus.GRCm39.pep.all.fa.gz\n\n# select longest cds for analysis\npep.list &lt;- lapply(c(\"Homo_sapiens.GRCh38.pep.all.fa.gz\",\n                     \"Mus_musculus.GRCm39.pep.all.fa.gz\"), \n                   function(x){\n                     hm.pep &lt;- Biostrings::readAAStringSet(x)\n                     names(hm.pep) &lt;- sapply(strsplit(names(hm.pep),split = \" \"),\"[\",4)\n                     \n                     leninfo &lt;- data.frame(id = names(hm.pep),\n                                           len = Biostrings::width(hm.pep)) %&gt;% \n                       dplyr::slice_max(order_by = len,n = 1,by = id)\n                     \n                     hm.pep &lt;- hm.pep[leninfo$id]\n                   })\n\nGenerate background sequences encompassing the complete set of k-mer combinations:\n\n# Generate human background 15-mers\nhm.kmers &lt;- generate_kmers(fa_obj = pep.list[[1]],\n                           fa_type = \"aa\",\n                           kmer_length = 15)\n\n\n# check\nhead(hm.kmers)\n# [1] \"XTDKLIFGKGTRVTV\" \"TDKLIFGKGTRVTVE\" \"XIQGAQKLVFGQGTR\" \"IQGAQKLVFGQGTRL\" \"QGAQKLVFGQGTRLT\"\n# [6] \"GAQKLVFGQGTRLTI\"\n\n# Generate mouse background 15-mers\nmm.kmers &lt;- generate_kmers(fa_obj = pep.list[[2]],\n                           fa_type = \"aa\",\n                           kmer_length = 15)\n\n# check\nhead(mm.kmers)\n# [1] \"MRCLAEFLRLLVLWI\" \"RCLAEFLRLLVLWIP\" \"CLAEFLRLLVLWIPA\" \"LAEFLRLLVLWIPAT\" \"AEFLRLLVLWIPATG\"\n# [6] \"EFLRLLVLWIPATGD\"\n\nEnrichment plot\nFirst, we load the motif sequences of interest. With the sequences prepared, we can now perform statistical enrichment analysis and visualization using the plogo_plot function:\n\nlibrary(patchwork)\n\n# Load sequence data\nlogo &lt;- read.csv(\"logo.csv\")\n\n# Plot human Src phosphorylation site motif using merged enrichment and depletion\nplogo_plot(foreground_seqs = logo$X312.Human.Src.Phosphorylation.Sites[1:312],\n           background_seqs = hm.kmers)\n\n\n\n\n\nTo separate enriched and depleted residues into two distinct panels for clearer interpretation:\n\n# Display enriched and depleted residues in separate panels\nplogo_plot(foreground_seqs = logo$X312.Human.Src.Phosphorylation.Sites[1:312],\n           background_seqs = hm.kmers,\n           type = \"sep\")\n\n\n\n\n\nTo visualize the motif specific to mouse S-nitrosylation sites:\n\n# Visualize enrichment/depletion in mouse S-nitrosylation data\nplogo_plot(foreground_seqs = logo$X897.Mouse.S.Nitrosylation.Sites,\n           background_seqs = mm.kmers,\n           type = \"sep\")\n\n\n\n\n\nReturn enrichment matrix\nBy setting return_data = TRUE in the plogo_plot function, users can extract the underlying log-odds enrichment matrix instead of generating the default plot. This matrix contains log-scaled enrichment or depletion scores for each amino acid at each sequence position, allowing users to perform downstream customized visualizations or statistical analyses:\n\nlogo.mat &lt;- plogo_plot(foreground_seqs = logo$X897.Mouse.S.Nitrosylation.Sites,\n           background_seqs = mm.kmers,\n           type = \"sep\",\n           return_data = T)\n\n# check\nhead(logo.mat[1:5,1:5])\n#         [,1]        [,2]       [,3]       [,4]         [,5]\n# A  3.0019778  0.45066123  1.2935104  0.3054578  0.675915762\n# R  1.6779435  0.89863638 -0.1011318 -0.6101936 -0.004278364\n# N  0.2781619 -0.57423131  0.2729732  1.0391953  0.040842459\n# D  0.6988828  0.05319199  1.7465229  1.3097744  0.573454875\n# C -1.6254121 -2.24066000 -2.2491104 -2.2449261 -1.634282743",
    "crumbs": [
      "Peptide motif plot"
    ]
  },
  {
    "objectID": "Peptide-motif-plot.html#theoretical-principle-of-plogo",
    "href": "Peptide-motif-plot.html#theoretical-principle-of-plogo",
    "title": "Peptide motif plot",
    "section": "Theoretical Principle of pLogo",
    "text": "Theoretical Principle of pLogo\npLogo (probability logo) is a motif visualization tool that scales residue characters not by raw frequency but by the statistical significance of their over- or underrepresentation compared to a defined background model, typically using binomial probability.\nStatistical Model\nFor a given residue r at position i in the foreground dataset (e.g., aligned modification sites), pLogo compares its observed count K with its expected frequency p, derived from the background dataset. Assuming N sequences in the foreground, the probability model is:\n\\[\nK \\sim \\text{Binomial}(N, p) \\tag{2}\n\\]\nWhere:\n\nK: observed count of residue r at position i in the foreground\nN: total number of foreground sequences\np: background frequency of residue r at that position\nResidue Significance and Height Calculation\nThe log-odds score for residue r at position i, which determines its vertical height in the pLogo visualization, is calculated as:\n\\[\n\\text{Height}(r_i) \\propto \\log_{10} \\left( \\frac{\\Pr(k \\ge K \\mid N, p)}{\\Pr(k \\le K \\mid N, p)} \\right) \\tag{3}\n\\]\nThis score provides a continuous probability-based metric reflecting both enrichment and depletion. It approximates:\n\\[\nh(r, i) =\n\\begin{cases}\n+\\log_{10} \\left( \\frac{1}{\\Pr(k \\ge K \\mid N, p)} \\right), & K &gt; Np \\\\\n-\\log_{10} \\left( \\frac{1}{\\Pr(k \\le K \\mid N, p)} \\right), & K &lt; Np \\\\\n0, & K \\approx Np\n\\end{cases} \\tag{4}\n\\]\nHere, residues with higher scores are displayed above the x-axis (significantly enriched), while those with negative scores appear below (significantly depleted).\nBonferroni Correction and Significance Threshold\nTo correct for multiple hypothesis testing across all residue-position pairs, a Bonferroni-adjusted threshold is applied. The number of independent tests is approximately:\n\\[\nm = \\sum_{i \\in R} C_i \\tag{5}\n\\]\nWhere:\n\nR: set of non-fixed positions\nC_i: number of unique residues observed at position i in the background\n\nThe corrected alpha level is:\n\\[\n\\alpha' = \\frac{0.05}{m} \\tag{6}\n\\]\nThe threshold for visualizing statistical significance on the pLogo is then:\n\\[\n\\text{Threshold} = \\pm \\log_{10} \\left( \\frac{\\alpha'}{1 - \\alpha'} \\right) \\tag{7}\n\\]\nReference\nThis approach was introduced in:\n\nO’Shea JP, Chou MF, Quader SA, et al. pLogo: a probabilistic approach to visualizing sequence motifs. Nature Methods (2013), 10(12):1211–1212.",
    "crumbs": [
      "Peptide motif plot"
    ]
  },
  {
    "objectID": "Codon-occupancy.html#codon-occupancy-barplot",
    "href": "Codon-occupancy.html#codon-occupancy-barplot",
    "title": "Codon occupancy",
    "section": "Codon occupancy barplot",
    "text": "Codon occupancy barplot\nCodon occupancy analysis was performed by using RiboMiner, and observed a marked increase in occupancy for codons encoding the amino acids P, D, L, I, and M (Proline, Aspartic acid, Leucine, Isoleucine, and Methionine), suggesting potential ribosome pausing or elongation slowdown at these sites:\n\n\n\n\nBefore performing codon occupancy analysis using the codon_occupancy_plot() function from the riboTransVis package, it is necessary to extract the coding sequences (CDS) for each gene. This ensures that the function can accurately map ribosome footprints to codons.\nThe get_transcript_sequence() function can be used to extract CDS sequences from genome and GTF files as shown below:\n\nget_transcript_sequence(genome_file = \"../../index-data/Saccharomyces_cerevisiae.R64-1-1.dna.toplevel.fa\",\n                        gtf_file = \"../../index-data/Saccharomyces_cerevisiae.R64-1-1.112.gtf\",\n                        feature = \"CDS\",\n                        output_file = \"sac_cds.fa\")\n\nOnce the CDS sequences have been obtained, codon occupancy can be calculated and visualized using the codon_occupancy_plot() function from the riboTransVis package:\n\ncodon_occupancy_plot(object = obj0, \n                     cds_fa = \"./sac_cds.fa\",\n                     do_offset_correct = T)\n\n\n\ndo_offset_correct = TRUE enables P-site offset correction to improve positional accuracy.\n\n\n\n\n\nSetting the argument plot_abbreviation = TRUE in the codon_occupancy_plot() function will display amino acid abbreviations (single-letter codes) on the x-axis instead of individual codon sequences. This can help simplify the visualization by grouping codons by the amino acid they encode:\n\ncodon_occupancy_plot(object = obj0, \n                     cds_fa = \"./sac_cds.fa\",\n                     do_offset_correct = T,\n                     plot_abbreviation = T)\n\n\n\n\n\nAlternatively, instead of generating the default plot, you can set return_data = TRUE in the codon_occupancy_plot() function to extract the underlying codon occupancy data for custom plotting. Here, we use the returned data to calculate the log₂ enrichment of codon occupancy between sample groups (e.g., sgeIF5A vs. wt) at the amino acid level:\n\nccdf &lt;- codon_occupancy_plot(object = obj0,\n                             cds_fa = \"./sac_cds.fa\",\n                             do_offset_correct = T,\n                             return_data = T)\n\nhead(ccdf)\n# # A tibble: 6 × 12\n#     sample       sample_group codon_seq   occup  freq reloccup AminoAcid  Abbreviation3 Abbreviation1 codon   abbrev  group  \n#     &lt;chr&gt;        &lt;chr&gt;        &lt;chr&gt;       &lt;dbl&gt; &lt;int&gt;    &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;         &lt;chr&gt;         &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;  \n# 1 sgeIF5A-rep1 sgeIF5A-rep1 AAA       112028. 37155     3.02 Lysine     Lys           K             AAA | K Lys | K sgeIF5A\n# 2 sgeIF5A-rep1 sgeIF5A-rep1 AAC       123727. 31161     3.97 Asparagine Asn           N             AAC | N Asn | N sgeIF5A\n# 3 sgeIF5A-rep1 sgeIF5A-rep1 AAG        87373. 35449     2.46 Lysine     Lys           K             AAG | K Lys | K sgeIF5A\n# 4 sgeIF5A-rep1 sgeIF5A-rep1 AAT       176460. 40086     4.40 Asparagine Asn           N             AAT | N Asn | N sgeIF5A\n# 5 sgeIF5A-rep1 sgeIF5A-rep1 ACA        88907. 21447     4.15 Threonine  Thr           T             ACA | T Thr | T sgeIF5A\n# 6 sgeIF5A-rep1 sgeIF5A-rep1 ACC        57954. 17177     3.37 Threonine  Thr           T             ACC | T Thr | T sgeIF5A\n\nCustom visualization:\n\n# plot\nlibrary(ggplot2)\nccdf$group &lt;- sapply(strsplit(ccdf$sample,split = \"\\\\-\"),\"[\",1)\n\n# log2 ratio\nccdf_aa &lt;- ccdf %&gt;%\n  dplyr::group_by(group,abbrev,AminoAcid) %&gt;%\n  dplyr::summarise(reloccup = mean(reloccup)) %&gt;%\n  tidyr::pivot_wider(names_from = group,values_from = reloccup) %&gt;%\n  dplyr::mutate(ratio = log2(sgeIF5A/wt)) %&gt;%\n  dplyr::arrange(ratio)\n\n# order\nccdf_aa$abbrev &lt;- factor(ccdf_aa$abbrev,levels = ccdf_aa$abbrev)\n\nggplot(ccdf_aa) +\n  geom_col(aes(x = abbrev,y = ratio,fill = AminoAcid),\n           position = position_dodge2(),width = 0.6) +\n  # theme_bw() +\n  theme(axis.text.x = element_text(angle = 90,vjust = 0.5),\n        panel.grid = element_blank(),\n        strip.text = element_text(face = \"bold\"),\n        axis.text = element_text(colour = \"black\")) +\n  xlab(\"Codons (Amino acids)\") +\n  ylab(\"Codon occupancy\")",
    "crumbs": [
      "Codon occupancy"
    ]
  },
  {
    "objectID": "Codon-occupancy.html#codon-occupancy-scatter-plot",
    "href": "Codon-occupancy.html#codon-occupancy-scatter-plot",
    "title": "Codon occupancy",
    "section": "Codon occupancy scatter plot",
    "text": "Codon occupancy scatter plot\nIn addition to using bar plots to visualize codon occupancy, scatter plots can be employed to examine differences in codon usage between samples:\n\nccdf &lt;- codon_occupancy_plot(object = obj0,\n                             cds_fa = \"./sac_cds.fa\",\n                             do_offset_correct = T,\n                             return_data = T)\n\n# check samples\nunique(ccdf$sample)\n# [1] \"sgeIF5A-rep1\" \"sgeIF5A-rep2\" \"wt-rep1\"      \"wt-rep2\"\n\ncodon_scatter_plot(codon_data = ccdf,\n                   x = \"wt-rep1\", y = \"sgeIF5A-rep1\",\n                   type = \"codon\")\n\n\n\n\n\nHighlight specific codons of interest(Pro anmino acid):\n\ncodon_scatter_plot(codon_data = ccdf,\n                   x = \"wt-rep1\", y = \"sgeIF5A-rep1\",\n                   type = \"codon\",\n                   codon_labels = c(\"CCA\",\"CCG\",\"CCC\",\"CCT\"))\n\n\n\n\n\nVisualize at the amino acid level:\n\ncodon_scatter_plot(codon_data = ccdf,\n                   x = \"wt-rep1\", y = \"sgeIF5A-rep1\",\n                   type = \"amino\")",
    "crumbs": [
      "Codon occupancy"
    ]
  },
  {
    "objectID": "Enzyme-digestion-site.html",
    "href": "Enzyme-digestion-site.html",
    "title": "Enzyme digestion site",
    "section": "",
    "text": "Intro\nIn ribosome profiling (Ribo-seq), enzyme digestion is a critical step that generates the footprints (typically 26–34 nt) for ribosome-bound mRNA fragments. Different nucleases (e.g., RNase I, micrococcal nuclease, or RelE) may have distinct cleavage preferences, producing digestion products that carry sequence biases near the cleavage (digestion) site. Analyzing these sequence preferences helps understand the enzymatic sequence specificity, the bias introduced during library preparation, and enables optimization of experimental protocols.\nTo investigate the preferences of different nucleases at digestion sites, one commonly extracts sequences flanking either the 5′ or 3′ end of Ribo-seq reads, depending on the experiment design and the library preparation strategy. These site-flanking sequences can be analyzed via motif visualization tools to identify enriched or depleted nucleotides around digest ends.",
    "crumbs": [
      "Enzyme digestion site"
    ]
  },
  {
    "objectID": "Enzyme-digestion-site.html#cleavage-site-motif-analysis",
    "href": "Enzyme-digestion-site.html#cleavage-site-motif-analysis",
    "title": "Enzyme digestion site",
    "section": "Cleavage site motif analysis",
    "text": "Cleavage site motif analysis\nFirst, we need to prepare the transcript sequences for all genes:\n\nget_transcript_sequence(genome_file = \"../../index-data/Saccharomyces_cerevisiae.R64-1-1.dna.toplevel.fa\",\n                        gtf_file = \"../../index-data/Saccharomyces_cerevisiae.R64-1-1.112.gtf\",\n                        feature = \"exon\",\n                        extend = T,\n                        extend_upstream = 50,\n                        extend_downstream = 50,\n                        output_file = \"sac_trans.fa\")\n\nThe function digestion_site_plot is used to extract the nucleotide sequences surrounding the 5′ or 3′ ends of all reads, and to visualize motif enrichment around cleavage sites:\n\ndp &lt;- digestion_site_plot(object = obj0,\n                          transcript_fa = \"sac_trans.fa\",\n                          type = \"end5\")\n\nThe result returned is a list of ggplot objects:\n\n\n\n\nMotif plot:\n\ndo.call(cowplot::plot_grid,sapply(dp,\"[\",1))\n\n\n\n\n\nWe can also visualize the sequence context of cleavage sites corresponding to reads in different reading frames (frame 0, 1, 2):\n\ndp2 &lt;- digestion_site_plot(object = obj0,\n                           transcript_fa = \"sac_trans.fa\",\n                           type = \"end5\",\n                           show_frame = T)\n\nlibrary(patchwork)\n\ndo.call(cowplot::plot_grid, args = c(list(ncol = 1),sapply(dp2,\"[\",1))) +\n  do.call(cowplot::plot_grid, args = c(list(ncol = 1),sapply(dp2,\"[\",2))) +\n  do.call(cowplot::plot_grid, args = c(list(ncol = 1),sapply(dp2,\"[\",3)))\n\n\n\n\n\nTo visualize the motif surrounding the 3′ end of footprint reads using the bits method:\n\ndp3 &lt;- digestion_site_plot(object = obj0,\n                           transcript_fa = \"sac_trans.fa\",\n                           method = \"bits\",\n                           type = \"end3\")\n\n\ndo.call(cowplot::plot_grid,sapply(dp3,\"[\",1))\n\n\n\n\n\nThere is no obvious sequence preference at the cleavage sites of ribosome-protected fragments treated with RNase I. In contrast, the fragments treated with MNase show a clear sequence preference, particularly for A/U bases. The data is from “Single-cell Ribo-seq reveals cell cycle-dependent translational pausing”:\n\nget_transcript_sequence(genome_file = \"../../index-data/Homo_sapiens.GRCh38.dna.primary_assembly.fa\",\n                        gtf_file = \"../../index-data/Homo_sapiens.GRCh38.112.gtf\",\n                        feature = \"exon\",\n                        output_file = \"GRCh38_trans.fa\")\n\ndp5 &lt;- digestion_site_plot(object = obj,\n                          transcript_fa = \"GRCh38_trans.fa\",\n                          type = \"end5\")\n\ndp3 &lt;- digestion_site_plot(object = obj,\n                          transcript_fa = \"GRCh38_trans.fa\",\n                          type = \"end3\")\n\nlibrary(patchwork)\n\np5 &lt;- sapply(dp5,\"[\",1)\np3 &lt;- sapply(dp3,\"[\",1)\n\np5[[1]] + p3[[1]]",
    "crumbs": [
      "Enzyme digestion site"
    ]
  },
  {
    "objectID": "Motif-occupancy.html",
    "href": "Motif-occupancy.html",
    "title": "Motif occupancy",
    "section": "",
    "text": "Intro\nTo investigate how ribosome occupancy varies across different treatment conditions, cumulative distribution curves are employed to visualize the translational enrichment at specific amino acids or peptide motifs based on Ribo-seq data.",
    "crumbs": [
      "Motif occupancy"
    ]
  },
  {
    "objectID": "Motif-occupancy.html#cumulative-curve",
    "href": "Motif-occupancy.html#cumulative-curve",
    "title": "Motif occupancy",
    "section": "Cumulative curve",
    "text": "Cumulative curve\nThe motif_occupancy function allows for the quantification of ribosome occupancy at specific motifs or codons across individual transcripts, and generates cumulative distribution curves to illustrate global translational trends under different treatment conditions. As shown below, upon the loss of eIF5A, an overall increase in occupancy is observed at the following motifs:\n\nmotif_occupancy(object = obj0, \n                cds_fa = \"./sac_cds.fa\",\n                search_type = \"amino\",\n                do_offset_correct = T,\n                motif_pattern = c(\"PP\",\"PPP\",\"PPD\",\"DPP\"))\n\n\n\n\n\nBy setting return_data = TRUE, the function returns the result as a data frame:\n\nco &lt;- motif_occupancy(object = obj0, \n                      cds_fa = \"./sac_cds.fa\",\n                      search_type = \"amino\",\n                      do_offset_correct = T,\n                      motif_pattern = c(\"PP\",\"PPP\",\"PPD\",\"DPP\"),\n                      return_data = T)\n\n# check\nhead(co)\n# # A tibble: 6 × 7\n#   sample       sample_group rname             codon_pos value motif   pos\n#   &lt;chr&gt;        &lt;chr&gt;        &lt;chr&gt;                 &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;int&gt;\n# 1 sgeIF5A-rep1 sgeIF5A      YAL002W_mRNA|VPS8        47 34.0  PP       47\n# 2 sgeIF5A-rep1 sgeIF5A      YAL005C_mRNA|SSA1       462  5.69 PP      462\n# 3 sgeIF5A-rep1 sgeIF5A      YAL011W_mRNA|SWC3       339 10.9  PP      339\n# 4 sgeIF5A-rep1 sgeIF5A      YAL013W_mRNA|DEP1       164 13.8  PP      164\n# 5 sgeIF5A-rep1 sgeIF5A      YAL014C_mRNA|SYN8       149 12.0  PP      149\n# 6 sgeIF5A-rep1 sgeIF5A      YAL015C_mRNA|NTG1       327  3.22 PP      327\n\nVisualize the cumulative distribution curve of ribosome occupancy across codons:\n\nmotif_occupancy(object = obj0, \n                cds_fa = \"./sac_cds.fa\",\n                search_type = \"codon\",\n                do_offset_correct = T,\n                motif_pattern = c(\"CCA\",\"CCT\",\"CCG\",\"CCC\"))",
    "crumbs": [
      "Motif occupancy"
    ]
  },
  {
    "objectID": "Feature-plot.html#read-distribution-across-transcript-regions",
    "href": "Feature-plot.html#read-distribution-across-transcript-regions",
    "title": "\n7  Feature distribution\n",
    "section": "",
    "text": "High CDS enrichment indicates efficient ribosome footprint capture and proper rRNA/tRNA depletion.\nExcessive 5′UTR or 3′UTR mapping may suggest contamination from non-translating RNA fragments or suboptimal library preparation.",
    "crumbs": [
      "Quality assessment",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Feature distribution</span>"
    ]
  },
  {
    "objectID": "Serp-Object.html",
    "href": "Serp-Object.html",
    "title": "\n5  Serp object\n",
    "section": "",
    "text": "5.1 Principle\nSelective ribosome profiling (SeRP) is an advanced sequencing technique that builds upon traditional ribosome profiling to investigate translationally active ribosomes under specific conditions or bound to specific factors (e.g., chaperones, ligands, or drugs). Below, we outline its principles, methodology, and applications.\nSelective ribosome profiling focuses on capturing ribosomes engaged in translating specific subsets of mRNAs or ribosomes interacting with regulatory molecules. Unlike standard ribosome profiling, which sequences all ribosome-protected mRNA fragments (RPFs), SeRP employs strategies to: 1. Enrich ribosomes of interest:\n- Use translational inhibitors (e.g., harringtonine) to arrest ribosomes at initiation sites.\n- Tag ribosomes (e.g., via affinity-tagged ribosomal proteins) for selective isolation.\n- Target ribosomes bound to specific co-factors (e.g., chaperones like NAC or SRP).\n2. Resolve context-specific translation: By isolating ribosomes in a defined state, SeRP reveals translational regulation in processes like stress responses, drug treatments, or pathogen-host interactions.\nThe general workflow is shown below Selective Ribosome Profiling to study interactions of translating ribosomes in yeast:",
    "crumbs": [
      "Object construction",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Serp object</span>"
    ]
  },
  {
    "objectID": "Serp-Object.html#methodology",
    "href": "Serp-Object.html#methodology",
    "title": "\n5  Serp object\n",
    "section": "\n5.2 Methodology",
    "text": "5.2 Methodology\nThe sequenced DNA libraries comprising the total translatome and the factor-bound translatome represent a rich data set to study factor engagement properties as well as features of mRNA translation. Initial steps of SeRP data analysis are generally performed using publicly available as well as customized read processing and alignment tools that are also used for RP analysis.\nInitial read processing trims adaptors, removes low quality and noncoding reads, and aligns the filtered reads to the genome of interest. The riboTransVis can be used for subsequent analyses including ribosome E/P/A-site assignment, RP quality assessment and Basic SeRP analysis.",
    "crumbs": [
      "Object construction",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Serp object</span>"
    ]
  },
  {
    "objectID": "Serp-Object.html#serp-object-construction",
    "href": "Serp-Object.html#serp-object-construction",
    "title": "\n5  Serp object\n",
    "section": "\n5.3 Serp object construction",
    "text": "5.3 Serp object construction\nWe used the construct_serp() function from the riboTransVis package to create a serp object, which is designed for analyzing selective ribosome profiling data. This function takes as input both total and IP-enriched BAM files, along with annotation files and sample metadata.\n\n# Set the working directory to the alignment result folder\nsetwd(\"~/junjun_proj/31.ssb_proj/4.map-data/\")\ngetwd()\n\n# Install and load the riboTransVis package\ndevtools::install_github(\"junjunlab/riboTransVis\", force = TRUE)\nlibrary(riboTransVis)\n\n# Define input BAM files for total (translatome) and IP (interactome) libraries\ntt.bam &lt;- c(\"WT_Ssb1-GFP_translatome_rep1.bam\",\n            \"WT_Ssb1-GFP_translatome_rep2.bam\",\n            \"WT_Ssb2-GFP_translatome_rep1.bam\",\n            \"WT_Ssb2-GFP_translatome_rep2.bam\")\n\nip.bam &lt;- c(\"WT_Ssb1_interactome_rep1.bam\",\n            \"WT_Ssb1_interactome_rep2.bam\",\n            \"WT_Ssb2_interactome_rep1.bam\",\n            \"WT_Ssb2_interactome_rep2.bam\")\n\n# Construct the 'serp' object\nobj &lt;- construct_serp(genome_file = \"../../index-data/Saccharomyces_cerevisiae.R64-1-1.dna.toplevel.fa\",\n                      gtf_file = \"../../index-data/Saccharomyces_cerevisiae.R64-1-1.112.gtf\",\n                      mapping_type = \"genome\",\n                      assignment_mode = \"end5\",\n                      extend = TRUE,\n                      extend_upstream = 50,\n                      extend_downstream = 50,\n                      total_bam_file = tt.bam,\n                      total_sample_name = c(\"ssb1_rep1\",\"ssb1_rep2\",\"ssb2_rep1\",\"ssb2_rep2\"),\n                      total_sample_group = c(\"ssb1\",\"ssb1\",\"ssb2\",\"ssb2\"),\n                      IP_bam_file = ip.bam,\n                      IP_sample_name = c(\"ssb1_rep1\",\"ssb1_rep2\",\"ssb2_rep1\",\"ssb2_rep2\"),\n                      IP_sample_group = c(\"ssb1\",\"ssb1\",\"ssb2\",\"ssb2\"),\n                      choose_longest_trans = TRUE)",
    "crumbs": [
      "Object construction",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Serp object</span>"
    ]
  },
  {
    "objectID": "Serp-Object.html#quality-evaluation",
    "href": "Serp-Object.html#quality-evaluation",
    "title": "\n5  Serp object\n",
    "section": "\n5.4 Quality evaluation",
    "text": "5.4 Quality evaluation\nWe begin by evaluating basic quality control (QC) metrics, such as the distribution of read lengths—a key feature in ribosome profiling data, as it reflects the presence of ribosome-protected fragments of expected size:\n\n# Compute summary statistics for total and IP libraries\nobj &lt;- generate_summary(\n  object   = obj, \n  exp_type = c(\"total\", \"ip\"), \n  nThreads = 40\n)\n\n# ==============================================================================\n# qc\n# Load ggplot2 for plotting\nlibrary(ggplot2)\n\nlength_plot(obj) +\n  scale_x_continuous(labels = scales::label_number(accuracy = 1)) +\n  facet_wrap(~sample, nrow = 2,scales = \"free\") +\n  theme_ribo()\n\n\n\n\n\nTo assess translational periodicity, we examine the distribution of reads across three reading frames for different fragment lengths. This helps determine whether the data exhibit the expected 3-nt periodicity characteristic of actively translating ribosomes:\n\n# Plot frame distribution across read lengths\nlength_plot(obj, type = \"frame_length\", \n            add_periodicity_label = FALSE) +\n  facet_wrap(~sample, nrow = 2, scales = \"free\") +\n  scale_fill_brewer(palette = \"Greens\", direction = -1) +\n  theme_ribo()\n\n\n\n\n\nTo further assess data quality and ribosome positioning accuracy, we examine the distribution of read offsets relative to annotated start codons. This helps verify whether reads of specific lengths show consistent positioning along transcripts:\n\n# Plot relative offsets for reads of specific lengths\nrelative_offset_plot(obj, read_length = c(20, 35))",
    "crumbs": [
      "Object construction",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Serp object</span>"
    ]
  },
  {
    "objectID": "Preprocessing-intro.html",
    "href": "Preprocessing-intro.html",
    "title": "Preprocessing introduction",
    "section": "",
    "text": "Ribosome profiling (Ribo-seq) data are typically generated through a multi-step experimental pipeline, starting from library preparation to sequencing on high-throughput platforms. The raw data output from sequencing is usually in FASTQ format and requires several preprocessing steps before downstream analysis.\nFirst, quality control should be performed on the raw FASTQ files using tools such as FastQC. To remove adapter contamination introduced during library preparation, trimming tools like Cutadapt or Trim Galore are commonly used. During size selection in the library construction process (e.g., gel purification), fragments within a specific length range are enriched. However, these can still include contaminating small RNAs such as rRNAs and tRNAs.\nTo eliminate these unwanted reads, it is essential to align sequences to a custom database of rRNA, tRNA, and other non-coding RNAs (downloadable from resources like NCBI and Ensembl) and remove matching reads. This filtering helps retain only high-confidence ribosome-protected footprints (RPFs), representing genuine translation events.\nThe cleaned reads can then be aligned to the reference genome or transcriptome using alignment tools such as STAR or HISAT2. Quantification of read counts across gene features can be performed using tools like featureCounts or HTSeq. After quantification, differential translation efficiency analysis between experimental conditions, enriched pathway analysis, and other integrative analyses can be carried out to interpret the biological significance of the translation landscape.",
    "crumbs": [
      "Preprocessing introduction"
    ]
  },
  {
    "objectID": "Selective-ribosome-profiling.html",
    "href": "Selective-ribosome-profiling.html",
    "title": "\n3  Selective ribosome profiling\n",
    "section": "",
    "text": "3.1 Inro\nIn this section, we reanalyze selective ribosome profiling data from the study titled “Profiling Ssb–Nascent Chain Interactions Reveals Principles of Hsp70-Assisted Folding” , published in Cell in 2017. This dataset provides an excellent example of how selective ribosome profiling can be used to dissect ribosome-associated interactions—in this case, focusing on the Hsp70 chaperone Ssb and its role in co-translational protein folding.\nThis study investigates how the ribosome-associated Hsp70 chaperone Ssb (found in yeast) engages with nascent polypeptides during translation, uncovering key principles of co-translational protein folding. The researchers employed a high-resolution approach—Selective Ribosome Profiling (SeRP)—to globally map Ssb-substrate interactions with near codon-level resolution in vivo.",
    "crumbs": [
      "Preprocessing introduction",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Selective ribosome profiling</span>"
    ]
  },
  {
    "objectID": "Selective-ribosome-profiling.html#data-download",
    "href": "Selective-ribosome-profiling.html#data-download",
    "title": "\n3  Selective ribosome profiling\n",
    "section": "\n3.2 Data download",
    "text": "3.2 Data download\nThe uploaded data is at GEO database GSE93830:\n\n\n\n\nWe retrieve the Aspera download links for each individual sample from SRA Explorer, and then use the Aspera command-line client (ascp) under a Linux environment to quickly and reliably download the corresponding FASTQ files:\n\n#!/usr/bin/env bash\nascp -QT -l 300m -P33001 -i $HOME/.aspera/connect/etc/asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:vol1/fastq/SRR518/009/SRR5188589/SRR5188589.fastq.gz . && mv SRR5188589.fastq.gz ssb2_Ssb1_interactome_low_salt_rep1.fastq.gz\nascp -QT -l 300m -P33001 -i $HOME/.aspera/connect/etc/asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:vol1/fastq/SRR518/004/SRR5188624/SRR5188624.fastq.gz . && mv SRR5188624.fastq.gz RAC_Ssb2_interactome_rep2.fastq.gz\nascp -QT -l 300m -P33001 -i $HOME/.aspera/connect/etc/asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:vol1/fastq/SRR518/004/SRR5188594/SRR5188594.fastq.gz . && mv SRR5188594.fastq.gz ssb1_Ssb2-GFP_translatome_rep1.fastq.gz\nascp -QT -l 300m -P33001 -i $HOME/.aspera/connect/etc/asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:vol1/fastq/SRR518/002/SRR5188592/SRR5188592.fastq.gz . && mv SRR5188592.fastq.gz ssb1_Ssb2_interactome_low_salt_rep1.fastq.gz\nascp -QT -l 300m -P33001 -i $HOME/.aspera/connect/etc/asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:vol1/fastq/SRR518/008/SRR5188628/SRR5188628.fastq.gz . && mv SRR5188628.fastq.gz ssb1_ssb2_translatome_rep2.fastq.gz\nascp -QT -l 300m -P33001 -i $HOME/.aspera/connect/etc/asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:vol1/fastq/SRR518/005/SRR5188625/SRR5188625.fastq.gz . && mv SRR5188625.fastq.gz WT_translatome_rep1.fastq.gz\nascp -QT -l 300m -P33001 -i $HOME/.aspera/connect/etc/asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:vol1/fastq/SRR518/006/SRR5188616/SRR5188616.fastq.gz . && mv SRR5188616.fastq.gz WT_Ssb2_interactome_rep2.fastq.gz\nascp -QT -l 300m -P33001 -i $HOME/.aspera/connect/etc/asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:vol1/fastq/SRR518/007/SRR5188617/SRR5188617.fastq.gz . && mv SRR5188617.fastq.gz NAC_Ssb1-GFP_translatome_rep2.fastq.gz\nascp -QT -l 300m -P33001 -i $HOME/.aspera/connect/etc/asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:vol1/fastq/SRR518/000/SRR5188600/SRR5188600.fastq.gz . && mv SRR5188600.fastq.gz ssb1_Ssb2-GFP_translatome_rep2.fastq.gz\nascp -QT -l 300m -P33001 -i $HOME/.aspera/connect/etc/asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:vol1/fastq/SRR518/008/SRR5188598/SRR5188598.fastq.gz . && mv SRR5188598.fastq.gz ssb1_Ssb2_interactome_low_salt_rep2.fastq.gz\nascp -QT -l 300m -P33001 -i $HOME/.aspera/connect/etc/asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:vol1/fastq/SRR518/001/SRR5188591/SRR5188591.fastq.gz . && mv SRR5188591.fastq.gz ssb2_Ssb1-GFP_translatome_rep1.fastq.gz\nascp -QT -l 300m -P33001 -i $HOME/.aspera/connect/etc/asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:vol1/fastq/SRR518/002/SRR5188602/SRR5188602.fastq.gz . && mv SRR5188602.fastq.gz WT_Ssb2-GFP_translatome_rep1.fastq.gz\nascp -QT -l 300m -P33001 -i $HOME/.aspera/connect/etc/asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:vol1/fastq/SRR518/007/SRR5188627/SRR5188627.fastq.gz . && mv SRR5188627.fastq.gz ssb1_ssb2_translatome_rep1.fastq.gz\nascp -QT -l 300m -P33001 -i $HOME/.aspera/connect/etc/asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:vol1/fastq/SRR518/007/SRR5188597/SRR5188597.fastq.gz . && mv SRR5188597.fastq.gz ssb2_Ssb1-GFP_translatome_rep2.fastq.gz\nascp -QT -l 300m -P33001 -i $HOME/.aspera/connect/etc/asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:vol1/fastq/SRR518/007/SRR5188607/SRR5188607.fastq.gz . && mv SRR5188607.fastq.gz NAC_Ssb1_interactome_rep1.fastq.gz\nascp -QT -l 300m -P33001 -i $HOME/.aspera/connect/etc/asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:vol1/fastq/SRR518/001/SRR5188621/SRR5188621.fastq.gz . && mv SRR5188621.fastq.gz RAC_Ssb1-GFP_translatome_rep2.fastq.gz\nascp -QT -l 300m -P33001 -i $HOME/.aspera/connect/etc/asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:vol1/fastq/SRR518/004/SRR5188614/SRR5188614.fastq.gz . && mv SRR5188614.fastq.gz WT_Ssb2-GFP_translatome_rep2.fastq.gz\nascp -QT -l 300m -P33001 -i $HOME/.aspera/connect/etc/asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:vol1/fastq/SRR518/003/SRR5188613/SRR5188613.fastq.gz . && mv SRR5188613.fastq.gz WT_Ssb1-GFP_translatome_rep2.fastq.gz\nascp -QT -l 300m -P33001 -i $HOME/.aspera/connect/etc/asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:vol1/fastq/SRR518/003/SRR5188603/SRR5188603.fastq.gz . && mv SRR5188603.fastq.gz WT_Ssb1_interactome_rep1.fastq.gz\nascp -QT -l 300m -P33001 -i $HOME/.aspera/connect/etc/asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:vol1/fastq/SRR518/005/SRR5188595/SRR5188595.fastq.gz . && mv SRR5188595.fastq.gz ssb2_Ssb1_interactome_low_salt_rep2.fastq.gz\nascp -QT -l 300m -P33001 -i $HOME/.aspera/connect/etc/asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:vol1/fastq/SRR518/001/SRR5188611/SRR5188611.fastq.gz . && mv SRR5188611.fastq.gz RAC_Ssb1_interactome_rep1.fastq.gz\nascp -QT -l 300m -P33001 -i $HOME/.aspera/connect/etc/asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:vol1/fastq/SRR518/008/SRR5188608/SRR5188608.fastq.gz . && mv SRR5188608.fastq.gz NAC_Ssb2_interactome_rep1.fastq.gz\nascp -QT -l 300m -P33001 -i $HOME/.aspera/connect/etc/asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:vol1/fastq/SRR518/006/SRR5188626/SRR5188626.fastq.gz . && mv SRR5188626.fastq.gz WT_translatome_rep2.fastq.gz\nascp -QT -l 300m -P33001 -i $HOME/.aspera/connect/etc/asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:vol1/fastq/SRR518/008/SRR5188618/SRR5188618.fastq.gz . && mv SRR5188618.fastq.gz NAC_Ssb2-GFP_translatome_rep2.fastq.gz\nascp -QT -l 300m -P33001 -i $HOME/.aspera/connect/etc/asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:vol1/fastq/SRR518/001/SRR5188601/SRR5188601.fastq.gz . && mv SRR5188601.fastq.gz WT_Ssb1-GFP_translatome_rep1.fastq.gz\nascp -QT -l 300m -P33001 -i $HOME/.aspera/connect/etc/asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:vol1/fastq/SRR518/006/SRR5188596/SRR5188596.fastq.gz . && mv SRR5188596.fastq.gz ssb2_Ssb1_interactome_high_salt_rep2.fastq.gz\nascp -QT -l 300m -P33001 -i $HOME/.aspera/connect/etc/asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:vol1/fastq/SRR518/000/SRR5188610/SRR5188610.fastq.gz . && mv SRR5188610.fastq.gz RAC_Ssb2-GFP_translatome_rep1.fastq.gz\nascp -QT -l 300m -P33001 -i $HOME/.aspera/connect/etc/asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:vol1/fastq/SRR518/003/SRR5188593/SRR5188593.fastq.gz . && mv SRR5188593.fastq.gz ssb1_Ssb2_interactome_high_salt_rep1.fastq.gz\nascp -QT -l 300m -P33001 -i $HOME/.aspera/connect/etc/asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:vol1/fastq/SRR518/005/SRR5188615/SRR5188615.fastq.gz . && mv SRR5188615.fastq.gz WT_Ssb1_interactome_rep2.fastq.gz\nascp -QT -l 300m -P33001 -i $HOME/.aspera/connect/etc/asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:vol1/fastq/SRR518/000/SRR5188620/SRR5188620.fastq.gz . && mv SRR5188620.fastq.gz NAC_Ssb2_interactome_rep2.fastq.gz\nascp -QT -l 300m -P33001 -i $HOME/.aspera/connect/etc/asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:vol1/fastq/SRR518/009/SRR5188609/SRR5188609.fastq.gz . && mv SRR5188609.fastq.gz RAC_Ssb1-GFP_translatome_rep1.fastq.gz\nascp -QT -l 300m -P33001 -i $HOME/.aspera/connect/etc/asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:vol1/fastq/SRR518/009/SRR5188599/SRR5188599.fastq.gz . && mv SRR5188599.fastq.gz ssb1_Ssb2_interactome_high_salt_rep2.fastq.gz\nascp -QT -l 300m -P33001 -i $HOME/.aspera/connect/etc/asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:vol1/fastq/SRR518/002/SRR5188622/SRR5188622.fastq.gz . && mv SRR5188622.fastq.gz RAC_Ssb2-GFP_translatome_rep2.fastq.gz\nascp -QT -l 300m -P33001 -i $HOME/.aspera/connect/etc/asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:vol1/fastq/SRR518/002/SRR5188612/SRR5188612.fastq.gz . && mv SRR5188612.fastq.gz RAC_Ssb2_interactome_rep1.fastq.gz\nascp -QT -l 300m -P33001 -i $HOME/.aspera/connect/etc/asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:vol1/fastq/SRR518/009/SRR5188619/SRR5188619.fastq.gz . && mv SRR5188619.fastq.gz NAC_Ssb1_interactome_rep2.fastq.gz\nascp -QT -l 300m -P33001 -i $HOME/.aspera/connect/etc/asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:vol1/fastq/SRR518/004/SRR5188604/SRR5188604.fastq.gz . && mv SRR5188604.fastq.gz WT_Ssb2_interactome_rep1.fastq.gz\nascp -QT -l 300m -P33001 -i $HOME/.aspera/connect/etc/asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:vol1/fastq/SRR518/003/SRR5188623/SRR5188623.fastq.gz . && mv SRR5188623.fastq.gz RAC_Ssb1_interactome_rep2.fastq.gz\nascp -QT -l 300m -P33001 -i $HOME/.aspera/connect/etc/asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:vol1/fastq/SRR518/006/SRR5188606/SRR5188606.fastq.gz . && mv SRR5188606.fastq.gz NAC_Ssb2-GFP_translatome_rep1.fastq.gz\nascp -QT -l 300m -P33001 -i $HOME/.aspera/connect/etc/asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:vol1/fastq/SRR518/005/SRR5188605/SRR5188605.fastq.gz . && mv SRR5188605.fastq.gz NAC_Ssb1-GFP_translatome_rep1.fastq.gz\nascp -QT -l 300m -P33001 -i $HOME/.aspera/connect/etc/asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:vol1/fastq/SRR518/000/SRR5188590/SRR5188590.fastq.gz . && mv SRR5188590.fastq.gz ssb2_Ssb1_interactome_high_salt_rep1.fastq.gz",
    "crumbs": [
      "Preprocessing introduction",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Selective ribosome profiling</span>"
    ]
  },
  {
    "objectID": "Selective-ribosome-profiling.html#removal-of-adapter-contamination",
    "href": "Selective-ribosome-profiling.html#removal-of-adapter-contamination",
    "title": "\n3  Selective ribosome profiling\n",
    "section": "\n3.3 Removal of Adapter Contamination",
    "text": "3.3 Removal of Adapter Contamination\nFollowing the methods described in the original publication, we removed adapter sequences from the raw sequencing data using Cutadapt. The command below was applied to all libraries to trim 3’ adapter contamination:\n\nfor i in NAC_Ssb1-GFP_translatome_rep NAC_Ssb1_interactome_rep NAC_Ssb2-GFP_translatome_rep NAC_Ssb2_interactome_rep \\\n         RAC_Ssb1-GFP_translatome_rep RAC_Ssb1_interactome_rep RAC_Ssb2-GFP_translatome_rep RAC_Ssb2_interactome_rep \\\n         ssb1_Ssb2-GFP_translatome_rep ssb1_Ssb2_interactome_high_salt_rep ssb1_Ssb2_interactome_low_salt_rep \\\n         ssb1_ssb2_translatome_rep ssb2_Ssb1-GFP_translatome_rep ssb2_Ssb1_interactome_high_salt_rep \\\n         ssb2_Ssb1_interactome_low_salt_rep WT_Ssb1-GFP_translatome_rep WT_Ssb1_interactome_rep \\\n         WT_Ssb2-GFP_translatome_rep WT_Ssb2_interactome_rep WT_translatome_rep\ndo\n    for j in 1 2\n    do\n        cutadapt -j 25 -a CTGTAGGCACCATCAATTCGTATGCCGTCTT \\\n                 -m 20 -M 45 --discard-untrimmed \\\n                 -o ./${i}${j}_trim.fq.gz \\\n                 ../1.raw-data/${i}${j}.fastq.gz\n    done\ndone",
    "crumbs": [
      "Preprocessing introduction",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Selective ribosome profiling</span>"
    ]
  },
  {
    "objectID": "Selective-ribosome-profiling.html#removal-of-rrna-contamination",
    "href": "Selective-ribosome-profiling.html#removal-of-rrna-contamination",
    "title": "\n3  Selective ribosome profiling\n",
    "section": "\n3.4 Removal of rRNA Contamination",
    "text": "3.4 Removal of rRNA Contamination\nTo eliminate reads originating from ribosomal RNA (rRNA), we aligned the trimmed reads to a reference rRNA database using Bowtie2. Reads that aligned to rRNA were discarded, and only unmapped reads, representing non-rRNA fragments, were retained for downstream analysis:\n\n# rRNA removal using Bowtie2\nfor i in NAC_Ssb1-GFP_translatome_rep NAC_Ssb1_interactome_rep NAC_Ssb2-GFP_translatome_rep NAC_Ssb2_interactome_rep \\\n         RAC_Ssb1-GFP_translatome_rep RAC_Ssb1_interactome_rep RAC_Ssb2-GFP_translatome_rep RAC_Ssb2_interactome_rep \\\n         ssb1_Ssb2-GFP_translatome_rep ssb1_Ssb2_interactome_high_salt_rep ssb1_Ssb2_interactome_low_salt_rep \\\n         ssb1_ssb2_translatome_rep ssb2_Ssb1-GFP_translatome_rep ssb2_Ssb1_interactome_high_salt_rep \\\n         ssb2_Ssb1_interactome_low_salt_rep WT_Ssb1-GFP_translatome_rep WT_Ssb1_interactome_rep \\\n         WT_Ssb2-GFP_translatome_rep WT_Ssb2_interactome_rep WT_translatome_rep\ndo\n    for j in 1 2\n    do         \n        bowtie2 -p 25 -x ../../index-data/sac-rRNA-index/Saccharomyces-cerevisiae-rRNA \\\n                --un-gz ${i}${j}.rmrRNA.fq.gz \\\n                -U ../2.trim-data/${i}${j}_trim.fq.gz \\\n                -S ./null\n    done\ndone",
    "crumbs": [
      "Preprocessing introduction",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Selective ribosome profiling</span>"
    ]
  },
  {
    "objectID": "Selective-ribosome-profiling.html#alignment-to-the-reference-genome",
    "href": "Selective-ribosome-profiling.html#alignment-to-the-reference-genome",
    "title": "\n3  Selective ribosome profiling\n",
    "section": "\n3.5 Alignment to the Reference Genome",
    "text": "3.5 Alignment to the Reference Genome\nTo align non-rRNA reads to the reference genome, we first constructed a Bowtie index using the Saccharomyces cerevisiae genome (version R64-1-1):\n\n# Build Bowtie index\nmkdir sac-bowtie-index\nbowtie-build Saccharomyces_cerevisiae.R64-1-1.dna.toplevel.fa sac-bowtie-index/sac\n\nWe then aligned all rRNA-depleted libraries to the reference genome using Bowtie. The alignment was followed by sorting with samtools and removal of intermediate SAM files to conserve disk space:\n\n#!/bin/bash\nfor i in WT_Ssb1-GFP_translatome_rep  WT_Ssb1_interactome_rep WT_Ssb2-GFP_translatome_rep WT_Ssb2_interactome_rep \\\n         WT_translatome_rep NAC_Ssb1-GFP_translatome_rep NAC_Ssb1_interactome_rep NAC_Ssb2-GFP_translatome_rep \\\n         NAC_Ssb2_interactome_rep RAC_Ssb1-GFP_translatome_rep RAC_Ssb1_interactome_rep \\\n         RAC_Ssb2-GFP_translatome_rep RAC_Ssb2_interactome_rep ssb1_Ssb2-GFP_translatome_rep \\\n         ssb1_Ssb2_interactome_high_salt_rep ssb1_Ssb2_interactome_low_salt_rep ssb1_ssb2_translatome_rep \\\n         ssb2_Ssb1-GFP_translatome_rep ssb2_Ssb1_interactome_high_salt_rep ssb2_Ssb1_interactome_low_salt_rep\ndo\n    for j in 1 2\n    do\n        # Align to genome using Bowtie (original version)\n        bowtie -p 25 ../../index-data/sac-bowtie-index/sac \\\n               -v 2 -m 5 --best --strata \\\n               &lt;(zcat ../3.rmrRNA-data/${i}${j}.rmrRNA.fq.gz) \\\n               -S ./${i}${j}.sam\n\n        # Convert SAM to sorted BAM\n        samtools sort -@ 25 -o ${i}${j}.bam ./${i}${j}.sam\n        rm ./${i}${j}.sam  # Remove intermediate files\n    done\ndone\n\nKey options explained:\n\n-v 2: Allows up to 2 mismatches per read.\n-m 5: Discards reads that map to more than 5 locations (to avoid ambiguous mappings).\n--best --strata: Ensures the best alignment from the best strata is reported.\n-p 25: Uses 25 threads for parallel processing.\nsamtools sort: Sorts alignments by genomic coordinates for downstream processing.",
    "crumbs": [
      "Preprocessing introduction",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Selective ribosome profiling</span>"
    ]
  },
  {
    "objectID": "Ribotrans-Object.html",
    "href": "Ribotrans-Object.html",
    "title": "\n4  Ribotrans object\n",
    "section": "",
    "text": "The RiboTransVis package utilizes an object-oriented programming paradigm for the analysis of Ribo-seq data. At the core of this framework is the ribotrans object, which encapsulates all essential information required for downstream analysis. Most functions in the package are designed to operate on this object. Therefore, the first step in any Ribo-seq analysis workflow using RiboTransVis is to construct a well-defined ribotrans object. This object is typically created from a set of inputs including the transcriptome FASTA file, a GTF annotation file, and aligned Ribo-seq data in BAM format.\n\n\n4.0.1 Constructing a Ribotrans Object\nIn this section, we demonstrate how to construct a RiboTrans object using Ribo-seq data obtained from wild-type (WT) and eIF5A knockout (sgeIF5A) yeast samples. This object serves as the core input for downstream translational profiling and visualization using RiboTransVis.\nTo create the RiboTrans object, you will need the following:\n\nA reference genome sequence file in FASTA format\nA corresponding gene annotation file in GTF format\nSample names\nAligned BAM files for each Ribo-seq sample\n\nWe specify that the BAM files are genome-aligned (not transcriptome-aligned) by setting mapping_type = “genome”. For assigning ribosome footprints to transcript features (e.g., CDS), we use the 5′-end rule by setting assignment_mode = “end5”.\nIn addition, we enable transcriptional region extension by setting extend = TRUE. This instructs RiboTrans to expand the annotation ranges defined in the GTF file, which can help recover reads that fall slightly upstream or downstream of annotated features. You can manually control the size of this extension via the extend_upstream and extend_downstream parameters (recommended: 50 nt).\nAnother important parameter is choose_longest_trans, which determines whether to reduce transcript redundancy by selecting a representative isoform for each gene. When set to TRUE, RiboTrans will select a canonical transcript per gene based on the following criteria:\n\nThe transcript with the longest CDS (coding sequence) is preferred.\nIf two or more transcripts share the same CDS length, the transcript with the longest overall exon span is selected as representative.\n\nWhen this parameter is not set (or set to FALSE), RiboTrans analyzes all annotated isoforms for each gene, which can increase the resolution of analysis but will substantially prolong processing time and downstream computational complexity.\nBelow is an example of the recommended code for constructing a ribotrans object with two replicates for WT and two for eIF5A-knockout samples:\n\ngp &lt;- c(\"wt-rep1\",\"wt-rep2\",\"sgeIF5A-rep1\",\"sgeIF5A-rep2\")\n\nribobams &lt;- c(\"WT.1.sorted.bam\",\"WT.2.sorted.bam\",\"eIF5Ad.1.sorted.bam\",\"eIF5Ad.2.sorted.bam\")\n\nobj0 &lt;- construct_ribotrans(genome_file = \"../../index-data/Saccharomyces_cerevisiae.R64-1-1.dna.toplevel.fa\",\n                            gtf_file = \"../../index-data/Saccharomyces_cerevisiae.R64-1-1.112.gtf\",\n                            mapping_type = \"genome\",\n                            assignment_mode = \"end5\",\n                            extend = TRUE,\n                            extend_upstream = 50,\n                            extend_downstream = 50,\n                            Ribo_bam_file = ribobams,\n                            Ribo_sample_name = gp,\n                            choose_longest_trans = T)\n\nRiboTrans not only stores the input sample information but also automatically extracts and retains relevant transcript annotation data for downstream analysis. Below is a preview of the recently created Ribotrans object, including both sample metadata and the transcript features parsed from the annotation file:\n\nWhen creating the object, we specified the extend parameter to expand both upstream and downstream regions of the CDS by 50 nucleotides. You can observe this setting reflected in the “features” slot of the RiboTrans object, where the lengths of utr5 and utr3 are both 50. You may also notice some genes with a CDS length of 0 — these correspond to non-coding genes, which do not contain annotated coding sequences, and thus their CDS length is set to 0 accordingly:\n\nobj0\nAn object of class \"ribotrans\"\nSlot \"bam_file\":\n                  bam type       sample sample_group\n1     WT.1.sorted.bam ribo      wt-rep1      wt-rep1\n2     WT.2.sorted.bam ribo      wt-rep2      wt-rep2\n3 eIF5Ad.1.sorted.bam ribo sgeIF5A-rep1 sgeIF5A-rep1\n4 eIF5Ad.2.sorted.bam ribo sgeIF5A-rep2 sgeIF5A-rep2\n\nSlot \"library\":\n                  bam mappped_reads type       sample sample_group\n1     WT.1.sorted.bam      44198992 ribo      wt-rep1      wt-rep1\n2     WT.2.sorted.bam      23149956 ribo      wt-rep2      wt-rep2\n3 eIF5Ad.1.sorted.bam      35041935 ribo sgeIF5A-rep1 sgeIF5A-rep1\n4 eIF5Ad.2.sorted.bam      26762955 ribo sgeIF5A-rep2 sgeIF5A-rep2\n\nSlot \"gtf_data\":\nGRanges object with 41879 ranges and 16 metadata columns:\n          seqnames      ranges strand |   source        type     score     phase     gene_id   gene_name gene_source\n             &lt;Rle&gt;   &lt;IRanges&gt;  &lt;Rle&gt; | &lt;factor&gt;    &lt;factor&gt; &lt;numeric&gt; &lt;integer&gt; &lt;character&gt; &lt;character&gt; &lt;character&gt;\n      [1]       IV   8683-9756      - |      sgd gene               NA      &lt;NA&gt;     YDL246C        SOR2         sgd\n      [2]       IV   8683-9756      - |      sgd transcript         NA      &lt;NA&gt;     YDL246C        SOR2         sgd\n      [3]       IV   8683-9756      - |      sgd exon               NA      &lt;NA&gt;     YDL246C        SOR2         sgd\n      [4]       IV   8686-9756      - |      sgd CDS                NA         0     YDL246C        SOR2         sgd\n      [5]       IV   9754-9756      - |      sgd start_codon        NA         0     YDL246C        SOR2         sgd\n      ...      ...         ...    ... .      ...         ...       ...       ...         ...         ...         ...\n  [41875]     Mito 70162-70237      + |      sgd  exon              NA      &lt;NA&gt;    tI(GAU)Q        &lt;NA&gt;         sgd\n  [41876]     Mito 58009-62447      + |      sgd  gene              NA      &lt;NA&gt;       Q0158    21S_RRNA         sgd\n  [41877]     Mito 58009-62447      + |      sgd  transcript        NA      &lt;NA&gt;       Q0158    21S_RRNA         sgd\n  [41878]     Mito 58009-60724      + |      sgd  exon              NA      &lt;NA&gt;       Q0158    21S_RRNA         sgd\n  [41879]     Mito 61868-62447      + |      sgd  exon              NA      &lt;NA&gt;       Q0158    21S_RRNA         sgd\n            gene_biotype transcript_id transcript_name transcript_source transcript_biotype               tag\n             &lt;character&gt;   &lt;character&gt;     &lt;character&gt;       &lt;character&gt;        &lt;character&gt;       &lt;character&gt;\n      [1] protein_coding          &lt;NA&gt;            &lt;NA&gt;              &lt;NA&gt;               &lt;NA&gt;              &lt;NA&gt;\n      [2] protein_coding  YDL246C_mRNA            SOR2               sgd     protein_coding Ensembl_canonical\n      [3] protein_coding  YDL246C_mRNA            SOR2               sgd     protein_coding Ensembl_canonical\n      [4] protein_coding  YDL246C_mRNA            SOR2               sgd     protein_coding Ensembl_canonical\n      [5] protein_coding  YDL246C_mRNA            SOR2               sgd     protein_coding Ensembl_canonical\n      ...            ...           ...             ...               ...                ...               ...\n  [41875]           tRNA tI(GAU)Q_tRNA            &lt;NA&gt;               sgd               tRNA Ensembl_canonical\n  [41876]           rRNA          &lt;NA&gt;            &lt;NA&gt;              &lt;NA&gt;               &lt;NA&gt;              &lt;NA&gt;\n  [41877]           rRNA    Q0158_rRNA            &lt;NA&gt;               sgd               rRNA Ensembl_canonical\n  [41878]           rRNA    Q0158_rRNA            &lt;NA&gt;               sgd               rRNA Ensembl_canonical\n  [41879]           rRNA    Q0158_rRNA            &lt;NA&gt;               sgd               rRNA Ensembl_canonical\n          exon_number          exon_id  protein_id\n          &lt;character&gt;      &lt;character&gt; &lt;character&gt;\n      [1]        &lt;NA&gt;             &lt;NA&gt;        &lt;NA&gt;\n      [2]        &lt;NA&gt;             &lt;NA&gt;        &lt;NA&gt;\n      [3]           1  YDL246C_mRNA-E1        &lt;NA&gt;\n      [4]           1             &lt;NA&gt;     YDL246C\n      [5]           1             &lt;NA&gt;        &lt;NA&gt;\n      ...         ...              ...         ...\n  [41875]           1 tI(GAU)Q_tRNA-E1        &lt;NA&gt;\n  [41876]        &lt;NA&gt;             &lt;NA&gt;        &lt;NA&gt;\n  [41877]        &lt;NA&gt;             &lt;NA&gt;        &lt;NA&gt;\n  [41878]           1    Q0158_rRNA-E1        &lt;NA&gt;\n  [41879]           2    Q0158_rRNA-E2        &lt;NA&gt;\n  -------\n  seqinfo: 17 sequences from an unspecified genome; no seqlengths\n\nSlot \"mapping_type\":\n[1] \"genome\"\n\nSlot \"assignment_mode\":\n[1] \"end5\"\n\nSlot \"features\":\n# A tibble: 7,127 × 10\n# Groups:   gene [7,127]\n   transcript_id  idnew                          utr5   cds  utr3 exonlen translen mstart mstop gene          \n   &lt;chr&gt;          &lt;chr&gt;                         &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt;    &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;         \n 1 tY(GUA)Q_tRNA  tY(GUA)Q_tRNA|tY(GUA)Q_tRNA      50     0    50     184      184      0     0 tY(GUA)Q_tRNA \n 2 tX(XXX)L_tRNA  tX(XXX)L_tRNA|tX(XXX)L_tRNA      50     0    50     180      180      0     0 tX(XXX)L_tRNA \n 3 tX(XXX)D_tRNA  tX(XXX)D_tRNA|tX(XXX)D_tRNA      50     0    50     200      200      0     0 tX(XXX)D_tRNA \n 4 tW(UCA)Q_tRNA  tW(UCA)Q_tRNA|tW(UCA)Q_tRNA      50     0    50     174      174      0     0 tW(UCA)Q_tRNA \n 5 tW(CCA)P_tRNA  tW(CCA)P_tRNA|tW(CCA)P_tRNA      50     0    50     172      172      0     0 tW(CCA)P_tRNA \n 6 tW(CCA)M_tRNA  tW(CCA)M_tRNA|tW(CCA)M_tRNA      50     0    50     172      172      0     0 tW(CCA)M_tRNA \n 7 tW(CCA)K_tRNA  tW(CCA)K_tRNA|tW(CCA)K_tRNA      50     0    50     172      172      0     0 tW(CCA)K_tRNA \n 8 tW(CCA)J_tRNA  tW(CCA)J_tRNA|tW(CCA)J_tRNA      50     0    50     172      172      0     0 tW(CCA)J_tRNA \n 9 tW(CCA)G2_tRNA tW(CCA)G2_tRNA|tW(CCA)G2_tRNA    50     0    50     172      172      0     0 tW(CCA)G2_tRNA\n10 tW(CCA)G1_tRNA tW(CCA)G1_tRNA|tW(CCA)G1_tRNA    50     0    50     172      172      0     0 tW(CCA)G1_tRNA\n# ℹ 7,117 more rows\n# ℹ Use `print(n = ...)` to see more rows\n\nSlot \"genome_trans_features\":\n# A tibble: 7,507 × 9\n# Groups:   gene_name, transcript_id [7,127]\n   seqnames  start    end width tx_len strand gene_name transcript_id f_len\n   &lt;fct&gt;     &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;fct&gt;  &lt;chr&gt;     &lt;chr&gt;         &lt;dbl&gt;\n 1 Mito       6496   8244  1749   1749 +      15S_RRNA  Q0020_rRNA     1749\n 2 Mito      57959  60724  2766   2766 +      21S_RRNA  Q0158_rRNA     3396\n 3 Mito      61868  62497   630   3396 +      21S_RRNA  Q0158_rRNA     3396\n 4 II       415933 416956  1024   1024 +      AAC3      YBR085W_mRNA   1024\n 5 X        727355 728321   967    967 +      AAD10     YJR155W_mRNA    967\n 6 III      313840 315031  1192   1192 +      AAD3      YCR107W_mRNA   1192\n 7 XIV      359546 360689  1144   1144 +      AAH1      YNL141W_mRNA   1144\n 8 XI       237486 238941  1456   1456 +      AAT1      YKL106W_mRNA   1456\n 9 XI       226520 228815  2296   2296 +      ABF1      YKL112W_mRNA   2296\n10 XIII     411519 412170   652    652 +      ABF2      YMR072W_mRNA    652\n# ℹ 7,497 more rows\n# ℹ Use `print(n = ...)` to see more rows\n\nSlot \"summary_info\":\ndata frame with 0 columns and 0 rows\n\nSlot \"reads_offset_info\":\ndata frame with 0 columns and 0 rows\n\nSlot \"gene_name\":\ncharacter(0)\n\nSlot \"ribo_occupancy\":\ndata frame with 0 columns and 0 rows\n\nSlot \"ribo.smoothed\":\ncharacter(0)\n\nSlot \"RNA_coverage\":\ndata frame with 0 columns and 0 rows\n\nSlot \"RNA.smoothed\":\ncharacter(0)\n\nSlot \"scaled_occupancy\":\ndata frame with 0 columns and 0 rows\n\n\n4.0.2 Note: Extension of annotation is not required for human or mouse genomes\nFor species such as human (Homo sapiens) or mouse (Mus musculus), most genes already contain well-annotated untranslated regions (UTRs), including 5′UTRs and 3′UTRs, in the reference GTF annotation. Therefore, it is generally unnecessary to manually extend the CDS regions upstream or downstream, as this information is already captured in the transcript models.\nWhen working with these species, you can safely omit the parameters extend = TRUE, extend_upstream, and extend_downstream when constructing the ribotrans object. This will ensure that the annotation is used as-is and will simplify interpretation of coverage profiles in the UTR and CDS regions.\nBelow is an example R code block for human samples:\n\nobj &lt;- construct_ribotrans(gtf_file = \"./Homo_sapiens.GRCh38.110.gtf\",\n                           mapping_type = \"genome\",\n                           assignment_mode = \"end3\",\n                           Ribo_bam_file = c(\"./bam-data/PC9-scr-1Ribo.bam\",\n                                             \"./bam-data/PC9-scr-2Ribo.bam\",\n                                             \"./bam-data/PC9-5A-1Ribo.bam\",\n                                             \"./bam-data/PC9-5A-2Ribo.bam\"),\n                           Ribo_sample_name = c(\"scramble-rep1\",\"scramble-rep2\",\"shEIF5A-rep1\",\"shEIF5A-rep2\"),\n                           choose_longest_trans = T)\n\n\n4.0.3 Assignment mode choose\n\n\n\n\n\n\nIn ribosome profiling (Ribo-seq) data analysis, the assignment_mode parameter is critical for determining which end of each read is used when assigning reads to genomic or transcriptomic features.\n\n\n\n\n4.0.3.1 Paired-end Sequencing Data\nNote that when setting assignment_mode = \"end3\", it often actually corresponds to the 5′ end of the read — particularly when aligning R1 fastq files to the genome.\nThis behavior is due to strand orientation:\n\nReads with SAM flag = 0 (usually from R1) align to genes on the negative (–) strand.\nReads with SAM flag = 16 align to genes on the positive (+) strand.\n\nAs a result, the logical 5′ end of the transcript appears on the opposite strand in the alignment output, which can make \"end3\" correspond to the actual 5′ end of the reads.\nOn the other hand, if R2 fastq files are used for alignment, the configuration is reversed: setting assignment_mode = \"end5\" directly corresponds to the true 5′ end of the reads.\n\n4.0.3.2 Single-end Sequencing Data\nFor single-end reads, the assignment_mode behaves in a more straightforward manner:\n\n\nassignment_mode = \"end5\": counts using the 5′ end of the reads.\n\nassignment_mode = \"end3\": counts using the 3′ end of the reads.\n\n4.0.3.3 Inspecting Strand Orientation with IGV\nIf unsure about which assignment_mode you should use, we strongly recommend loading your BAM file into IGV (Integrative Genomics Viewer) to visually inspect the orientation and strand of your aligned reads.\n\n4.0.3.4 Transcriptome-aligned BAM Files\nWhen working with alignments to the transcriptome (as opposed to the genome), the assignment mode reflects the actual orientation of the reads:\n\n\nassignment_mode = \"end5\": corresponds to the 5′ end.\n\nassignment_mode = \"end3\": corresponds to the 3′ end.\n\nThere is no strand inversion in this case.\n\n4.0.3.5 Summary\n\n\n\n\n\n\n\n\nAlignment Reference\nData Type\nassignment_mode\nRefers To\n\n\n\nGenome\nPaired-end (R1)\n\"end3\"\nActual 5′ end\n\n\n\nGenome\nPaired-end (R2)\n\"end5\"\nActual 5′ end\n\n\n\nGenome\nSingle-end\n\"end5\"\n5′ end\n\n\nGenome\nSingle-end\n\"end3\"\n3′ end\n\n\nTranscriptome\nSingle-end\n\"end5\"\n5′ end\n\n\nTranscriptome\nSingle-end\n\"end3\"\n3′ end\n\n\n\nAlways verify strand orientation to ensure accurate read counting.",
    "crumbs": [
      "Object construction",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Ribotrans object</span>"
    ]
  },
  {
    "objectID": "Profiling-Ssb-Nascent-Chain.html",
    "href": "Profiling-Ssb-Nascent-Chain.html",
    "title": "\n18  Profiling Ssb-Nascent Chain Interactions\n",
    "section": "",
    "text": "18.1 Intro\nThe data download and preprocessing steps for the study “Profiling Ssb-Nascent Chain Interactions Reveals Principles of Hsp70-Assisted Folding” can be found in the “Selective-ribosome-profiling” section. Next, we will reproduce a selection of figures from the paper.",
    "crumbs": [
      "More examples",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Profiling Ssb-Nascent Chain Interactions</span>"
    ]
  },
  {
    "objectID": "Profiling-Ssb-Nascent-Chain.html#metagene-profiles",
    "href": "Profiling-Ssb-Nascent-Chain.html#metagene-profiles",
    "title": "\n18  Profiling Ssb-Nascent Chain Interactions\n",
    "section": "\n18.2 Metagene profiles",
    "text": "18.2 Metagene profiles\nFigure 1B of the study shows that in cells expressing either Ssb1-GFP or Ssb2-GFP, the metagene translatome exhibits a typical accumulation of ribosome footprints near the start codon, reflecting slow translation initiation, followed by a nearly uniform distribution across the first 500 codons. The Ssb1- and Ssb2-bound translatomes are highly similar to each other but differ from the total translatome. Specifically, the mean read density in Ssb-bound translatomes is low within the first 50 codons and then reaches a stable plateau, indicating that Ssb begins to engage nascent chains on average after ~50 amino acids have been synthesized. Since 25–30 residues are still inside the ribosome during translation, this suggests that Ssb starts interacting with nascent chains when approximately 20 amino acids are exposed outside the ribosome:\n\n\n\n\nWe use the metagene_plot function to visualize ribosome density in the region from -50 to 1500 nucleotidesrelative to the start codon), with codon as the unit:\n\nmetagene_plot(object = obj,\n              mode = \"codon\",\n              rel2st_dist = c(-50, 1500),\n              facet_wrap = ggplot2::facet_wrap(~sample,nrow = 2))\n\n\n\n\n\nAlternatively, we can extract the data ourselves for customized plotting:\n\nmt &lt;- metagene_plot(object = obj,\n                    mode = \"codon\",\n                    rel2st_dist = c(-50, 1500),\n                    return_data = T)\n\n# check\nhead(mt)\n# # A tibble: 6 × 3\n#  sample         rel    avg\n#  &lt;chr&gt;        &lt;dbl&gt;  &lt;dbl&gt;\n# 1 ssb1_rep1-ip   -16 0.0627\n# 2 ssb1_rep1-ip   -15 0.0829\n# 3 ssb1_rep1-ip   -14 0.0842\n# 4 ssb1_rep1-ip   -13 0.0878\n# 5 ssb1_rep1-ip   -12 0.0805\n# 6 ssb1_rep1-ip   -11 0.0578\n\nWe can also visualize the data by grouping biological replicates and separately plotting the total and IP samples:\n\n# add groups\nmt$gp &lt;- sapply(strsplit(mt$sample,split = \"_\"),\"[\",1)\nmt$tp &lt;- sapply(strsplit(mt$sample,split = \"-\"),\"[\",2)\nmt$rep &lt;- sapply(strsplit(mt$sample,split = \"_|-\"),\"[\",2)\n\n# plot\nggplot(mt) +\n  geom_line(aes(x = rel,y = avg,colour = sample)) +\n  facet_grid(rep~gp) +\n  theme_bw() +\n  theme(axis.text = element_text(colour = \"black\"),\n        panel.grid = element_blank(),\n        strip.text = element_text(face = \"bold\",size = rel(1))) +\n  xlab(\"Codons / amino acids\") +\n  ylab(\"Mean read density [AU]\")",
    "crumbs": [
      "More examples",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Profiling Ssb-Nascent Chain Interactions</span>"
    ]
  },
  {
    "objectID": "Profiling-Ssb-Nascent-Chain.html#single-gene-enrichment-profile",
    "href": "Profiling-Ssb-Nascent-Chain.html#single-gene-enrichment-profile",
    "title": "\n18  Profiling Ssb-Nascent Chain Interactions\n",
    "section": "\n18.3 Single gene enrichment profile",
    "text": "18.3 Single gene enrichment profile\nThe article demonstrates that the proteins PMT1, CDC37, and CCT3 are among the nascent chains bound by Ssb, as shown in Figure 1:\n\n\n\n\n我们批量绘制这3个基因的enrichment的track图：\n\nglist &lt;- c(\"PMT1\", \"CDC37\", \"CCT3\")\n\n# x = 1\nlapply(seq_along(glist), function(x){\n  obj &lt;- get_occupancy(object = obj, \n                       serp_exp = \"total\",\n                       gene_name = glist[x],\n                       coordinate_to_trans = T,\n                       do_reads_offset = T)\n  \n \n  obj &lt;- get_occupancy(object = obj, \n                       serp_exp = \"ip\",\n                       gene_name = glist[x],\n                       coordinate_to_trans = T,\n                       do_reads_offset = T)\n  \n  p &lt;-\n    enrichment_plot2(object = obj,\n                        smooth = TRUE, \n                        window_size = 15,\n                        mode = \"codon\",\n                        merge_rep = T,\n                        facet = ggplot2::facet_grid(~rname))\n  \n  return(p)\n}) -&gt; plist\n\n# combine\ncowplot::plot_grid(plotlist = plist, nrow = 2)\n\n\n\n\n\nGene-by-gene inspection revealed that the small discrepancy in substrate pools is largely due to subtle differences in enrichment factors that affect bioinformatic detection:\n\n\n\n\n\nglist &lt;- c(\"RPL30\", \"RPL7A\", \"PIR1\")\n\n# x = 1\nlapply(seq_along(glist), function(x){\n  obj &lt;- get_occupancy(object = obj, \n                       serp_exp = \"total\",\n                       gene_name = glist[x],\n                       coordinate_to_trans = T,\n                       do_reads_offset = T)\n  \n  \n  obj &lt;- get_occupancy(object = obj, \n                       serp_exp = \"ip\",\n                       gene_name = glist[x],\n                       coordinate_to_trans = T,\n                       do_reads_offset = T)\n  \n  p &lt;-\n    enrichment_plot2(object = obj,\n                     smooth = TRUE, \n                     window_size = 15,\n                     mode = \"codon\",\n                     merge_rep = T,\n                     facet = ggplot2::facet_grid(~rname))\n  \n  return(p)\n}) -&gt; plist\n\n# combine\ncowplot::plot_grid(plotlist = plist, nrow = 2)",
    "crumbs": [
      "More examples",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Profiling Ssb-Nascent Chain Interactions</span>"
    ]
  },
  {
    "objectID": "Profiling-Ssb-Nascent-Chain.html#ssb-targeted-proteins-metagene-profile",
    "href": "Profiling-Ssb-Nascent-Chain.html#ssb-targeted-proteins-metagene-profile",
    "title": "\n18  Profiling Ssb-Nascent Chain Interactions\n",
    "section": "\n18.4 Ssb targeted proteins metagene profile",
    "text": "18.4 Ssb targeted proteins metagene profile\nFigure 3B presents metagene binding profiles that characterize how the chaperone protein Ssb interacts with nascent polypeptide chains based on their subcellular localization — specifically, cytoplasmic/nuclear, mitochondrial, and ER-targeted proteins:\n\n\n\n\n\n18.4.1 Download protein category data\nFirst, we download the gene classification data provided in the article from the following link:https://www.cell.com/cms/10.1016/j.cell.2017.06.038/attachment/24190c7e-ed24-4329-9349-fe9c72386983/mmc1.xlsx\nThen, we import and examine the content of the “protein categories” sheet using the readxl package, skipping the first 14 rows which contain metadata or descriptions:\n\npc &lt;- readxl::read_xlsx(\"../mmc1.xlsx\",sheet = \"protein categories\",\n                        skip = 14)\n\n# check\nhead(pc)\n# # A tibble: 6 × 11\n# cytoplasmic, nuclear …¹ mitochondrial protei…² `ER-targeted proteins` SRP-dependent protei…³ SRP-independent prot…⁴\n#   &lt;chr&gt;                   &lt;chr&gt;                  &lt;chr&gt;                  &lt;chr&gt;                  &lt;chr&gt;                 \n# 1 YPL191C                 YNL003C                YPL051W                YMR058W                YJL052C-A             \n# 2 YJL179W                 YIL124W                YBL102W                YHR138C                YNL238W               \n# 3 YNL288W                 YKL029C                YIL048W                YJR116W                YDR246W-A             \n# 4 YPL144W                 YNR045W                YPL195W                YFR035C                YPL189W               \n# 5 YHR112C                 YNR018W                YGL223C                YML132W                YLR120C               \n# 6 YKR084C                 YKR064W                YDR137W                YJL127C-B              YMR305C               \n# # ℹ abbreviated names: ¹​`cytoplasmic, nuclear proteins`, ²​`mitochondrial proteins`, ³​`SRP-dependent proteins`,\n# #   ⁴​`SRP-independent proteins`\n# # ℹ 6 more variables: `SND-pathway proteins (used for Fig. 3A)` &lt;chr&gt;,\n# #   `SND-pathway proteins (used for Fig. S3F)` &lt;chr&gt;, `Tail-anchored proteins` &lt;chr&gt;,\n# #   `unclassified ER-targeted proteins` &lt;chr&gt;, `SRP substrates (with distinct peak)` &lt;chr&gt;,\n# #   `SRP substrates (pre-recruitment)` &lt;chr&gt;\n\n\n18.4.2 Calculation and visualization\nThen calculate and process the gene names for each gene category:\n\n# choose ssb1 for analysis\nobj2 &lt;- subset_data(object = obj, sample %in% c(\"ssb1_rep1\", \"ssb1_rep2\"))\n\n# gene features\nft &lt;- obj2@features\n\n# get gene list\ncyto_nuc &lt;- ft %&gt;% \n  dplyr::filter(transcript_id %in% paste(pc$`cytoplasmic, nuclear proteins`,\"_mRNA\",sep = \"\"))\n \nmito &lt;-  ft %&gt;% \n  dplyr::filter(transcript_id %in% paste(pc$`mitochondrial proteins`,\"_mRNA\",sep = \"\"))\n\ner &lt;-  ft %&gt;% \n  dplyr::filter(transcript_id %in% paste(pc$`ER-targeted proteins`,\"_mRNA\",sep = \"\"))\n\ntranlatome &lt;- ft\n\n# groups\ngp &lt;- c(\"cyto_nuc\", \"mito\", \"ER\", \"translatome\")\nglist &lt;- list(cyto_nuc$gene, mito$gene, er$gene, tranlatome$gene)\n\nFinally, calculate and plot the metagene profile data for genes of different categories:\n\n# loop get data\n# x = 1\nlapply(seq_along(gp), function(x){\n  mt &lt;- metagene_plot(object = obj2,\n                      selected_genes = glist[[x]],\n                      mode = \"codon\",\n                      rel2st_dist = c(-50, 1500),\n                      return_data = T)\n  \n  mt$group &lt;- gp[x]\n  mt$tp &lt;- sapply(strsplit(mt$sample,split = \"-\"),\"[\",2)\n  \n  if(gp[x] == \"translatome\"){\n    mt &lt;- subset(mt, tp == \"total\")\n  }else{\n    mt &lt;- subset(mt, tp == \"ip\")\n  }\n  \n  return(mt)\n}) %&gt;% do.call(\"rbind\",.) %&gt;% data.frame() -&gt; mts\n\n# plot\n# add groups\nmts$gp &lt;- sapply(strsplit(mts$sample,split = \"_\"),\"[\",1)\nmts$rep &lt;- sapply(strsplit(mts$sample,split = \"_|-\"),\"[\",2)\n\n# plot\nggplot(mts) +\n  geom_line(aes(x = rel,y = avg,colour = group)) +\n  facet_grid(rep~gp) +\n  theme_bw() +\n  theme(axis.text = element_text(colour = \"black\"),\n        panel.grid = element_blank(),\n        strip.text = element_text(face = \"bold\",size = rel(1))) +\n  xlab(\"Codons / amino acids\") +\n  ylab(\"Mean read density [AU]\") +\n  scale_color_brewer(palette = \"Set2\")",
    "crumbs": [
      "More examples",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Profiling Ssb-Nascent Chain Interactions</span>"
    ]
  },
  {
    "objectID": "Profiling-Ssb-Nascent-Chain.html#impact-of-rac-on-co-translational-ssb-function",
    "href": "Profiling-Ssb-Nascent-Chain.html#impact-of-rac-on-co-translational-ssb-function",
    "title": "\n18  Profiling Ssb-Nascent Chain Interactions\n",
    "section": "\n18.5 Impact of RAC on co-translational ssb function",
    "text": "18.5 Impact of RAC on co-translational ssb function\nBy integrating ribosome profiling data with enrichment analysis and motif identification, the study maps Ssb interactions with high resolution and reveals its coordination with translation elongation and nascent chain folding. This provides a comprehensive understanding of Ssb’s role as a chaperone in co-translational protein folding:\n\n\n\n\n\n18.5.1 Serp object construction\nWe reconstructed the relevant samples into SeRP objects for subsequent analyses:\n\n# total bamfiles\ntt.bam &lt;- c(\"WT_Ssb1-GFP_translatome_rep1.bam\",\n            \"WT_Ssb1-GFP_translatome_rep2.bam\",\n            \"WT_Ssb2-GFP_translatome_rep1.bam\",\n            \"WT_Ssb2-GFP_translatome_rep2.bam\",\n            \"RAC_Ssb1-GFP_translatome_rep1.bam\",\n            \"RAC_Ssb1-GFP_translatome_rep2.bam\",\n            \"RAC_Ssb2-GFP_translatome_rep1.bam\",\n            \"RAC_Ssb2-GFP_translatome_rep2.bam\",\n            \"NAC_Ssb1-GFP_translatome_rep1.bam\",\n            \"NAC_Ssb1-GFP_translatome_rep2.bam\",\n            \"NAC_Ssb2-GFP_translatome_rep1.bam\",\n            \"NAC_Ssb2-GFP_translatome_rep2.bam\")\n\n# interactome bam files\nip.bam &lt;- c(\"WT_Ssb1_interactome_rep1.bam\",\n            \"WT_Ssb1_interactome_rep2.bam\",\n            \"WT_Ssb2_interactome_rep1.bam\",\n            \"WT_Ssb2_interactome_rep2.bam\",\n            \"RAC_Ssb1_interactome_rep1.bam\",\n            \"RAC_Ssb1_interactome_rep2.bam\",\n            \"RAC_Ssb2_interactome_rep1.bam\",\n            \"RAC_Ssb2_interactome_rep2.bam\",\n            \"NAC_Ssb1_interactome_rep1.bam\",\n            \"NAC_Ssb1_interactome_rep2.bam\",\n            \"NAC_Ssb2_interactome_rep1.bam\",\n            \"NAC_Ssb2_interactome_rep2.bam\")\n\n\n# construct_serp\nobj &lt;- construct_serp(genome_file = \"../../index-data/Saccharomyces_cerevisiae.R64-1-1.dna.toplevel.fa\",\n                      gtf_file = \"../../index-data/Saccharomyces_cerevisiae.R64-1-1.112.gtf\",\n                      mapping_type = \"genome\",\n                      assignment_mode = \"end5\",\n                      extend = TRUE,\n                      extend_upstream = 50,\n                      extend_downstream = 50,\n                      total_bam_file = tt.bam,\n                      total_sample_name = c(\"Ssb1_rep1\",\"Ssb1_rep2\",\n                                            \"Ssb2_rep1\",\"Ssb2_rep2\",\n                                            \"RAC_Ssb1_rep1\",\"RAC_Ssb1_rep2\",\n                                            \"RAC_Ssb2_rep1\",\"RAC_Ssb2_rep2\",\n                                            \"NAC_Ssb1_rep1\",\"NAC_Ssb1_rep2\",\n                                            \"NAC_Ssb2_rep1\",\"NAC_Ssb2_rep2\"),\n                      total_sample_group = c(\"Ssb1\",\"Ssb1\",\"Ssb2\",\"Ssb2\",\n                                             \"RAC_Ssb1\",\"RAC_Ssb1\",\"RAC_Ssb2\",\"RAC_Ssb2\",\n                                             \"NAC_Ssb1\",\"NAC_Ssb1\",\"NAC_Ssb2\",\"NAC_Ssb2\"),\n                      IP_bam_file = ip.bam,\n                      IP_sample_name = c(\"Ssb1_rep1\",\"Ssb1_rep2\",\n                                         \"Ssb2_rep1\",\"Ssb2_rep2\",\n                                         \"RAC_Ssb1_rep1\",\"RAC_Ssb1_rep2\",\n                                         \"RAC_Ssb2_rep1\",\"RAC_Ssb2_rep2\",\n                                         \"NAC_Ssb1_rep1\",\"NAC_Ssb1_rep2\",\n                                         \"NAC_Ssb2_rep1\",\"NAC_Ssb2_rep2\"),\n                      IP_sample_group = c(\"Ssb1\",\"Ssb1\",\"Ssb2\",\"Ssb2\",\n                                          \"RAC_Ssb1\",\"RAC_Ssb1\",\"RAC_Ssb2\",\"RAC_Ssb2\",\n                                          \"NAC_Ssb1\",\"NAC_Ssb1\",\"NAC_Ssb2\",\"NAC_Ssb2\"),\n                      choose_longest_trans = T)\n\n\n\n\n# generate summary data for QC or other analysis\nobj &lt;- generate_summary(object = obj, \n                        exp_type = c(\"total\",\"ip\"), \n                        nThreads = 60)\n\n\n18.5.2 Adding offset information\n\n# offset correction\nsp &lt;- c(\"Ssb1_rep1\",\"Ssb1_rep2\",\n        \"Ssb2_rep1\",\"Ssb2_rep2\",\n        \"RAC_Ssb1_rep1\",\"RAC_Ssb1_rep2\",\n        \"RAC_Ssb2_rep1\",\"RAC_Ssb2_rep2\",\n        \"NAC_Ssb1_rep1\",\"NAC_Ssb1_rep2\",\n        \"NAC_Ssb2_rep1\",\"NAC_Ssb2_rep2\")\n\noffset &lt;- data.frame(sample = rep(c(paste(sp,\"total\",sep = \"-\"),paste(sp,\"ip\",sep = \"-\")),\n                                  each = 16),\n                     qwidth = rep(20:35,24),\n                     rel_pos = rep(c(rep(15,11),rep(16,5)),24))\n\n\nobj@reads_offset_info &lt;- offset\n\n\n18.5.3 Metagene profile for RAC depletion\nUse the subset_data function to filter and analyze samples with Ssb and RAC deletions:\n\n# ==============================================================================\n# choose RAC and ssb for analysis\nobj2 &lt;- subset_data(object = obj, sample_group %in% c(\"Ssb1\", \"Ssb2\", \"RAC_Ssb1\",\"RAC_Ssb2\"))\n\nmt &lt;- metagene_plot(object = obj2,\n                    mode = \"codon\",\n                    rel2st_dist = c(-50, 1500),\n                    return_data = T)\n\n# add groups\nmt$gp &lt;- sapply(strsplit(mt$sample,split = \"_\"),\"[\",1)\nmt$tp &lt;- sapply(strsplit(mt$sample,split = \"-\"),\"[\",2)\n\nmt &lt;- mt %&gt;% \n  dplyr::mutate(rep = dplyr::case_when(startsWith(sample, \"Ssb\") ~ sapply(strsplit(sample,split = \"_|-\"),\"[\",2),\n                                       !startsWith(sample, \"Ssb\") ~ sapply(strsplit(sample,split = \"_|-\"),\"[\",3),\n                                       )) %&gt;% \n  dplyr::mutate(ft = dplyr::case_when(startsWith(sample, \"Ssb\") ~ sapply(strsplit(sample,split = \"_\"),\"[\",1),\n                                       !startsWith(sample, \"Ssb\") ~ sapply(strsplit(sample,split = \"_\"),\"[\",2),\n  ))\n\n\n# plot\nggplot(mt) +\n  geom_line(aes(x = rel,y = avg,colour = sample)) +\n  facet_grid(ft~rep) +\n  theme_bw() +\n  theme(axis.text = element_text(colour = \"black\"),\n        panel.grid = element_blank(),\n        strip.text = element_text(face = \"bold\",size = rel(1))) +\n  xlab(\"Codons / amino acids\") +\n  ylab(\"Mean read density [AU]\") +\n  guides(color = guide_legend(ncol = 2))\n\n\n\n\n\n\n18.5.4 Ssb1 interaction profiles for exemplary proteins\nThe authors presented the interaction profiles of Ssb1 for the exemplary genes ssc1 and cbf5. They observed that the deletion of RAC significantly influenced the co-translational binding dynamics of Ssb, leading to altered binding distributions and a notable delay in its engagement with nascent chains. To showcase these effects and deepen our understanding, we extracted the data to visualize the binding profiles of Ssb1 and Ssb2 in the context of RAC deletion:\n\nglist &lt;- c(\"SSC1\", \"CBF5\")\n\n# x = 1\nlapply(seq_along(glist), function(x){\n  obj2 &lt;- get_occupancy(object = obj2, \n                       serp_exp = \"total\",\n                       gene_name = glist[x],\n                       coordinate_to_trans = T,\n                       do_reads_offset = T)\n  \n  \n  obj2 &lt;- get_occupancy(object = obj2, \n                       serp_exp = \"ip\",\n                       gene_name = glist[x],\n                       coordinate_to_trans = T,\n                       do_reads_offset = T)\n  \n  pdf &lt;-\n    enrichment_plot2(object = obj2,\n                     smooth = TRUE, \n                     window_size = 15,\n                     mode = \"codon\",\n                     merge_rep = T,\n                     facet = ggplot2::facet_grid(~rname),\n                     return_data = T)\n  \n  return(pdf)\n}) %&gt;% do.call(\"rbind\",.) %&gt;% data.frame() -&gt; pdf\n\n# re-plot\n\npdf$gp &lt;- sapply(strsplit(pdf$sample,split = \"_\"),\"[\",2)\n\npdf &lt;- pdf %&gt;% \n  dplyr::mutate(gp = ifelse(is.na(gp), sample, gp))\n\n# check\n# head(pdf)\n#     sample             rname pos     rpm.x     rpm.y sm1 sm2 sd smratio   gp\n# 1 RAC_Ssb1 YJR045C_mRNA|SSC1   1 0.8387263 0.5019538   0   0  0       0 Ssb1\n# 2 RAC_Ssb1 YJR045C_mRNA|SSC1   2 0.6155070 0.3005195   0   0  0       0 Ssb1\n# 3 RAC_Ssb1 YJR045C_mRNA|SSC1   3 0.2795754 0.1721372   0   0  0       0 Ssb1\n# 4 RAC_Ssb1 YJR045C_mRNA|SSC1   4 0.2795754 0.2426880   0   0  0       0 Ssb1\n# 5 RAC_Ssb1 YJR045C_mRNA|SSC1   5 0.5012232 0.2881815   0   0  0       0 Ssb1\n# 6 RAC_Ssb1 YJR045C_mRNA|SSC1   6 1.3352958 0.6264777   0   0  0       0 Ssb1\n\nplotting data:\n\n# plot\nggplot(pdf) +\n  geom_ribbon(aes(ymin = smratio - sd,\n                  ymax = smratio + sd,\n                  x = pos,y = smratio,\n                  fill = sample), alpha = 0.5) +\n  geom_line(aes(x = pos,y = smratio, color = sample)) +\n  geom_hline(yintercept = 1,lty = \"dashed\",color = \"black\") +\n  facet_grid(gp~rname,scales = \"free\") +\n  theme_bw() +\n  theme(panel.grid = element_blank(),\n        axis.text = element_text(colour = \"black\"),\n        strip.text.y.left = element_text(angle = 0, hjust = 1),\n        strip.background = element_blank(),\n        strip.text = element_text(face = \"bold\"),\n        strip.placement = \"outside\",\n        ggside.panel.background = element_blank(),\n        ggside.panel.border = element_blank()) +\n  xlab(\"Ribosome position (codons / amino acids)\") +\n  ylab(\"Mean enrichment (IP / total)[AU]\") +\n  scale_color_brewer(palette = \"Set2\") +\n  scale_fill_brewer(palette = \"Set2\")",
    "crumbs": [
      "More examples",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Profiling Ssb-Nascent Chain Interactions</span>"
    ]
  },
  {
    "objectID": "Profiling-Ssb-Nascent-Chain.html#interplay-of-ssb-and-nac",
    "href": "Profiling-Ssb-Nascent-Chain.html#interplay-of-ssb-and-nac",
    "title": "\n18  Profiling Ssb-Nascent Chain Interactions\n",
    "section": "\n18.6 Interplay of ssb and NAC",
    "text": "18.6 Interplay of ssb and NAC\nThese findings in figure 6 demonstrate that NAC synergistically promotes broader Ssb binding to nascent chains by increasing the number and intensity of Ssb-binding events. However, the absence of NAC does not alter Ssb’s substrate selectivity or the positional characteristics of its binding sites:\n\n\n\n\n\n18.6.1 Metagene profile for NAC depletion\nFilter NAC samples, with the analysis workflow similar to the above:\n\n# ==============================================================================\n# choose NAC and ssb for analysis\nobj3 &lt;- subset_data(object = obj, sample_group %in% c(\"Ssb1\", \"Ssb2\", \"NAC_Ssb1\",\"NAC_Ssb2\"))\n\nmt &lt;- metagene_plot(object = obj3,\n                    mode = \"codon\",\n                    rel2st_dist = c(-50, 1500),\n                    return_data = T)\n\n# add groups\nmt$gp &lt;- sapply(strsplit(mt$sample,split = \"_\"),\"[\",1)\nmt$tp &lt;- sapply(strsplit(mt$sample,split = \"-\"),\"[\",2)\n\nmt &lt;- mt %&gt;% \n  dplyr::mutate(rep = dplyr::case_when(startsWith(sample, \"Ssb\") ~ sapply(strsplit(sample,split = \"_|-\"),\"[\",2),\n                                       !startsWith(sample, \"Ssb\") ~ sapply(strsplit(sample,split = \"_|-\"),\"[\",3),\n  )) %&gt;% \n  dplyr::mutate(ft = dplyr::case_when(startsWith(sample, \"Ssb\") ~ sapply(strsplit(sample,split = \"_\"),\"[\",1),\n                                      !startsWith(sample, \"Ssb\") ~ sapply(strsplit(sample,split = \"_\"),\"[\",2),\n  ))\n\n# plot\nggplot(mt) +\n  geom_line(aes(x = rel,y = avg,colour = sample)) +\n  facet_grid(ft~rep) +\n  theme_bw() +\n  theme(axis.text = element_text(colour = \"black\"),\n        panel.grid = element_blank(),\n        strip.text = element_text(face = \"bold\",size = rel(1))) +\n  xlab(\"Codons / amino acids\") +\n  ylab(\"Mean read density [AU]\") +\n  guides(color = guide_legend(ncol = 2))\n\n\n\n\n\n\n18.6.2 Ssb1 interaction profiles\n\n# ==============================================================================\nglist &lt;- c(\"CDC19\", \"PMT1\", \"PDI1\")\n\n# x = 1\nlapply(seq_along(glist), function(x){\n  obj3 &lt;- get_occupancy(object = obj3, \n                        serp_exp = \"total\",\n                        gene_name = glist[x],\n                        coordinate_to_trans = T,\n                        do_reads_offset = T)\n  \n  \n  obj3 &lt;- get_occupancy(object = obj3, \n                        serp_exp = \"ip\",\n                        gene_name = glist[x],\n                        coordinate_to_trans = T,\n                        do_reads_offset = T)\n  \n  pdf &lt;-\n    enrichment_plot2(object = obj3,\n                     smooth = TRUE, \n                     window_size = 15,\n                     mode = \"codon\",\n                     merge_rep = T,\n                     facet = ggplot2::facet_grid(~rname),\n                     return_data = T)\n  \n  return(pdf)\n}) %&gt;% do.call(\"rbind\",.) %&gt;% data.frame() -&gt; pdf\n\n# re-plot\n\npdf$gp &lt;- sapply(strsplit(pdf$sample,split = \"_\"),\"[\",2)\n\npdf &lt;- pdf %&gt;% \n  dplyr::mutate(gp = ifelse(is.na(gp), sample, gp))\n\n# plot\nggplot(pdf) +\n  geom_ribbon(aes(ymin = smratio - sd,\n                  ymax = smratio + sd,\n                  x = pos,y = smratio,\n                  fill = sample), alpha = 0.5) +\n  geom_line(aes(x = pos,y = smratio, color = sample)) +\n  geom_hline(yintercept = 1,lty = \"dashed\",color = \"black\") +\n  facet_grid(gp~rname,scales = \"free\") +\n  theme_bw() +\n  theme(panel.grid = element_blank(),\n        axis.text = element_text(colour = \"black\"),\n        strip.text.y.left = element_text(angle = 0, hjust = 1),\n        strip.background = element_blank(),\n        strip.text = element_text(face = \"bold\"),\n        strip.placement = \"outside\",\n        ggside.panel.background = element_blank(),\n        ggside.panel.border = element_blank()) +\n  xlab(\"Ribosome position (codons / amino acids)\") +\n  ylab(\"Mean enrichment (IP / total)[AU]\") +\n  scale_color_brewer(palette = \"Set2\") +\n  scale_fill_brewer(palette = \"Set2\")",
    "crumbs": [
      "More examples",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Profiling Ssb-Nascent Chain Interactions</span>"
    ]
  },
  {
    "objectID": "Serp-Object.html#offset-correction",
    "href": "Serp-Object.html#offset-correction",
    "title": "\n5  Serp object\n",
    "section": "\n5.5 Offset correction",
    "text": "5.5 Offset correction\nFor accurate mapping of ribosome positions (P-sites), we manually assign offset values for reads of different fragment lengths. These offsets align the 5’ end of each read to the corresponding position within a ribosome, ensuring precise localization on transcripts:\n\n# Define sample names\nsp &lt;- c(\"ssb1_rep1\", \"ssb1_rep2\", \"ssb2_rep1\", \"ssb2_rep2\")\n\n# Create a data frame specifying the offset (A-site position) \n# for each read length (20–35 nt) and sample\noffset &lt;- data.frame(\n  sample  = rep(c(paste(sp, \"total\", sep = \"-\"), paste(sp, \"ip\", sep = \"-\")), each = 16),\n  qwidth  = rep(20:35, 8),\n  rel_pos = rep(c(rep(15, 11), rep(16, 5)), 8)  # Set offset by read length\n)\n\n# Preview the offset table\nhead(offset)\n#              sample qwidth rel_pos\n# 1 ssb1_rep1-total     20      15\n# 2 ssb1_rep1-total     21      15\n# 3 ssb1_rep1-total     22      15\n# 4 ssb1_rep1-total     23      15\n# 5 ssb1_rep1-total     24      15\n# 6 ssb1_rep1-total     25      15\n\nobj@reads_offset_info &lt;- offset",
    "crumbs": [
      "Object construction",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Serp object</span>"
    ]
  },
  {
    "objectID": "Enrichment-analysis.html",
    "href": "Enrichment-analysis.html",
    "title": "Enrichment analysis",
    "section": "",
    "text": "Introduction\nThe enrichment analysis aims to identify potential co-translation events, similar to the strategy employed by Ayala Shiber et al. in their study of ribosome-associated interactions. This approach allows us to detect transcripts that are preferentially enriched in immunoprecipitated ribosome fractions, potentially indicating co-translational binding or complex assembly occurring during translation.\nTo perform this analysis, two input datasets are required:\nBy comparing the read coverage at each nucleotide across open reading frames (ORFs) between the total and IP translatome datasets, EA quantifies the relative enrichment of transcripts in the IP sample. This ratio-based enrichment can reveal specific mRNAs that are co-translationally associated with the IP target, pointing to possible physical interactions or functional coupling at the level of translation.",
    "crumbs": [
      "Enrichment analysis"
    ]
  },
  {
    "objectID": "Enrichment-analysis.html#introduction",
    "href": "Enrichment-analysis.html#introduction",
    "title": "Enrichment analysis",
    "section": "",
    "text": "Total Translatome File — This file represents the global translation profile, typically obtained through ribosome profiling of whole-cell lysates. It serves as a reference or background against which enrichment can be measured.\nIP Translatome File — This file contains translation data derived from immunoprecipitated (IP) ribosome complexes, often obtained via affinity purification techniques targeting proteins of interest. This dataset reflects transcripts that are associated with the protein or complex under investigation.\n\n\n1. Gene-Level Enrichment\nThe gene-level enrichment is defined as the ratio of normalized ribosome profiling (Ribo-seq) reads in the immunoprecipitated (IP) sample to those in the total translatome sample, for the entire open reading frame (ORF) of a given gene. This provides a summary measure of how much a given transcript is enriched in the IP fraction relative to the background.\nThe formula is as follows:\n\\[\n\\text{Enrichment}_{\\text{gene}} = \\frac{\\text{RPM}_{\\text{IP (total ORF)}}}{\\text{RPM}_{\\text{Total (total ORF)}}}\n\\]\nWhere:\n- RPM: Reads per million mapped reads\n- IP: The immunoprecipitation (experiment) sample\n- Total: The input control sample (total translatome)\nAlternatively, we can use the total Ribo-seq data as a control group and apply differential expression analysis tools such as DESeq2 or edgeR to identify genes significantly enriched in the IP Ribo-seq data.\n2. Nucleotide-Level Enrichment\nFor nucleotide-level enrichment, enrichment ratios are calculated at each nucleotide position (typically the footprint 5’ end) on the ORF:\n\\[\n\\text{Enrichment}_{i} = \\frac{\\text{RPM}_{\\text{IP},i}}{\\text{RPM}_{\\text{Total},i}}\n\\]\nWhere ( i ) represents the nucleotide position within the ORF.\nBecause Ribo-seq data are often sparse at single-nucleotide resolution, we apply a fixed-length sliding window approach (e.g., 45 nucleotides, equivalent to 15 codons). This smooths local variation and improves signal detection.\nFor each window ( W ) centered at position ( j ), the smoothed enrichment is:\n\\[\n\\text{Enrichment}_{W_j} = \\frac{\\sum_{i \\in W_j} \\text{RPM}_{\\text{IP},i}}{\\sum_{i \\in W_j} \\text{RPM}_{\\text{Total},i}}\n\\]\n\nWindow size: 45 nt\n\nStep size: Typically 1 or more depending on resolution needed\n\nThe window moves along the ORF from 5’ to 3’ end\n\nThis positional analysis enables the identification of localized peaks of enrichment that may correspond to co-translational interaction sites (e.g., domain emergence, complex assembly hotspots).",
    "crumbs": [
      "Enrichment analysis"
    ]
  },
  {
    "objectID": "Enrichment-analysis.html#ribosome-density-calculation",
    "href": "Enrichment-analysis.html#ribosome-density-calculation",
    "title": "Enrichment analysis",
    "section": "Ribosome density calculation",
    "text": "Ribosome density calculation\nThe get_occupancy function can be used to extract and calculate the ribosome density of genes of interest from a serp object. By leveraging the previously assigned read offset information, it enables accurate correction of read positions to infer the ribosomal A-site locations:\n\n# Total translatome occupancy\nobj &lt;- get_occupancy(object = obj, \n                     serp_exp = \"total\",\n                     gene_name = \"CCT3\",\n                     coordinate_to_trans = T,\n                     do_reads_offset = T)\n\n# check\nhead(obj@total_occupancy)\n# # A tibble: 6 × 7\n#   sample    sample_group rname               pos count    rpm smooth\n#   &lt;chr&gt;     &lt;chr&gt;        &lt;chr&gt;             &lt;dbl&gt; &lt;int&gt;  &lt;dbl&gt;  &lt;dbl&gt;\n# 1 ssb1_rep1 ssb1         YJL014W_mRNA|CCT3   -14     2 0.0515 0.0515\n# 2 ssb1_rep1 ssb1         YJL014W_mRNA|CCT3   -13     1 0.0258 0.0258\n# 3 ssb1_rep1 ssb1         YJL014W_mRNA|CCT3     5     1 0.0258 0.0258\n# 4 ssb1_rep1 ssb1         YJL014W_mRNA|CCT3     8     1 0.0258 0.0258\n# 5 ssb1_rep1 ssb1         YJL014W_mRNA|CCT3     9     1 0.0258 0.0258\n# 6 ssb1_rep1 ssb1         YJL014W_mRNA|CCT3    12     1 0.0258 0.0258\n\n# IP translatome occupancy\nobj &lt;- get_occupancy(object = obj, \n                     serp_exp = \"ip\",\n                     gene_name = \"CCT3\",\n                     coordinate_to_trans = T,\n                     do_reads_offset = T)\n\n# check\nhead(obj@ip_occupancy)\n# # A tibble: 6 × 7\n#   sample    sample_group rname               pos count    rpm smooth\n#  &lt;chr&gt;     &lt;chr&gt;        &lt;chr&gt;             &lt;dbl&gt; &lt;int&gt;  &lt;dbl&gt;  &lt;dbl&gt;\n# 1 ssb1_rep1 ssb1         YJL014W_mRNA|CCT3   -14     4 0.111  0.111 \n# 2 ssb1_rep1 ssb1         YJL014W_mRNA|CCT3   -13     1 0.0277 0.0277\n# 3 ssb1_rep1 ssb1         YJL014W_mRNA|CCT3     6     1 0.0277 0.0277\n# 4 ssb1_rep1 ssb1         YJL014W_mRNA|CCT3    10     2 0.0554 0.0554\n# 5 ssb1_rep1 ssb1         YJL014W_mRNA|CCT3    20     1 0.0277 0.0277\n# 6 ssb1_rep1 ssb1         YJL014W_mRNA|CCT3    21     4 0.111  0.111",
    "crumbs": [
      "Enrichment analysis"
    ]
  },
  {
    "objectID": "Enrichment-analysis.html#ribosome-density-visualization",
    "href": "Enrichment-analysis.html#ribosome-density-visualization",
    "title": "Enrichment analysis",
    "section": "Ribosome density visualization",
    "text": "Ribosome density visualization\nThe trans_plot function is used to visualize the ribosome density profiles from both IP and total Ribo-seq datasets:\n\ntrans_plot(object = obj)\n\n\n\n\n\nDisplay UTR regions and set the x-axis units to nucleotides (nt) instead of codons:\n\ntrans_plot(object = obj, retain_cds = F, mode = \"nt\")\n\n\n\n\n\nAdd a new y-axis range label:\n\ntrans_plot(object = obj, new_signal_range = T)\n\n\n\n\n\nMerge biological replicates, with the shaded area representing the variance among replicates:\n\ntrans_plot(object = obj, merge_rep = T)",
    "crumbs": [
      "Enrichment analysis"
    ]
  },
  {
    "objectID": "Enrichment-analysis.html#enrichment-visualization",
    "href": "Enrichment-analysis.html#enrichment-visualization",
    "title": "Enrichment analysis",
    "section": "Enrichment visualization",
    "text": "Enrichment visualization\nWe use a sliding window approach to calculate and visualize the IP-to-total enrichment ratio along the transcript. The enrichment_plot2 function computes the fold enrichment and generates a track plot. In this example, we set the x-axis units to codons and apply a sliding window of 15 codons:\n\nenrichment_plot2(object = obj,\n                 smooth = TRUE, \n                 window_size = 15,\n                 mode = \"codon\",\n                 merge_rep = F)\n\n\n\n\n\nMerge biological replicates:\n\nenrichment_plot2(object = obj,\n                 smooth = TRUE, \n                 window_size = 15,\n                 mode = \"codon\",\n                 new_signal_range = T,\n                 merge_rep = T)\n\n\n\n\n\nCombine samples in a single plot without faceting:\n\nenrichment_plot2(object = obj,\n                 smooth = TRUE, \n                 window_size = 15,\n                 mode = \"codon\",\n                 merge_rep = T,\n                 facet = ggplot2::facet_grid(~rname))\n\n\n\n\n\nChange the x-axis to nucleotide (nt) positions:\n\nenrichment_plot2(object = obj,\n                 smooth = TRUE, \n                 window_size = 45,\n                 retain_cds = F,\n                 facet = ggplot2::facet_grid(~rname),\n                 mode = \"nt\")\n\n\n\n\n\nConfidence interval (CI) according to Agresti and Coull\nThe enrichment_plot1 function calculates a 95% confidence interval (CI) for ( p_i ) using the Agresti-Coull method, as described in paper “Interactions between nascent proteins translated by adjacent ribosomes drive homomer assembly”. This approach provides reliable CIs for proportion data, especially in cases of small sample sizes. The function utilizes sliding windows to smooth the data from IP and Total datasets at each position for each sample.\nAgresti-Coull Method Overview\nThe Agresti-Coull method adjusts the proportion ( p_i ) for more accurate calculation of confidence intervals. Here’s how the method works:\nAdjusted Proportion Calculation\nThe adjusted proportion is defined as:\n\\[\n\\tilde{p}_i = \\frac{x + z^2 / 2}{n + z^2}\n\\]\nwhere:\n\n( x ): Sliding window’s count of IPs (win_ip),\n( n ): Total count (win_ip + win_total),\n( z ): Critical value from the standard normal distribution (( z = 1.96 ) for 95% CI).\nConfidence Interval Calculation\nThe 95% confidence interval is then calculated as:\n\\[\n\\tilde{p}_i \\pm z \\sqrt{\\frac{\\tilde{p}_i(1 - \\tilde{p}_i)}{n + z^2}}\n\\]\nThis adjustment ensures robust confidence intervals even for small samples or sparse data.\nVisualization\nDefault plot:\n\nenrichment_plot1(object = obj,\n                 window_size = 15,\n                 mode = \"codon\")\n\n\n\n\n\nDisplay enrichment fold-change in log2 scale:\n\nenrichment_plot1(object = obj,\n                 window_size = 15,\n                 mode = \"codon\",\n                 log2_transform = T)\n\n\n\n\n\nConvert the x-axis unit from codon to nucleotide (nt):\n\nenrichment_plot1(object = obj,\n                 window_size = 45,\n                 mode = \"nt\")\n\n\n\n\n\nRetain and display the UTR regions:\n\nenrichment_plot1(object = obj,\n                 window_size = 45,\n                 mode = \"nt\",\n                 retain_cds = F)\n\n\n\n\n\nCombine samples for a joint display:\n\nenrichment_plot1(object = obj,\n                 window_size = 15,\n                 mode = \"codon\",\n                 log2_transform = T,\n                 facet = facet_grid(.~rname,switch = \"y\"))\n\n\n\n\n\nChange sample colors:\n\nenrichment_plot1(object = obj,\n                 window_size = 15,\n                 mode = \"codon\",\n                 facet = facet_grid(.~rname,switch = \"y\"),\n                 sample_col = c(\"ssb1_rep1\" = \"#3A59D1\",\"ssb1_rep2\" = \"#3A59D1\",\n                                \"ssb2_rep1\" = \"#328E6E\",\"ssb2_rep2\" = \"#328E6E\"),\n                 shadow_alpha = c(0.05,0.1))",
    "crumbs": [
      "Enrichment analysis"
    ]
  },
  {
    "objectID": "Extract-sequence.html#extracting-longest-transcript-sequences",
    "href": "Extract-sequence.html#extracting-longest-transcript-sequences",
    "title": "\n2  Sequence Extraction\n",
    "section": "\n2.5 Extracting longest transcript sequences",
    "text": "2.5 Extracting longest transcript sequences\nThe get_longest_transcript function extracts the longest transcript sequence.\nThe selection criteria are as follows:\n1. Transcripts are first sorted by the length of their CDS (coding sequence), and the one with the longest CDS is selected.\n2. If multiple transcripts have the same CDS length, then the one with the longest full transcript sequence is chosen.\nHere is an example:\n\nlt &lt;- get_longest_transcript(genome_file = \"Homo_sapiens.GRCh38.dna.primary_assembly.fa\",\n                             gtf_file = \"Homo_sapiens.GRCh38.94.gtf.gz\",\n                             output_file = \"longest_trans.fa\")\n\nltfa &lt;- Biostrings::readDNAStringSet(\"longest_trans.fa\")\nltfa\n# DNAStringSet object of length 57169:\n#      width seq                                                                                         names               \n# [1]   1657 GTTAACTTGCCGTCAGCCTTTTCTTTGACCTCTTCTTTCTGTTC...GCACAGCTAGAGATCCTTTATTAAAAGCACACTGTTGGTTTCTG ENST00000456328|D...\n# [2]    712 GTGCACACGGCTCCCATGCGTTGTCTTCCGAGCGTCAGGCCGCC...AACTTGGACTTCCAAGCCTCCAGAACTGTGAGGGATAAATGTAT ENST00000473358|M...\n# [3]    138 GGATGCCCAGCTAGTTTGAATTTTAGATAAACAACGAATAATTT...AACATTATTGGTTGTTTATCTGAGATTCAGAATTAAGCATTTTA ENST00000607096|M...\n# [4]    840 GCGGTATCTAAATTTGTATTGATTGGACTTTCAAGCTCTTGGGA...CACCCCTGTCTAGGATCTACACATTAAGAAACAAAGACATGAAC ENST00000606857|O...\n# [5]   1414 AGCTATCTGAATTTCTCCTTCTCCTAAAAATGCACATCCTATGA...AAAAAGTATATATTTCTATCTAATGTGTGTATCTAATTAACAGC ENST00000642116|O...\n# ...    ... ...\n# [57165]    603 AAATCTGCTCCCGGGGGTATTCTTGACTTAAACAAGGTTGCAAC...AAGAAAATCCTCAGCAAAGTGAAGAATTGCTTGAAGTAAGCAAC ENST00000620795|A...\n# [57166]    603 AAATCTGCTCCCGGGGGTATTCTTGACTTAAACAAGGTTGCAAC...AAGAAAATCCTCAGCAAAGTGAAGAATTGCTTGAAGTAAGCAAC ENST00000615362|A...\n# [57167]   2404 GGCGGCTGGACGAGGACGCTCCGAGCCCAGCTCTCGAGAGTTCA...CGCCACTGCACTCCAGCCTGGGTGACAGAGCGAGACTCCGTCTC ENST00000617983|A...\n# [57168]   1213 CGCGAGGCGCGCCGCGATCGGGGACTGTCCTAAGACGGGCGGGG...CTCTGTGTGACCCAGAGAAATAAAGATGCCTCAGTGTGGCCCGC ENST00000613204|A...\n# [57169]   2405 GGTCTCACTCTGTTGCTGTCTTCACGGAGAGCAGGAGCAGAGGC...CTGGGGAGGCCTGCCTGGTCAATAAACCACTGTTCCTGCAGCTG ENST00000621424|A...\n\nThe function also returns detailed information for each selected transcript:\n\n# check\nhead(lt)\n# # A tibble: 6 × 10\n# # Groups:   gene [6]\n#   transcript_id   idnew                         utr5   cds  utr3 exonlen translen mstart mstop gene        \n#   &lt;chr&gt;           &lt;chr&gt;                        &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;   &lt;int&gt;    &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;       \n# 1 ENST00000609567 ENST00000609567|hsa-mir-1253     0     0     0     105      105      0     0 hsa-mir-1253\n# 2 ENST00000381638 ENST00000381638|ZZEF1          125  8883  2445   11456    11456    126  9008 ZZEF1       \n# 3 ENST00000617638 ENST00000617638|ZYXP1            0     0     0     118      118      0     0 ZYXP1       \n# 4 ENST00000322764 ENST00000322764|ZYX            345  1716   429    2493     2493    346  2061 ZYX         \n# 5 ENST00000294353 ENST00000294353|ZYG11B         145  2232  5713    8093     8093    146  2377 ZYG11B      \n# 6 ENST00000430329 ENST00000430329|ZYG11AP1         0     0     0     837      837      0     0 ZYG11AP1",
    "crumbs": [
      "Preprocessing introduction",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Sequence Extraction</span>"
    ]
  },
  {
    "objectID": "Metagene-plot.html#method-to-aggregate-data-for-each-position",
    "href": "Metagene-plot.html#method-to-aggregate-data-for-each-position",
    "title": "\n15  Metagene plot\n",
    "section": "\n15.2 Method to aggregate data for each position",
    "text": "15.2 Method to aggregate data for each position\nThe metagene_plot function supports three aggregation methods (“median”, “mean” and “sum”) to summarize ribosome‐density signals at each transcript position. Users can choose the method that best fits their analysis goals. The example data shown here are taken from the “Profiling-Ssb-Nascent-Chain” section—see that vignette for the complete data‐processing workflow:\n\nlibrary(ggplot2)\n\nmetagene_plot(object = obj,\n              mode = \"codon\",\n              rel2st_dist = c(-50, 1500),\n              facet_wrap = ggplot2::facet_wrap(~sample,nrow = 2),\n              method = \"median\")\n\n\n\n\n\nSet method = “mean”:\n\nmetagene_plot(object = obj,\n              mode = \"codon\",\n              rel2st_dist = c(-50, 1500),\n              facet_wrap = ggplot2::facet_wrap(~sample,nrow = 2),\n              method = \"mean\")\n\n\n\n\n\nSet method = “sum”:\n\nmetagene_plot(object = obj,\n              mode = \"codon\",\n              rel2st_dist = c(-50, 1500),\n              facet_wrap = ggplot2::facet_wrap(~sample,nrow = 2),\n              method = \"sum\")\n\n\n\n\n\nMerge replicates:\n\nmetagene_plot(object = obj,\n              mode = \"codon\",\n              rel2st_dist = c(-50, 1500),\n              method = \"median\",\n              merge_rep = T)\n\n\n\n\n\nDo 1000 bootstraps to add 95% confidence intervals:\n\nmetagene_plot(object = obj,\n              mode = \"codon\",\n              rel2st_dist = c(-50, 1500),\n              method = \"median\",\n              facet_wrap = ggplot2::facet_wrap(~sample,nrow = 2),\n              do_bootstrap = T)",
    "crumbs": [
      "Quality assessment",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Metagene plot</span>"
    ]
  },
  {
    "objectID": "Metagene-plot.html#enrichment-metagene-analysis",
    "href": "Metagene-plot.html#enrichment-metagene-analysis",
    "title": "\n15  Metagene plot\n",
    "section": "\n15.3 Enrichment metagene analysis",
    "text": "15.3 Enrichment metagene analysis\nWe create metagene plots by analyzing the ratio of ribosome density in IP samples compared to total samples at positions relative to start codons or stop codons across genes from selective ribosome profiling data. The enrichment_metagene_plot function maintains most parameters consistent with the metagene_plot function.\nDefault plot:\n\nenrichment_metagene_plot(object = obj,\n                         mode = \"codon\",\n                         rel2st_dist = c(-50, 1500),\n                         facet_wrap = ggplot2::facet_wrap(~sample,nrow = 2),\n                         method = \"median\")\n\n\n\n\n\nSet method = “sum”:\n\nenrichment_metagene_plot(object = obj,\n                         mode = \"codon\",\n                         rel2st_dist = c(-50, 1500),\n                         facet_wrap = ggplot2::facet_wrap(~sample,nrow = 2),\n                         method = \"sum\")\n\n\n\n\n\nMerge replicates:\n\nenrichment_metagene_plot(object = obj,\n                         mode = \"codon\",\n                         rel2st_dist = c(-50, 1500),\n                         method = \"median\",\n                         merge_rep = T)\n\n\n\n\n\nDo bootstraps to add 95% confidence interval:\n\nenrichment_metagene_plot(object = obj,\n                         mode = \"codon\",\n                         rel2st_dist = c(-50, 1500),\n                         method = \"median\",\n                         facet_wrap = ggplot2::facet_wrap(~sample,nrow = 2),\n                         do_bootstrap = T)",
    "crumbs": [
      "Quality assessment",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Metagene plot</span>"
    ]
  },
  {
    "objectID": "Binding-peaks-detection.html",
    "href": "Binding-peaks-detection.html",
    "title": "Binding region detection",
    "section": "",
    "text": "Introduction\nSelective Ribosome Profiling (SeRP) is a powerful technique used to identify RNA regions that are bound by specific ribosome-associated factors, such as RNA-binding proteins or specialized ribosomal subunits. In contrast to traditional ribosome profiling, which captures all translating ribosomes on mRNAs, SeRP enriches for a subset of ribosomes engaged in specific interactions, enabling the discovery of functionally important regulatory sites at nucleotide or codon resolution.\nIdentifying binding regions from SeRP data involves a comparative analysis between enriched (IP) and control (total) ribo-seq libraries. Regions bound by the target factor are expected to show elevated ribosome occupancy in the IP library relative to the total library. These regions can be divided broadly into two categories:\nStrong binding regions: Sites where the enrichment ratio (IP / total) is significantly elevated over background and sustained across multiple nucleotides or codons. Weak binding regions: Sites with moderate enrichment relative to local background (e.g., the first 90 nt of a gene), which may reflect transient or low-affinity interactions but remain biologically meaningful when reproducible. The riboTransVis package provides two primary methods for binding region identification:\nAccurate detection of binding regions enables downstream interpretation of ribosome-associated regulatory events, including translation stalling, RNA-binding protein activity, and co-translational regulation, providing new insights into gene expression control at the post-transcriptional level.",
    "crumbs": [
      "Binding region detection"
    ]
  },
  {
    "objectID": "Binding-peaks-detection.html#introduction",
    "href": "Binding-peaks-detection.html#introduction",
    "title": "Binding region detection",
    "section": "",
    "text": "find_strong_peaks(): Detects high-confidence binding peaks by computing the local enrichment (IP vs. total RPMs) along transcripts, using configurable smoothing and peak-calling parameters. These peaks generally correspond to stable or high-affinity binding sites.\nfind_weak_peaks(): Identifies lower-intensity peaks by comparing IP signal to transcript-specific background (e.g., first 90 nt). This is useful for detecting subtle footprint signatures that may be functionally relevant but not strongly enriched over total signal. Both methods support flexible settings for signal smoothing, read length filtering, peak width constraints, and output resolution (nucleotide- or codon-level). Additionally, P-site offset correction can be applied to align reads precisely to functional ribosome positions.",
    "crumbs": [
      "Binding region detection"
    ]
  },
  {
    "objectID": "Binding-peaks-detection.html#example",
    "href": "Binding-peaks-detection.html#example",
    "title": "Binding region detection",
    "section": "Example",
    "text": "Example\nFinding strong binded peaks:\n\nstrp &lt;- find_strong_peaks(object = obj, \n                          do_offset_correct = T,\n                          smooth = TRUE,\n                          window_size = 45,\n                          enrichment_threshold = 1.5,\n                          binding_width = 15,\n                          mode = \"codon\")\n# check\nhead(strp)\n#      sample sample_group             rname above start end mean_ratio binding_width\n# 1 ssb1_rep1         ssb1    Q0055_mRNA|AI2  TRUE   127 142   2.492493            16\n# 2 ssb1_rep1         ssb1   Q0130_mRNA|OLI1  TRUE    61  69   2.881696             9\n# 3 ssb1_rep1         ssb1   Q0250_mRNA|COX2  TRUE   133 139   3.882078             7\n# 4 ssb1_rep1         ssb1   Q0250_mRNA|COX2  TRUE   196 205   2.150074            10\n# 5 ssb1_rep1         ssb1   Q0275_mRNA|COX3  TRUE   249 262   3.036979            14\n# 6 ssb1_rep1         ssb1 YAL001C_mRNA|TFC3  TRUE    71  89   3.989795            19\n\nFinding weakbinded peaks:\n\nwakp &lt;- find_weak_peaks(object = obj, \n                        do_offset_correct = T,\n                        smooth = TRUE,\n                        window_size = 45,\n                        enrichment_threshold = 3,\n                        binding_width = 15)\n\nhead(wakp)\n#      sample sample_group          rname above start end mean_ratio binding_width\n# 1 ssb1_rep1         ssb1 Q0050_mRNA|AI1  TRUE   132 176   4.899083            45\n# 2 ssb1_rep1         ssb1 Q0050_mRNA|AI1  TRUE   201 243   4.723704            43\n# 3 ssb1_rep1         ssb1 Q0050_mRNA|AI1  TRUE   275 324  26.438532            50\n# 4 ssb1_rep1         ssb1 Q0050_mRNA|AI1  TRUE   440 458   3.302752            19\n# 5 ssb1_rep1         ssb1 Q0050_mRNA|AI1  TRUE   506 551   5.600319            46\n# 6 ssb1_rep1         ssb1 Q0050_mRNA|AI1  TRUE   619 646   3.302752            28",
    "crumbs": [
      "Binding region detection"
    ]
  },
  {
    "objectID": "m6A-modulates-translation.html",
    "href": "m6A-modulates-translation.html",
    "title": "\n19  m6A modulates translation efficiency\n",
    "section": "",
    "text": "19.1 Intro\nIn this section, we reproduce key findings from a seminal 2015 Cell paper titled “N6-methyladenosine Modulates Messenger RNA Translation Efficiency.” Our focus centers on recreating the cumulative distribution curves that elegantly demonstrate how YTHDF1 knockdown affects both RNA stability and translational efficiency.\nCumulative distribution curves serve as powerful analytical tools in transcriptomic studies, providing comprehensive insights into the overall distribution characteristics of gene expression data. These curves are particularly valuable for visualizing global shifts in expression patterns and identifying systematic changes across entire transcriptomes.",
    "crumbs": [
      "More examples",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>m6A modulates translation efficiency</span>"
    ]
  },
  {
    "objectID": "m6A-modulates-translation.html#data-download",
    "href": "m6A-modulates-translation.html#data-download",
    "title": "\n19  m6A modulates translation efficiency\n",
    "section": "\n19.2 Data download",
    "text": "19.2 Data download\nFirst, we need to download the ribosome profiling (Ribo-seq) data from the original study. The data is deposited in the Gene Expression Omnibus (GEO) under accession number GSE63591:\n\n\n\n\nDownload data by aspera:\n\n#!/usr/bin/env bash\nascp -QT -l 300m -P33001 -i $HOME/.aspera/connect/etc/asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:vol1/fastq/SRR166/001/SRR1661491/SRR1661491.fastq.gz . && mv SRR1661491.fastq.gz rep1-SiControl-RPF.fastq.gz\nascp -QT -l 300m -P33001 -i $HOME/.aspera/connect/etc/asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:vol1/fastq/SRR166/005/SRR1661495/SRR1661495.fastq.gz . && mv SRR1661495.fastq.gz rep2-SiControl-RPF.fastq.gz\nascp -QT -l 300m -P33001 -i $HOME/.aspera/connect/etc/asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:vol1/fastq/SRR166/003/SRR1661493/SRR1661493.fastq.gz . && mv SRR1661493.fastq.gz rep1-SiYTHDF1_1-RPF.fastq.gz\nascp -QT -l 300m -P33001 -i $HOME/.aspera/connect/etc/asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:vol1/fastq/SRR166/007/SRR1661497/SRR1661497.fastq.gz . && mv SRR1661497.fastq.gz rep2-SiYTHDF1_8-RPF.fastq.gz\nascp -QT -l 300m -P33001 -i $HOME/.aspera/connect/etc/asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:vol1/fastq/SRR166/008/SRR1661498/SRR1661498.fastq.gz . && mv SRR1661498.fastq.gz rep2-SiYTHDF1_8-input.fastq.gz\nascp -QT -l 300m -P33001 -i $HOME/.aspera/connect/etc/asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:vol1/fastq/SRR166/002/SRR1661492/SRR1661492.fastq.gz . && mv SRR1661492.fastq.gz rep1-SiControl-input.fastq.gz\nascp -QT -l 300m -P33001 -i $HOME/.aspera/connect/etc/asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:vol1/fastq/SRR166/004/SRR1661494/SRR1661494.fastq.gz . && mv SRR1661494.fastq.gz rep1-SiYTHDF1_1-input.fastq.gz\nascp -QT -l 300m -P33001 -i $HOME/.aspera/connect/etc/asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:vol1/fastq/SRR166/006/SRR1661496/SRR1661496.fastq.gz . && mv SRR1661496.fastq.gz rep2-SiControl-input.fastq.gz",
    "crumbs": [
      "More examples",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>m6A modulates translation efficiency</span>"
    ]
  },
  {
    "objectID": "m6A-modulates-translation.html#alignment-to-reference",
    "href": "m6A-modulates-translation.html#alignment-to-reference",
    "title": "\n19  m6A modulates translation efficiency\n",
    "section": "\n19.3 Alignment to reference",
    "text": "19.3 Alignment to reference\nAfter quality control assessment using FastQC software, the results indicated no adapter sequences were present in the data, allowing us to proceed directly to genome alignment. We performed genome alignment using HISAT2 with the following parameters:\n\nfor i in rep1-SiControl-input rep1-SiControl-RPF rep1-SiYTHDF1_1-input rep1-SiYTHDF1_1-RPF rep2-SiControl-input rep2-SiControl-RPF rep2-SiYTHDF1_8-input rep2-SiYTHDF1_8-RPF\ndo\n    hisat2 -p 20 -x ../../index-data/grch38_hisat2_index/genome \\\n        --summary-file ${i}.mapinfo.txt \\\n        -U ../1.raw-data/${i}.fastq.gz \\\n        |samtools sort -@ 20 -o ${i}.sorted.bam\ndone\n\nls ./*.bam | xargs -i samtools index -@ 20 {}",
    "crumbs": [
      "More examples",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>m6A modulates translation efficiency</span>"
    ]
  },
  {
    "objectID": "m6A-modulates-translation.html#constructing-the-ribotrans-object",
    "href": "m6A-modulates-translation.html#constructing-the-ribotrans-object",
    "title": "\n19  m6A modulates translation efficiency\n",
    "section": "\n19.4 Constructing the ribotrans object",
    "text": "19.4 Constructing the ribotrans object\nNext, we construct RiboTrans objects from the aligned BAM files to facilitate downstream analysis of ribosome profiling data:\n\nsetwd(\"~/junjun_proj/34.ythdf1_ribo/2.map-data/\")\ngetwd()\n\n\ndevtools::install_github(\"junjunlab/riboTransVis\",force = TRUE)\nlibrary(riboTransVis)\n\ngp &lt;- c(\"siControl-rep1\",\"siControl-rep2\",\"siYTHDF1-rep1\",\"siYTHDF1-rep2\")\n\nrnabams &lt;- c(\"rep1-SiControl-input.sorted.bam\",\n             \"rep2-SiControl-input.sorted.bam\",\n             \"rep1-SiYTHDF1_1-input.sorted.bam\",\n             \"rep2-SiYTHDF1_8-input.sorted.bam\")\n\nribobams &lt;- c(\"rep1-SiControl-RPF.sorted.bam\",\n              \"rep2-SiControl-RPF.sorted.bam\",\n              \"rep1-SiYTHDF1_1-RPF.sorted.bam\",\n              \"rep2-SiYTHDF1_8-RPF.sorted.bam\")\n\nobj &lt;- construct_ribotrans(gtf_file = \"./Homo_sapiens.GRCh38.114.gtf.gz\",\n                           RNA_bam_file = rnabams,\n                           RNA_sample_name = gp,\n                           mapping_type = \"genome\",\n                           assignment_mode = \"end5\",\n                           Ribo_bam_file = ribobams,\n                           Ribo_sample_name = gp,\n                           choose_longest_trans = T)\n\n\n19.4.1 QC for ribo-seq\nReads length and frames check:\n\n# ==============================================================================\n# QC\n# ==============================================================================\nobj &lt;- generate_summary(object = obj,exp_type = \"ribo\", nThreads = 40)\n\nlength_plot(obj,type = \"frame_length\") +\n  scale_fill_brewer(palette = \"Greens\",direction = -1)\n\n\n\n\n\nOffset check:\n\nrelative_offset_plot(obj)",
    "crumbs": [
      "More examples",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>m6A modulates translation efficiency</span>"
    ]
  },
  {
    "objectID": "m6A-modulates-translation.html#reads-counting",
    "href": "m6A-modulates-translation.html#reads-counting",
    "title": "\n19  m6A modulates translation efficiency\n",
    "section": "\n19.5 Reads counting",
    "text": "19.5 Reads counting\nCounting reads for rna and rpf samples:\n\n# ==============================================================================\n# COUNT\n# ==============================================================================\n\nobj &lt;- get_counts(obj, nThreads = 15)\n\n# obj &lt;- get_counts(obj, nThreads = 15, ribo_feature = \"exon\")\n\nrna &lt;- obj@counts$rna$counts\nrpf &lt;- obj@counts$rpf$counts\n\ncc &lt;- cor_plot(data = rna,x = \"siControl-rep1\",y = \"siControl-rep2\")\ncy &lt;- cor_plot(data = rna,x = \"siYTHDF1-rep1\",y = \"siYTHDF1-rep2\")\n\nccf &lt;- cor_plot(data = rna,x = \"siControl-rep1\",y = \"siControl-rep2\")\ncyf &lt;- cor_plot(data = rna,x = \"siYTHDF1-rep1\",y = \"siYTHDF1-rep2\")\n\nlibrary(patchwork)\n(cc + cy) / (ccf + cyf)",
    "crumbs": [
      "More examples",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>m6A modulates translation efficiency</span>"
    ]
  },
  {
    "objectID": "m6A-modulates-translation.html#differential-analysis",
    "href": "m6A-modulates-translation.html#differential-analysis",
    "title": "\n19  m6A modulates translation efficiency\n",
    "section": "\n19.6 Differential analysis",
    "text": "19.6 Differential analysis\nPerform differential analysis separately for the RNA-seq (input), the Ribo-seq (RPF) and TE (translation efficiency). First, we download the information on YTHDF1 binding targets and non-binding targets provided by the paper and import it:\n\n# ==============================================================================\n# Differential analysis\n# ==============================================================================\ntt &lt;- readxl::read_xlsx(\"1-s2.0-S0092867415005620-mmc2.xlsx\",skip = 1)[,1:2] %&gt;% \n  na.omit()\n\ncolnames(tt) &lt;- c(\"bind\",\"gene\")\n\n# filter\ntt &lt;- tt %&gt;% \n  dplyr::filter(bind %in% c(\"CLIP only target\",\"CLIP+IP target\",\n                            \"Non-target\"))\n\n# check\ntable(tt$bind)\n# CLIP only target   CLIP+IP target       Non-target \n#             3652             1261             2822 \n\nRNA-seq differential analysis and plot cumulative curve:\n\n# rna\ndiff.rna &lt;- gene_differential_analysis(obj, \n                                       type = \"rna\",\n                                       control_samples = c(\"siControl-rep1\",y = \"siControl-rep2\"),\n                                       treat_samples = c(\"siYTHDF1-rep1\",y = \"siYTHDF1-rep2\"))\n\n# add binding type\ndiff.rna.anno &lt;- diff.rna %&gt;% \n  dplyr::inner_join(y = tt,by = c(\"gene_name\" = \"gene\"))\n\n\nlibrary(ggplot2)\nlibrary(ggsci)\n\n# plot\nggplot(diff.rna.anno) +\n  stat_ecdf(aes(x = log2FoldChange, color = bind)) +\n  theme_bw() +\n  theme(panel.grid = element_blank(),\n        aspect.ratio = 1,\n        axis.text = element_text(colour = \"black\")) +\n  scale_color_manual(values = c(\"Non-target\" = \"grey50\",\n                                \"CLIP only target\" = \"blue\",\n                                \"CLIP+IP target\" = \"red\"),\n                     name = \"Binding type\")+\n  xlim(-1.5,1.5) +\n  ylab(\"Cumulative Fraction\") +\n  xlab(\"log2(siYTHDF1/siControl)\\nmRNA Input\")\n\n\n\n\n\nRibo-seq (RPF) differential analysis and plot cumulative curve:\n\n# rpf\ndiff.ribo &lt;- gene_differential_analysis(obj, \n                                        type = \"ribo\",\n                                        control_samples = c(\"siControl-rep1\",y = \"siControl-rep2\"),\n                                        treat_samples = c(\"siYTHDF1-rep1\",y = \"siYTHDF1-rep2\"))\n\n# add binding type\ndiff.ribo.anno &lt;- diff.ribo %&gt;% \n  dplyr::inner_join(y = tt,by = c(\"gene_name\" = \"gene\"))\n\n# plot\nggplot(diff.ribo.anno) +\n  stat_ecdf(aes(x = log2FoldChange, color = bind)) +\n  theme_bw() +\n  theme(panel.grid = element_blank(),\n        aspect.ratio = 1,\n        axis.text = element_text(colour = \"black\")) +\n  scale_color_manual(values = c(\"Non-target\" = \"grey50\",\n                                \"CLIP only target\" = \"blue\",\n                                \"CLIP+IP target\" = \"red\"),\n                     name = \"Binding type\") +\n  xlim(-1.5,1.5) +\n  ylab(\"Cumulative Fraction\") +\n  xlab(\"log2(siYTHDF1/siControl)\\nRibosome bound fragments\")\n\n\n\n\n\nTranslation efficiency (TE) differential analysis and plot cumulative curve:\n\n# ==============================================================================\n# te\n# ==============================================================================\n\n# use riborex for te analysis\nte.rex &lt;- TE_differential_analysis(object = obj,\n                                   pkg = \"riborex\",\n                                   control_samples = c(\"siControl-rep1\",y = \"siControl-rep2\"),\n                                   treat_samples = c(\"siYTHDF1-rep1\",y = \"siYTHDF1-rep2\"))\n\nte &lt;- te.rex$deg_anno\n\n# add binding type\ndiff.te.anno &lt;- te %&gt;% \n  dplyr::inner_join(y = tt,by = c(\"gene_name\" = \"gene\"))\n\n# plot\nggplot(diff.te.anno) +\n  stat_ecdf(aes(x = log2FoldChange, color = bind)) +\n  theme_bw() +\n  theme(panel.grid = element_blank(),\n        aspect.ratio = 1,\n        axis.text = element_text(colour = \"black\")) +\n  scale_color_manual(values = c(\"Non-target\" = \"grey50\",\n                                \"CLIP only target\" = \"blue\",\n                                \"CLIP+IP target\" = \"red\"),\n                     name = \"Binding type\") +\n  xlim(-1.5,1.5) +\n  ylab(\"Cumulative Fraction\") +\n  xlab(\"log2(siYTHDF1/siControl)\\nTranslation efficiency\")\n\n\n\n\n\nThe following results is from original paper in figure 2:",
    "crumbs": [
      "More examples",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>m6A modulates translation efficiency</span>"
    ]
  },
  {
    "objectID": "m6A-modulates-translation.html#cumulative-curve-for-each-replicate",
    "href": "m6A-modulates-translation.html#cumulative-curve-for-each-replicate",
    "title": "\n19  m6A modulates translation efficiency\n",
    "section": "\n19.7 Cumulative curve for each replicate",
    "text": "19.7 Cumulative curve for each replicate\nThe original paper also presented the distribution of ECDF (empirical cumulative distribution function) curves for RNA, RPF, and TE across individual biological replicates. Here, we need to obtain the normalized values for each sample, and then use the ratios between TE or RNA/RPF in siYTHDF1 and siControl to plot the cumulative distribution curves for each biological replicate:\n\n# ==============================================================================\n# normalized values\n# ==============================================================================\n\nnorm &lt;- get_normalized_reads(object = obj,\n                             type = c(\"rna\", \"ribo\", \"te\"))\n\n# ==============================================================================\n# rna\n\n# add binding type\nnorm.rna &lt;- norm$tpm.rna %&gt;% \n  dplyr::inner_join(y = tt %&gt;% dplyr::filter(bind != \"CLIP only target\"),\n                    by = c(\"gene_name\" = \"gene\")) %&gt;% \n  dplyr::mutate(logrep1 = log2(`siYTHDF1-rep1`/`siControl-rep1`),\n                logrep2 = log2(`siYTHDF1-rep2`/`siControl-rep2`))\n\n\n# rna ecdf plot\nrna.rep1 &lt;-\nggplot(norm.rna) +\n  stat_ecdf(aes(x = logrep1, color = bind)) +\n  theme_bw() +\n  theme(panel.grid = element_blank(),\n        aspect.ratio = 1,\n        axis.text = element_text(colour = \"black\")) +\n  scale_color_manual(values = c(\"Non-target\" = \"grey50\",\n                                \"CLIP+IP target\" = \"red\"),\n                     name = \"Binding type\")+\n  xlim(-2,2) +\n  ylab(\"Cumulative Fraction\") +\n  xlab(\"log2(siYTHDF1/siControl)\\nmRNA Input\") +\n  ggtitle(\"Rep1\")\n\nrna.rep2 &lt;-\n  ggplot(norm.rna) +\n  stat_ecdf(aes(x = logrep2, color = bind)) +\n  theme_bw() +\n  theme(panel.grid = element_blank(),\n        aspect.ratio = 1,\n        axis.text = element_text(colour = \"black\")) +\n  scale_color_manual(values = c(\"Non-target\" = \"grey50\",\n                                \"CLIP+IP target\" = \"red\"),\n                     name = \"Binding type\")+\n  xlim(-2,2) +\n  ylab(\"Cumulative Fraction\") +\n  xlab(\"log2(siYTHDF1/siControl)\\nmRNA Input\") +\n  ggtitle(\"Rep2\")\n\n# ==============================================================================\n# rpf\n\n# add binding type\nnorm.rpf &lt;- norm$tpm.ribo %&gt;% \n  dplyr::inner_join(y = tt %&gt;% dplyr::filter(bind != \"CLIP only target\"),\n                    by = c(\"gene_name\" = \"gene\")) %&gt;% \n  dplyr::mutate(logrep1 = log2(`siYTHDF1-rep1`/`siControl-rep1`),\n                logrep2 = log2(`siYTHDF1-rep2`/`siControl-rep2`))\n\n\n# rpf ecdf plot\nrpf.rep1 &lt;-\n  ggplot(norm.rpf) +\n  stat_ecdf(aes(x = logrep1, color = bind)) +\n  theme_bw() +\n  theme(panel.grid = element_blank(),\n        aspect.ratio = 1,\n        axis.text = element_text(colour = \"black\")) +\n  scale_color_manual(values = c(\"Non-target\" = \"grey50\",\n                                \"CLIP+IP target\" = \"red\"),\n                     name = \"Binding type\")+\n  xlim(-2,2) +\n  ylab(\"Cumulative Fraction\") +\n  xlab(\"log2(siYTHDF1/siControl)\\nRibosome bound fragments\") +\n  ggtitle(\"Rep1\")\n\nrpf.rep2 &lt;-\n  ggplot(norm.rpf) +\n  stat_ecdf(aes(x = logrep2, color = bind)) +\n  theme_bw() +\n  theme(panel.grid = element_blank(),\n        aspect.ratio = 1,\n        axis.text = element_text(colour = \"black\")) +\n  scale_color_manual(values = c(\"Non-target\" = \"grey50\",\n                                \"CLIP+IP target\" = \"red\"),\n                     name = \"Binding type\")+\n  xlim(-2,2) +\n  ylab(\"Cumulative Fraction\") +\n  xlab(\"log2(siYTHDF1/siControl)\\nRibosome bound fragments\") +\n  ggtitle(\"Rep2\")\n  \n# ==============================================================================\n# te\n# add binding type\nnorm.te &lt;- norm$te %&gt;% \n  dplyr::inner_join(y = tt %&gt;% dplyr::filter(bind != \"CLIP only target\"),\n                    by = c(\"gene_name\" = \"gene\")) %&gt;% \n  dplyr::mutate(logrep1 = log2(`siYTHDF1-rep1`/`siControl-rep1`),\n                logrep2 = log2(`siYTHDF1-rep2`/`siControl-rep2`))\n\n\n# te ecdf plot\nte.rep1 &lt;-\n  ggplot(norm.te) +\n  stat_ecdf(aes(x = logrep1, color = bind)) +\n  theme_bw() +\n  theme(panel.grid = element_blank(),\n        aspect.ratio = 1,\n        axis.text = element_text(colour = \"black\")) +\n  scale_color_manual(values = c(\"Non-target\" = \"grey50\",\n                                \"CLIP+IP target\" = \"red\"),\n                     name = \"Binding type\")+\n  xlim(-2,2) +\n  ylab(\"Cumulative Fraction\") +\n    xlab(\"log2(siYTHDF1/siControl)\\nTranslation efficiency\") +\n  ggtitle(\"Rep1\")\n\nte.rep2 &lt;-\n  ggplot(norm.te) +\n  stat_ecdf(aes(x = logrep2, color = bind)) +\n  theme_bw() +\n  theme(panel.grid = element_blank(),\n        aspect.ratio = 1,\n        axis.text = element_text(colour = \"black\")) +\n  scale_color_manual(values = c(\"Non-target\" = \"grey50\",\n                                \"CLIP+IP target\" = \"red\"),\n                     name = \"Binding type\")+\n  xlim(-2,2) +\n  ylab(\"Cumulative Fraction\") +\n  xlab(\"log2(siYTHDF1/siControl)\\nTranslation efficiency\") +\n  ggtitle(\"Rep2\")\n\n\n# combine\n(rpf.rep1 + rna.rep1 + te.rep1) / (rpf.rep2 + rna.rep2 + te.rep2)\n\n\n\n\n\nIt can be seen that replicate 2 does not perform very well and is not quite consistent with the results reported in the original paper. The following results is from original paper in figure S2:",
    "crumbs": [
      "More examples",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>m6A modulates translation efficiency</span>"
    ]
  },
  {
    "objectID": "m6A-modulates-translation.html#using-orignal-data",
    "href": "m6A-modulates-translation.html#using-orignal-data",
    "title": "\n19  m6A modulates translation efficiency\n",
    "section": "\n19.8 Using orignal data",
    "text": "19.8 Using orignal data\nWe can use the pre-calculated data provided in the paper to replot the ECDF curves:\n\n# ==============================================================================\n# gse data\n# ==============================================================================\n\ndt &lt;- read.csv(\"gse_siYTHDF1.csv\") %&gt;% \n  dplyr::inner_join(y = tt %&gt;% dplyr::filter(bind != \"CLIP only target\"),\n                    by = c(\"Gene.symbol\" = \"gene\"))\n\ncolnames(dt)\n# [1] \"Gene.symbol\" \"ribo.rep1\"   \"rna.rep1\"    \"te.rep1\"     \"ribo.rep2\"   \"rna.rep2\"    \"te.rep2\"     \"bind\"\n\nrna.rep1 &lt;-\n  ggplot(dt) +\n  stat_ecdf(aes(x = rna.rep1, color = bind)) +\n  theme_bw() +\n  theme(panel.grid = element_blank(),\n        aspect.ratio = 1,\n        axis.text = element_text(colour = \"black\")) +\n  scale_color_manual(values = c(\"Non-target\" = \"grey50\",\n                                \"CLIP+IP target\" = \"red\"),\n                     name = \"Binding type\")+\n  xlim(-2,2) +\n  ylab(\"Cumulative Fraction\") +\n  xlab(\"log2(siYTHDF1/siControl)\\nmRNA Input\") +\n  ggtitle(\"Rep1\")\n\nrna.rep2 &lt;-\n  ggplot(dt) +\n  stat_ecdf(aes(x = rna.rep2, color = bind)) +\n  theme_bw() +\n  theme(panel.grid = element_blank(),\n        aspect.ratio = 1,\n        axis.text = element_text(colour = \"black\")) +\n  scale_color_manual(values = c(\"Non-target\" = \"grey50\",\n                                \"CLIP+IP target\" = \"red\"),\n                     name = \"Binding type\")+\n  xlim(-2,2) +\n  ylab(\"Cumulative Fraction\") +\n  xlab(\"log2(siYTHDF1/siControl)\\nmRNA Input\") +\n  ggtitle(\"Rep2\")\n\n# rpf ecdf plot\nrpf.rep1 &lt;-\n  ggplot(dt) +\n  stat_ecdf(aes(x = ribo.rep1, color = bind)) +\n  theme_bw() +\n  theme(panel.grid = element_blank(),\n        aspect.ratio = 1,\n        axis.text = element_text(colour = \"black\")) +\n  scale_color_manual(values = c(\"Non-target\" = \"grey50\",\n                                \"CLIP+IP target\" = \"red\"),\n                     name = \"Binding type\")+\n  xlim(-2,2) +\n  ylab(\"Cumulative Fraction\") +\n  xlab(\"log2(siYTHDF1/siControl)\\nRibosome bound fragments\") +\n  ggtitle(\"Rep1\")\n\nrpf.rep2 &lt;-\n  ggplot(dt) +\n  stat_ecdf(aes(x = ribo.rep2, color = bind)) +\n  theme_bw() +\n  theme(panel.grid = element_blank(),\n        aspect.ratio = 1,\n        axis.text = element_text(colour = \"black\")) +\n  scale_color_manual(values = c(\"Non-target\" = \"grey50\",\n                                \"CLIP+IP target\" = \"red\"),\n                     name = \"Binding type\")+\n  xlim(-2,2) +\n  ylab(\"Cumulative Fraction\") +\n  xlab(\"log2(siYTHDF1/siControl)\\nRibosome bound fragments\") +\n  ggtitle(\"Rep2\")\n\n\n# te ecdf plot\nte.rep1 &lt;-\n  ggplot(dt) +\n  stat_ecdf(aes(x = te.rep1, color = bind)) +\n  theme_bw() +\n  theme(panel.grid = element_blank(),\n        aspect.ratio = 1,\n        axis.text = element_text(colour = \"black\")) +\n  scale_color_manual(values = c(\"Non-target\" = \"grey50\",\n                                \"CLIP+IP target\" = \"red\"),\n                     name = \"Binding type\")+\n  xlim(-2,2) +\n  ylab(\"Cumulative Fraction\") +\n  xlab(\"log2(siYTHDF1/siControl)\\nTranslation efficiency\") +\n  ggtitle(\"Rep1\")\n\nte.rep2 &lt;-\n  ggplot(dt) +\n  stat_ecdf(aes(x = te.rep2, color = bind)) +\n  theme_bw() +\n  theme(panel.grid = element_blank(),\n        aspect.ratio = 1,\n        axis.text = element_text(colour = \"black\")) +\n  scale_color_manual(values = c(\"Non-target\" = \"grey50\",\n                                \"CLIP+IP target\" = \"red\"),\n                     name = \"Binding type\")+\n  xlim(-2,2) +\n  ylab(\"Cumulative Fraction\") +\n  xlab(\"log2(siYTHDF1/siControl)\\nTranslation efficiency\") +\n  ggtitle(\"Rep2\")\n\n\n# combine\n(rpf.rep1 + rna.rep1 + te.rep1) / (rpf.rep2 + rna.rep2 + te.rep2)",
    "crumbs": [
      "More examples",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>m6A modulates translation efficiency</span>"
    ]
  }
]